#!/usr/bin/env perl

# gedcom - produce data from a gedcom file

# Author Nigel Horne: njh@bandsman.co.uk
# Copyright (C) 2015-2024, Nigel Horne

# Usage is subject to licence terms.
# The licence terms of this software are as follows:
# Personal single user, single computer use: GPL2
# All other users (including Commercial, Charity, Educational, Government)
#	must apply in writing for a licence for use from Nigel Horne at the
#	above e-mail.

# FIXME: -a Goes through the entire file once for each day without remembering
#	anything
# TODO: add option to print in generations order rather than date order
# TODO: write a post-processor to sort errors by type
# TODO: -i restrict to selectable types of anniversaries - currently does
#	all BMD, baptism and burials
# TODO: look at census records to note the different places that a person's children
#	were born and note if the residences of the person don't include those places
# TODO: add an option for -Adw to create output as a CSV
# TODO:	remove date_to_datetime
# TODO: finish the -M option.  Note that UK is:
#	https://static-maps.yandex.ru/1.x/?lang=en_US&ll=-2.51,54.20&z=5&l=map&size=650,450
#	Put the year on to the map as text
# TODO: add extract_year_from_date - given a string or various record types
# TODO: flag if census locations are XYX and Y is more than (say) 50 miles from X
# TODO:	Cornwall = la Coronouaille in French
# TODO: If someone lives in a place smaller than, say 1,000 inhabitants, say it's
#	"20 miles from xxx - where xxx is a place of at least 10,000 people"
# TODO: investigate Locale::Geocode
# FIXME: with a US state you use 'en' not Ã 
# TODO: Investigate List::ToHumanString and Lingua::EN::Sentence
# TODO: Investigate Lingua::FR::Numbers
# TODO: Investigate Locale::Maketext
# TODO: Investigate Carp::Assert::More
# TODO: https://funeral-notices.co.uk/Isle+of+Thanet+Gazette/all-announcements?keyword_search=spratt&cluster=112&loc_search=true
# TODO: consider Data::Dumper::Names instead of Data::Dumper
# TODO: investigate User::Identity
# TODO: fix utf-8 in PDF by adding support for unicode fonts
# TODO: use Geo::Coder::Abreviate->normalize once that's completed

# dnf install langpacks-fr glibc-all-langpacks -y

use 5.020;
use strict;
use warnings;
# use open qw(:std :utf8);	# Do not use, it breaks printing
	# HTTP::Response->decoded_content() to a file
# no feature qw(indirect);
# use feature qw(signatures);
# no warnings qw(experimental::signatures);

no lib '.';

use	constant	ASSUME_NOT_LIVING => 120;

my @needfull;

# Install Pre-requisites
BEGIN {
	my @modules = (
		'Array::Iterator', 'Data::Section::Simple', 'Date::Manip',
		'FindBin', 'Gedcom', 'Genealogy::Gedcom::Date',
		'Date::Parse', 'IPC::System::Simple',
		'CHI', 'File::HomeDir', 'String::Compare',
		'HTML::Entities',
		'Lingua::Conjunction',
		'Lingua::EN::NameCase', 'Lingua::EN::NameParse',
		'Lingua::EN::ABC', 'Lingua::String',
		'Lingua::EN::Inflect', 'DateTime::Format::Natural',
		'Locale::AU', 'Locale::CA', 'Locale::US',
		'Data::Text', 'DateTime::Format::Genealogy', 'Parse::RecDescent',
		'Mozilla::CA',
		'Sort::Key::DateTime', 'Text::Names::GB',
		'Class::Simple::Cached', 'Class::Simple::Readonly::Cached',
		'File::Spec', 'Net::OAuth',
		# 'Geo-Coder-PlaceFinder-0.1.tar.gz'
		'Getopt::Std', 'File::Basename', 'Locale::Object::Country', 'Term::ANSIColor',
		'Geo::Coder::Abbreviations',
		'Roman', 'Unicode::Diacritic::Strip',
		'utf8::all',
		# 'Devel::FIXME',
	);

	# I can't get Marpa::R2 versions 10 and 12 to build on Solaris.
	# It's used by Genealogy::Gedcom::Date, so force version 8
	eval 'use Marpa::R2';
	if($@) {
		if($^O eq 'solaris') {
			push @needfull, 'JKEGL/Marpa-R2-8.000000.tar.gz'
		} else {
			push @needfull, 'Marpa::R2';
		}
	}

	foreach my $module(@modules) {
		eval "use $module";
		if($@) {
			# Install module dependancies
			if($module =~ /(.+)\s/) {
				# Specific version not satisfied
				push @needfull, $1;
			} else {
				push @needfull, $module;
			}
		}
	}
	# Fix for this module not being found
	# https://cpan.metacpan.org/authors/id/G/GR/GRAY/Geo-Coder-PlaceFinder-0.05.tar.gz
	eval 'use Geo::Coder::PlaceFinder';
	if($@) {
		push @needfull, 'Net::OAuth', 'JSON', 'F/FR/FRIFFIN/Geo-Coder-PlaceFinder-0.1.tar.gz'
	}

	if(defined($ENV{'LANG'}) && ($ENV{'LANG'} =~ /^fr/)) {
		eval 'use Lingua::FR::Numbers::Ordinate';
		if($@) {
			# Apparently it's "unauthorized", but there's no other module with the same name
			push @needfull, 'N/NH/NHORNE/Lingua-FR-Numbers-Ordinate-0.03.tar.gz';
		}
	} else {
		if(defined($ENV{'LANG'}) && ($ENV{'LANG'} =~ /^fa/)) {
			eval 'use Lingua::FA::Number';
			if($@) {
				push @needfull, 'Lingua::FA::Number', 'HTML::Entities';
			}
		}
		eval 'use Lingua::EN::Numbers::Ordinate';
		if($@) {
			push @needfull, 'Lingua::EN::Numbers::Ordinate';
		}
	}

	if(scalar(@needfull)) {
		my $list = join(' ', @needfull);
		print "Installing $list\n";
		# system("cpan -i $list");
		$ENV{'PERL_MM_USE_DEFAULT'} = 1;
		system('perl -MCPAN -e \'CPAN::Shell->install("' . join('", "', @needfull) . '")\'');
	}
	# $Devel::FIXME::REPAIR_INC = 1;

	# FIXME
	$SIG{__WARN__} = sub {
		my $warning = shift;
		if(($warning !~ /Subroutine Geo::Coder::OpenCage::ua redefined at/) &&
		   ($warning !~ /Subroutine ua redefined at/) &&
		   ($warning !~ /Subroutine HTML::GoogleMaps::V3::_text_to_point redefined at/) &&
		   ($warning !~ /Subroutine Gedcom::Individual::relationship redefined at/)) {
			if(($warning =~ /^Use of uninitialized value/) ||
			   ($warning =~ /Wide/) ||
			   ($warning =~ /masks earlier declaration in same scope/) ||
			   ($warning =~ /: attempt to add consecutive punctuation/) ||
			   ($warning =~ /isn't numeric in numeric eq /i)) {
				die $warning;
			}
			utf8::decode($warning);
			warn $warning;
		}
	};
}

foreach my $module(@needfull) {
	my $version;
	if($module =~ /(.+)\s(.+)$/) {
		$module = $1;
		$version = $2;
	}
	if($module =~ /.+\/(.+)/) {
		$module = $1;
	}
	$module =~ s/\-/::/g;
	$module =~ s/\.tar\.gz$//;
	$module =~ s/::(\d)+$/ $1/;
	eval "require $module";
	if($@) {
		die $@;
	}
	$module->import();
	# if($version && ($module::VERSION < $version)) {
		# die "$module: need $version got ", $module::VERSION;
	# }
}

# use IPC::System::Simple;
use autodie qw(:all);
use Array::Iterator::BiDirectional;
# use diagnostics;
# use warnings::unused;

sub get_location($);

my %opts;
getopts('aAbB:cCdDe:fFGgh:Hi:m:M:lLOp:PrsStwWxvy:', \%opts);
die "Usage: $0 [ -a ] [ -A ] [ -b ] [ -B book.pdf ] [ -c ] [ -C ] [ -d ] [ -D ] [ -f ] [ -F ] [ -G ] [ -h home-person-name ] [ -H [ -L [ -e ] ] [ -i ics_file ] [ -M place ] [ -m month ] [ -y year ] ] [ -l ] [ -p person-to-print ] [ -P ] [ -r ] [ -s ] [ -S ] [ -t ] [ -w [ -W ] [ -g | -x ]] filename [ filename2 ]" unless($ARGV[0]);

print "Starting\n" if($opts{'v'});

my $me;
my @myancestors;
my @mydescendants;
my %printed;
my %places;
my %all_locations;
my %all_places;
my %all_residences;
my %all_occupations;
# my $pi = atan2(1,1) * 4;

# binmode(STDOUT, ':utf8');

my $ged = Gedcom->new(gedcom_file => $ARGV[0], read_only => 1);
my $nameparser = Lingua::EN::NameParse->new(extended_titles => 1, initials => 1);
if($opts{h}) {
	my @rc = $ged->get_individual($opts{h});
	if(scalar(@rc) == 0) {
		die "$0: Can't find '$opts{h}' in $ARGV[0]";
	} elsif(scalar(@rc) == 1) {
		$me = $rc[0];
	} elsif(!$opts{'x'}) {
		# Need top of family tree
		@rc = map { ($_->father() || $_->mother()) ? () : $_ } @rc;
		if(scalar(@rc) > 1) {
			my $i;
			do {
				$i = 0;
				print join("\n", map { $i++; "$i: " . $_->as_string({ include_years => 1, middle_names => 1 }) } @rc),
					"\nMore than one $opts{h} found - choose a line number: ";
				$i = <STDIN>;
			} while(!defined($i));
			chomp $i;
			$me = $rc[$i - 1];
		} else {
			$me = $rc[0];
		}
		die 'Incorrect line number' unless($me);
	}
}

if($opts{'f'}) {
	$opts{'w'} = 1;
}
if($opts{'P'}) {
	$opts{'r'} = 1;
}

die '-w option needs -d or -M option' if($opts{'w'} && (!$opts{'M'}) && !$opts{'d'});

my $language = get_language();

print "Language = $language\n" if($opts{'v'});

@needfull = ();
my @modules = ();
if($opts{'B'}) {
	# yum install gd-devel ImageMagick-devel
	my $magick;
	if($^O eq 'linux') {
		# Debian lacks ImageMagick-7
		$magick = 'Image::Magick 6.9.12-2';
	} else {
		$magick = 'Image::Magick';
	}
	push @modules, 'File::Temp', 'Image::Resize', $magick,
		'Image::Magick::Thumbnail',
		'NJH::PDFPage' ,'LWP::Simple::WithCache',
		'PDF::API2', 'PDF::API2::XS',
		'Text::Soundex', 'Text::Wrap';
} elsif($opts{'r'} || $opts{'i'} || $opts{'O'}) {
	if($opts{'i'}) {
		push @modules, 'Data::ICal', 'Date::ICal',
			'Data::ICal::Entry::Event',
			'Data::ICal::TimeZone', 'Data::ICal::DateTime';
	}
} elsif($opts{'H'}) {
	push @modules, 'HTML::Table', 'Text::Soundex';
} elsif($opts{'x'} || $opts{'g'} || $opts{'M'}) {
	push @modules, 'Text::Soundex';
} elsif($opts{'S'}) {
	push @modules, 'DBI';
} else {
	push @modules, 'GIS::Distance';
}
unless(($opts{'r'} || $opts{'O'} || $opts{'S'}) && !$opts{'v'}) {
	push @modules, 'Geo::Coder::List', 'Geo::Coder::Free', 'Geo::Coder::Free::Local',
		'Geo::Coder::CA', 'Geo::Coder::Postcodes',
		# 'Geo::Coder::DataScienceToolkit',
		'Geo::Coder::Ovi', 'Geo::Coder::RandMcnally', 'Geo::Coder::US::Census',
		'Geo::Coder::OSM', 'Geo::Coder::XYZ';
}
if($opts{'H'} || ($opts{'B'} && $opts{'h'})) {
	push @modules, 'DateTime::Locale';
}
if($opts{'A'} || $opts{'B'} || $opts{'G'} || $opts{'i'}) {
	push @modules, 'String::ProgressBar';
}
if($opts{'w'} || $opts{'B'} || $opts{'M'}) {
	push @modules, 'HTTP::Cache::Transparent', 'LWP::UserAgent::Cached', 'LWP::UserAgent::Throttled';
	if($opts{'M'}) {
		push @modules, 'IPC::Run';
	}
}
if(defined($language) && ($language ne 'English')) {
	push @modules, 'Locale::Country::Multilingual';
	if($language ne 'English') {
		push @modules, 'Locale::Places';
	}
}
if($opts{'w'}) {
	push @modules, 'Genealogy::ChroniclingAmerica', 'Genealogy::ObituaryDailyTimes', 'Genealogy::Wills', 'Locale::Country';
}
if($opts{'c'}) {
	push @modules, 'URI::Find::Schemeless';
}
if((!$opts{'O'}) && (!$opts{'r'}) && (!$opts{'S'})) {
	if($ENV{'GEO_CODER_OPENCAGE_API_KEY'}) {
		push @modules, 'Geo::Coder::OpenCage';
	}
	if($ENV{'GMAP_KEY'}) {
		push @modules, 'Geo::Coder::GooglePlaces';
	}
	if($ENV{BMAP_KEY}) {
		push @modules, 'Geo::Coder::Bing';
	}
	if($ENV{'GEONAMES_USER'}) {
		push @modules, 'Geo::GeoNames';
	}
}
if($ENV{'REDIS_SERVER'}) {
	push @modules, 'CHI::Driver::Redis';
}
if($opts{'d'}) {
	push @modules, 'Weather::Meteo', 'XML::Hash';
}
if($opts{'d'} || $opts{'B'}) {
	push @modules, 'DateTime::Format::Text';
}

if($opts{'v'}) {
	push @modules, 'Log::Any::Adapter';
}

my $libdir1 = File::Spec->catfile($FindBin::Bin, File::Spec->updir(), 'lib');
if(-d $libdir1) {
	unshift @INC, ($libdir1);
}
my $libdir2 = File::Spec->catfile(File::HomeDir->my_home(), 'lib');
if(($libdir2 ne $libdir1) && (-d $libdir2)) {
	unshift @INC, ($libdir2);
}

foreach my $module(@modules) {
	my $version;
	my $module_name;
	if($module =~ /(.+)\s(.+)$/) {
		$module_name = $1;
		$version = $2;
		eval "require $1";
	} else {
		eval "require $module";
	}
	if($@) {
		if($version) {
			my $s = `cpan -D $module_name | grep /`;

			chomp($s);
			$s =~ s/^\s+//;
			$s =~ s/(.+)\/.+/$1/;
			$module_name =~ s/::/-/g;

			# FIXME - could end in .tgz or even .zip
			push @needfull, "$s/$module_name-$version.tar.gz";
		} else {
			push @needfull, $module;
		}
	} else {
		$module->import();
	}
}

if(scalar(@needfull)) {
	my $list = join(' ', @needfull);
	print "Installing $list\n";
	# system("cpan -i $list");
	$ENV{'PERL_MM_USE_DEFAULT'} = 1;
	system('perl -MCPAN -e \'CPAN::Shell->install("' . join('", "', @needfull) . '")\'');
}

foreach my $module(@modules) {
	my $version;
	if($module =~ /(.+)\s(.+)$/) {
		$module = $1;
		$version = $2;
	}
	eval "require $module";
	if($@) {
		die $@;
	}
	$module->import();
	# if($version) {
		# $module->VERSION($version);
	# }
	# if($version && ($module::VERSION < $version)) {
		# die "$module: need $version got ", $module::VERSION;
	# }
}

umask(0077);	# Don't let PII become publicly readable

Lingua::Conjunction->separator_phrase(',');
Lingua::Conjunction->penultimate(0);

my $browser;
my $cached_browser;
my $au = Locale::AU->new();
my $ca_en = Locale::CA->new(lang => 'en');
my $ca_fr = Locale::CA->new(lang => 'fr');
my $us = Locale::US->new();
my $birth_country;
my $grave_modules;
if($opts{'w'} || $opts{'B'} || $opts{'M'}) {
	my $cache_dir = $ENV{'CACHE_DIR'};
	if($cache_dir) {
		mkdir $cache_dir, 02700 if(!-d $cache_dir);
		$cache_dir = File::Spec->catfile($cache_dir, 'lwp-cache');
	} else {
		# $cache_dir = File::Spec->catfile(File::Spec->tmpdir(), 'cache', 'lwp');
		$cache_dir = File::Spec->catfile(File::HomeDir->my_home(), '.cache', 'lwp-cache')
	}
	if(!-d $cache_dir) {
		mkdir $cache_dir, 02700 || die "$cache_dir: $!";
	}
	print "Cachedir $cache_dir\n" if($opts{'v'});
	$cached_browser = LWP::UserAgent::Cached->new(
		cache_dir => $cache_dir,
		agent => basename($0),
		keep_alive => 1,
		timeout => 30,
		cachename_spec => {
			_body => '',
			_headers => []
		},
	);
	$cached_browser->env_proxy(1);
	$cached_browser->conn_cache->total_capacity(undef);
	$cached_browser->ssl_opts(verify_hostname => 1, SSL_ca_file => Mozilla::CA::SSL_ca_file());

	$browser = LWP::UserAgent::Throttled->new(agent => basename($0), keep_alive => 1, timeout => 30);
	$browser->env_proxy(1);
	$browser->conn_cache->total_capacity(undef);
	$browser->default_header(accept_encoding => 'gzip,deflate');
	$browser->ua($cached_browser);

	# Cache calls to openstreetmap etc.
	$cache_dir = $ENV{'CACHE_DIR'};
	if($cache_dir) {
		$cache_dir = File::Spec->catfile($cache_dir, 'http-cache-transparent');
	} else {
		# $cache_dir = File::Spec->catfile(File::Spec->tmpdir(), 'cache', 'http-cache-transparent');
		$cache_dir = File::Spec->catfile(File::HomeDir->my_home(), '.cache', 'http-cache-transparent');
	}

	HTTP::Cache::Transparent::init({
		BasePath => $cache_dir,
		Verbose => $opts{'v'} ? 1 : 0,
		NoUpdate => 60 * 60 * 24,
		MaxAge => 30 * 24
	}) || die "$0: $cache_dir: $!";

	if($opts{'w'}) {
		# If you have a locally written module to look up entries,
		# list them in gedcom.config,
		# otherwise use WWW::Scrape::FindaGrave
		my $config;

		eval { $config = Config::Auto::parse() };

		if($config && $config->{'grave_modules'}) {
			$grave_modules = $config->{'grave_modules'};

			if(ref($grave_modules)) {
				foreach my $module(@{$grave_modules}) {
					autoload $module;
				}
			} else {
				autoload $grave_modules;
			}
		# } else {
			# require WWW::Scrape::FindaGrave;
			# WWW::Scrape::FindaGrave->import();
		}
		# if(!$ged->validate() && $opts{'f'}) {
			# die "$ARGV[0] is not a valid gedcom file";
		# }
	}
}

my $script_name = basename($0);
my $logger;
if($opts{'v'}) {
	Log::Any::Adapter->set('Stdout', log_level => 'trace');
	$logger = Log::Any->get_logger(category => $script_name);
}

my $places;
my $lcm;
if(defined($language) && ($language ne 'English')) {
	$places = Class::Simple::Readonly::Cached->new(object => Locale::Places->new(), cache => { });
	$lcm = Class::Simple::Readonly::Cached->new(object => Locale::Country::Multilingual->new(),
		cache => CHI->new(driver => 'RawMemory', datastore => {}));
}

my %all_dates;	# Maps dates to the hashref from Genealogy::Gedcom::Date

# Read in the $text table for translation
my $i18n;
if(my $data = Data::Section::Simple::get_data_section($language)) {
	my @lines = split /\n/, $data;
	foreach(@lines) {
		my ($english, $gender, $foreign) = split /:/;
		if($gender) {
			$i18n->{$english}->{$gender} = $foreign;
		} else {
			$i18n->{$english} = $foreign;
		}
	}
}

my $date_parser = Genealogy::Gedcom::Date->new();
my $dfn;
if(defined($language) && ($language eq 'French')) {
	# $dfn = DateTime::Format::Natural->new(format => 'dd/mm/yy', lang => 'fr');	 # not supported
	$dfn = DateTime::Format::Natural->new(format => 'dd/mm/yy');
	Date_Init("DateFormat=FR");	# Date::Manip
	$lcm->set_lang('fr');
} elsif((defined($ENV{'LC_TIME'}) && ($ENV{'LC_TIME'} =~ /^en_US/)) ||
	((defined($ENV{'LC_ALL'}) && ($ENV{'LC_ALL'} =~ /^en_US/)))) {
	$dfn = DateTime::Format::Natural->new();
	Date_Init("DateFormat=US");	# Date::Manip
	if(defined($lcm)) {
		$lcm->set_lang('en');
	}
} else {
	$dfn = DateTime::Format::Natural->new(format => 'dd/mm/yy');
	if(defined($language)) {
		Date_Init("Language=$language");	# Date::Manip
	} else {
		Date_Init("DateFormat=International");
	}
	if($lcm) {
		$lcm->set_lang(get_language_code() // 'en');
	}
}

my $dfg = DateTime::Format::Genealogy->new();
my $tz = $ENV{'TZ'} // DateTime::TimeZone->new(name => 'local');

# my $geocoder = Geo::Coder::List->new(cache => CHI->new(driver => 'Memcached', servers => [ '192.168.1.15:11211', '127.0.0.1:11211' ]));
my $cache_dir;
if(my $e = $ENV{'CACHE_DIR'}) {
	$cache_dir = File::Spec->catfile($e, basename($0));
} else {
	# $cache_dir = File::Spec->catfile(File::Spec->tmpdir(), 'cache', basename($0));
	$cache_dir = File::Spec->catfile(File::HomeDir->my_home(), '.cache', basename($0));
}

my $gopts;

if(my $redis = $ENV{'REDIS_SERVER'}) {
	$gopts->{'cache'} = CHI->new(
		driver => 'Redis',
		namespace => $script_name,
		server => $redis,
		l1_cache => { driver => 'RawMemory', global => 1, max_size => 1024*1024 },
		debug => $opts{'v'}
	);
} else {
	# FIXME: The location of the geo-coding cache should be configurable
	$gopts->{'cache'} = CHI->new(
		driver => 'File',
		root_dir => $cache_dir,
		l1_cache => { driver => 'RawMemory', global => 1, max_size => 1024*1024 }
	);
	# $gopts->{'cache'} = CHI->new(
		# driver => 'Memcached',
		# namespace => basename($0),
		# servers => [ '192.168.1.16:11211', '192.168.1.15:11211', '127.0.0.1:11211', '192.168.1.2:11211' ],
		# debug => $opts{'v'},
		# l1_cache => { driver => 'RawMemory', global => 1, max_size => 1024*1024 },
		# compress_threshold => 10_000
	# );
}

if($opts{'v'}) {
	$gopts->{'debug'} = 1;
}

my $geocoder;
my $textgeocoder;
if(((!$opts{'r'}) && (!$opts{'O'} && (!$opts{'S'}))) || $opts{'v'}) {
	$geocoder = Geo::Coder::List->new($gopts)->push(Geo::Coder::Free::Local->new());

	my %topts;
	if(my $oa = $ENV{'OPENADDR_HOME'}) {
		$topts{'openaddr'} = $oa;
	}
	if($logger) {
		$topts{'logger'} = $logger;
	}
	$topts{'cache_duration'} = '1 month';
	$topts{'cache'} = CHI->new(
		driver => 'File',
		root_dir => $cache_dir,
		l1_cache => { driver => 'RawMemory', global => 1, max_size => 1024*1024 }
	);
	$textgeocoder = Geo::Coder::Free->new(%topts);
	if($ENV{'OPENADDR_HOME'}) {
		# $geocoder->push({ regex => qr/,[\w\s]+,[\w\s]+$/, geocoder => $textgeocoder });
		# US, Canada and Australia are full
		# Counties and towns in the UK are full
		$geocoder->push({ regex => qr/,\s*(USA|US|United States|Canada|Australia)\s*$/, geocoder => $textgeocoder })
			->push({ regex => qr/^([\w\s]+,)?\s*[\w\s]+,\s*[\w\s]+\s*$/, geocoder => $textgeocoder });
	} else {
		$geocoder->push({ regex => qr/^[\w\s\-]+?,[\w\s]+,[\w\s]+?$/, geocoder => $textgeocoder })
			# E.g. 'Nebraska, USA'
			->push({ regex => qr/^[\w\s]+,\s*(UK|England|Canada|USA|US|United States)$/i, geocoder => $textgeocoder });
	}

	$geocoder->push({ regex => qr/^[\w\s]+,\s*[\w\s]+,\s*(UK|England|Wales|Scotland)$/i, geocoder => $textgeocoder });

	if(my $username = $ENV{'GEONAMES_USER'}) {
		$geocoder->push(Geo::GeoNames->new(username => $username));
	}

	# DST isn't that good for the UK
	# $geocoder->push({ regex => qr/(UK|United Kingdom|England|USA|US|United States|Wales)$/i, geocoder => Geo::Coder::DataScienceToolkit->new() })`
	$geocoder->push({ regex => qr/^\d.+?,.+?,\s*(USA|US|United States)$/i, geocoder => Geo::Coder::US::Census->new() })
		->push({ limit => 100, regex => qr/(Canada|USA|United States)$/, geocoder => Geo::Coder::CA->new() })
		->push({ regex => qr/^[\w\s-]+,\s*[\w\s]+,\s*(UK|United Kingdom|England|Wales)$/i, geocoder => Geo::Coder::Postcodes->new() })
		# ->push({ regex => qr/(USA|US|United States)$/i, geocoder => Geo::Coder::DataScienceToolkit->new() })	# Offline
		->push(Geo::Coder::OSM->new())
		->push({ regex => qr/(USA|US|United States)$/i, geocoder => Geo::Coder::RandMcnally->new() })
		# ->push({ limit => 200, geocoder => Geo::Coder::XYZ->new()})
		->push(Geo::Coder::Ovi->new());
		# ->push(Geo::Coder::GeocodeFarm->new());	# Needs GT#1 to be fixed

	if(my $key = $ENV{'GEO_CODER_OPENCAGE_API_KEY'}) {
		$geocoder->push({ limit => 200, geocoder => Geo::Coder::OpenCage->new(api_key => $key) });
	}
	if(my $key = $ENV{'GMAP_KEY'}) {
		my %gp_args = (apiver => 3);
		my $l = $ENV{'LANG'};
		if(defined($l) && ($l =~ /^([a-z]{2})/i)) {
			$gp_args{'language'} = lc($1);
		}
		$gp_args{'key'} = $key;
		$gp_args{'api_key'} = $key;
		$geocoder->push({ limit => 100, geocoder => Geo::Coder::GooglePlaces->new(%gp_args) });
	}
	if(my $key = $ENV{BMAP_KEY}) {
		$geocoder->push(Geo::Coder::Bing->new(key => $key));
	}

	if($browser) {
		$browser->throttle({
			'nominatim.openstreetmap.org' => 1,
			'geocode.xyz' => 2,
			'geocoder.ca' => 1,
			'opencagedata.com' => 1,
			'api.postcodes.io' => 1,
			'where.desktop.mos.svc.ovi.com' => 1,
			'geocoding.geo.census.gov' => 1,
			'a2ageo.rmservers.com' => 1,
			'dev.virtualearth.net' => 1,	# Bing
			'api.geonames.org' => 1,
			'yboss.yahooapis.com' => 1,	# Geo::Coder::PlaceFinder
			'www.familysearch.org' => 1,
			'lookup.dbpedia.org' => 1,
		});
		# G::C::GooglePlaces
		$browser->throttle({ 'maps.googleapis.com' => 0.1 }) unless($ENV{GMAP_KEY});
		$browser->ssl_opts(verify_hostname => 0);	# prevent "Can't connect to geocode.xyz:443 (certificate verify failed)"
		$geocoder->ua($browser);

		# $textgeocoder = Geo::Parser::Text->new('https://geocoder.ca');
		# $textgeocoder = Geo::Parser::Text->new('https://geocode.xyz');

		# Geo::Coder::PlaceFinder doesn't support the ua() method
		if((my $ckey = $ENV{'YAHOO_CONSUMER'}) && (my $skey = $ENV{'YAHOO_SECRET'})) {
			$geocoder->push(Geo::Coder::PlaceFinder->new(consumer_key => $ckey, secret_key => $skey, ua => $browser));
		}
	}
}

my $oneday = DateTime::Duration->new(days => 1);
my $tenmonths = DateTime::Duration->new(months => 10);
my $sixteenyears = DateTime::Duration->new(years => 16);
my $fortyyears = DateTime::Duration->new(years => 40);
my $pdf;
my $pdfpage;
my @tmpfiles;
my $pr;
my $dbh;
$ged = Class::Simple::Cached->new(object => $ged,
	cache => CHI->new(driver => 'RawMemory', datastore => {}));
my $ged2;
if($ARGV[1]) {
	$ged2 = Gedcom->new(gedcom_file => $ARGV[1], read_only => 1);
	$ged2 = Class::Simple::Cached->new(object => $ged2, cache => CHI->new(driver => 'RawMemory', datastore => {}));
}
my $abbr = Geo::Coder::Abbreviations->new();

my @everyone;
# Don't get everyone if we're after a specific person, or we're producing a book of a person
unless($opts{'p'} || (($opts{'A'} || $opts{'G'}) && $opts{'B'} && $opts{'h'})) {
	# @everyone = sort {
		# $a->as_string({ include_years => 1, middle_names => 1 }) cmp $b->as_string({ include_years => 1, middle_names => 1 })
		# } $ged->individuals();
	# @everyone = map { Class::Simple::Readonly::Cached->new(object => $_, cache => CHI->new(driver => 'RawMemory', datastore => {})) } $ged->individuals();

	print "Loading all individuals\n" if($opts{'v'});
	@everyone = map { Class::Simple::Readonly::Cached->new({ object => $_, cache => {} }) } $ged->individuals();
	if(scalar(@everyone) == 0) {
		die 'No people in the tree';
	}
	print scalar(@everyone), " individuals loaded\n" if($opts{'v'});
}

if($opts{'c'} && !$opts{'d'}) {
	die '-c only makes sense with the -d option';
}
if($opts{'F'} && !$opts{'B'}) {
	die '-F only makes sense with the -B option';
}
if($opts{'m'} && !$opts{'H'}) {
	die '-m only makes sense with the -H option';
}
if($opts{'y'} && (!$opts{'H'}) && (!$opts{'r'})) {
	die '-y only makes sense with the -H or -r options';
}
if($opts{'e'} && ((!$opts{'L'}) || (!$opts{'H'}))) {
	die '-e only makes sense with the -L option and -H options';
}
if($opts{'L'} && !$opts{'H'}) {
	die '-L only makes sense with the -H option';
}
if($opts{'W'} && !$opts{'w'}) {
	warn '-W only makes sense with the -w option';
} elsif($opts{'w'} && !defined($ENV{'CLICOLOR'})) {
	$opts{'W'} = 1;
}
if($opts{'A'} && $opts{'G'}) {
	die '-A doesn\'t make sense with the -G option';
}
if($opts{'S'} && $opts{'B'}) {
	die '-S doesn\'t make sense with the -B option';
}

if($opts{'B'}) {
	$pdf = PDF::API2->new(-file => $opts{'B'});
	my $papersize;
	if(defined($ENV{'LC_ALL'}) &&($ENV{'LC_ALL'} =~ /^en_US/)) {
		$papersize = 'letter';
	} elsif(defined($ENV{'LC_PAPER'}) &&($ENV{'LC_PAPER'} =~ /^en_US/)) {
		$papersize = 'letter';
	} elsif((-r '/etc/papersize') && open(my $fin, '<', '/etc/papersize')) {
		# Linux
		$papersize = <$fin>;
		close $fin;
		chomp $papersize;
	} else {
		$papersize = 'A4';
	}
	if($papersize eq 'letter') {
		$pdf->mediabox('Letter');
		$Text::Wrap::columns = 95;
	} else {
		$pdf->mediabox('A4');
		$Text::Wrap::columns = 105;
	}
	$opts{'A'} = 1 unless($opts{'G'});
} elsif($opts{'s'}) {
	die '-s only makes sense with the -B, -H, -g or -x options' unless($opts{'x'} || $opts{'g'} || $opts{'M'} || $opts{'H'});
} elsif($opts{'S'}) {
	# Use basename of .ged with .sql suffix
	my $sqlite_file = $ARGV[0];
	$sqlite_file =~ s/\.ged$//;
	$sqlite_file .= '.sqlite';

	if(-e $sqlite_file) {
		unlink $sqlite_file;
	}

	$dbh = DBI->connect("dbi:SQLite:dbname=$sqlite_file", undef, undef, { RaiseError => 1, AutoCommit => 0, synchronous => 0, locking_mode => 'EXCLUSIVE' });
	$dbh->do('PRAGMA cache_size = 65536');
	$dbh->do('PRAGMA journal_mode = OFF');

	$dbh->do('CREATE TABLE people(xref CHAR(6) NOT NULL, givennames VARCHAR, surname VARCHAR, mother CHAR(6), father CHAR(6), birth CHAR (12), death CHAR (12), PRIMARY KEY (xref), FOREIGN KEY (mother) REFERENCES people(xref), FOREIGN KEY (father) REFERENCES people(xref));');
	$dbh->do('CREATE TABLE siblings(xref CHAR(6), sibling CHAR(6) NOT NULL, PRIMARY KEY (xref, sibling), FOREIGN KEY (sibling) REFERENCES people(xref));');
	$dbh->do('CREATE TABLE children(xref CHAR(6), child CHAR(6) NOT NULL, PRIMARY KEY (xref, child), FOREIGN KEY (child) REFERENCES people(xref));');
	$dbh->do('CREATE TABLE spouses(xref CHAR(6), spouse CHAR(6) NOT NULL, dateofmarriage CHAR (12), placeofmarriage CHAR (30), PRIMARY KEY (xref, spouse), FOREIGN KEY (spouse) REFERENCES people(xref));');
	$dbh->do('CREATE TABLE locations(location CHAR (30), PRIMARY KEY (location));');
	$dbh->do('CREATE TABLE residences(xref CHAR (6), date CHAR (12), location CHAR (30), FOREIGN KEY (xref) REFERENCES people(xref), FOREIGN KEY (location) REFERENCES locations(location));');
	$dbh->do('CREATE TABLE occupations(xref CHAR (6), occupation CHAR (20), FOREIGN KEY (xref) REFERENCES people(xref));');
}

if($opts{'A'} || $opts{'G'} || $opts{'S'}) {
	$opts{'a'} = 1;
}
if($opts{'x'}) {
	if($opts{'g'}) {
		die '-g and -x option are exclusive'
	}
	if($opts{'M'}) {
		die '-g and -x option are exclusive'
	}
	$opts{'r'} = 1;
} elsif($opts{'g'} || $opts{'M'}) {
	$opts{'r'} = 1;
}
if($opts{'r'} || $opts{'O'}) {
	$opts{'A'} = $opts{'a'} = $opts{'d'} = 1;
}
my $ical;
if($opts{'i'}) {
	if($opts{'r'}) {
		die '-i and -r are exclusive';
	}
	$ical = Data::ICal->new();
	$ical->add_properties(
		calscale => 'GREGORIAN',
		method => 'PUBLISH',
		'X-WR-CALNAME' => "$0 Family Calendar",
	);
	$opts{'A'} = $opts{'a'} = 1;
}

my $dot;
if($opts{'B'}) {
	if(-x '/usr/bin/dot') {
		$dot = '/usr/bin/dot';
	} elsif(-x '/usr/local/bin/dot') {
		$dot = '/usr/local/bin/dot';
	} elsif(-x '/sw/bin/dot') {
		$dot = '/sw/bin/dot';
	}

	if(!defined($dot)) {
		complain(warning => 'Graphviz not found, no family trees');
	} elsif($opts{'v'}) {
		print "Using $dot\n";
	}
}

my ($obituaries, $wills);

if($opts{'w'}) {
	my $opts;
	if(my $redis = $ENV{'REDIS_SERVER'}) {
		$opts->{'cache'} = CHI->new(
			driver => 'Redis',
			namespace => $script_name,
			server => $redis,
			debug => $opts{'v'}
		);
	} else {
		$opts->{'cache'} = CHI->new(
			driver => 'File',
			root_dir => $cache_dir,
		);
	}
	if($logger) {
		$opts->{'logger'} = $logger;
	}
	$obituaries = Genealogy::ObituaryDailyTimes->new($opts);
	die if(!defined($obituaries));
	$wills = Genealogy::Wills->new($opts);
	die if(!defined($wills));
}

my $meteo;

if($opts{'d'} && (!$opts{'r'}) && (!$opts{'O'})) {
	$meteo = Weather::Meteo->new(ua => $cached_browser);
}

if($opts{'H'}) {
	die '-H only makes sense with the -d option' unless($opts{'d'});
	die '-a doesn\'t make sense with the -H option' if($opts{'a'});
	die '-h doesn\'t make sense with the -H option unless you give the -s option' if($opts{'h'} && !$opts{'s'});
	die '-p doesn\'t make sense with the -H option' if($opts{'p'});
	die '-H doesn\'t support citations' if($opts{'c'});

	my $dtl = DateTime::Locale->load($ENV{'LC_TIME'} // $ENV{'LC_ALL'} // $ENV{'LANG'});

	my @dow = @{$dtl->day_format_wide()};
	if($dtl->first_day_of_week() == 7) {
		# e.g. US
		unshift @dow, pop @dow;
	}
	my $table = HTML::Table->new(-border => 1, -padding => 5, -head => \@dow);
	print '<html><head><title>Gedcom Calendar</title></head><body><font size="2">',
		'<style>table { empty-cells: show; }</style>';

	foreach my $day(0..6) {
		# $table->setCell(1, $day + 1, $days[$day]);
		$table->setColWidth($day, '14.29%');
		$table->setColVAlign($day, 'top');
	}

	my $month;
	if($opts{'m'}) {
		$month = $opts{'m'};
		if(($month =~ /\D/) || ($month < 1) || ($month > 12)) {
			die "$0: invalid month number $month";
		}
		$month--;
	} else {
		$month = (localtime)[4]; # 0..11
	}

	my $dt = DateTime->today();
	my $year;
	if($opts{'y'}) {
		$year = $opts{'y'};
		if($year !~ /\d{3,4}/) {
			die "$0: invalid year number $month";
		}
	} else {
		$year = $dt->year();
	}

	$dt = DateTime->last_day_of_month(month => $month + 1, year => $year);
	$dt->subtract(months => 1);
	$dt->add(days => 1);
	my $column = $dt->day_of_week();
	if($dtl->first_day_of_week() == 7) {
		$column++;
		if($column == 8) {
			$column = 1;
		}
	}

	foreach my $column(1..7) {
		$table->setCell(2, $column, '&nbsp;');
	}

	my $row = 2;
	while($dt->month() == $month + 1) {
		$table->setCellVAlign($row, $column, 'top');
		$table->setCell($row, $column, '<font size="1">' . $dt->day() . '</font>');
		$dt->add(days => 1);
		if($dt->day() == 1) {
			last;
		}
		if($column == 7) {
			$row++;
			foreach my $column(1..7) {
				$table->setCell($row, $column, '&nbsp;');
			}
			$column = 1;
		} else {
			$column++;
		}
	}

	print '<center><h2>', @{$dtl->month_format_wide()}[$month], " $year</h2></center>";

	foreach my $day(1..28) {
		# print STDERR __LINE__, ": $day/", $month + 1, "/$year\n";
		generate(day => $day, month => $month, year => $year, everyone => \@everyone, table => $table, dtl => $dtl);
	}
	if($month == 1) {
		# February
		if(($year % 100) == 0) {
			if(($year % 400) == 0) {
				generate(day => 29, month => $month, everyone => \@everyone, table => $table, dtl => $dtl);
			}
		} elsif(($year % 4) == 0) {
			generate(day => 29, month => $month, everyone => \@everyone, table => $table, dtl => $dtl);
		}
	} else {
		generate(day => 29, month => $month, year => $year, everyone => \@everyone, table => $table, dtl => $dtl);
		generate(day => 30, month => $month, year => $year, everyone => \@everyone, table => $table, dtl => $dtl);
		if(($month == 0) || ($month == 2) || ($month == 4) || ($month == 6) || ($month == 7) || ($month == 9) || ($month == 11)) {
			generate(day => 31, month => $month, year => $year, everyone => \@everyone, table => $table, dtl => $dtl);
		}
	}
	print '<center>';
	$table->print();
	print '</center></font></body></html>';
} elsif($opts{a}) {
	die '-b and -a should not be given together' if($opts{'b'});
	die '-D and -a should not be given together' if($opts{'D'});
	die '-p and -a should not be given together' if($opts{'p'});

	if($opts{'A'} || $opts{'G'}) {
		my $surname;

		if($opts{'s'} && $opts{'h'}) {
			if($opts{'h'} =~ /\s*([A-Z]+?)$/i) {
				$surname = $1;
			} else {
				$surname = $opts{'h'};
			}
		}
		if($opts{'B'}) {
			if($opts{'h'}) {
				my $page = $pdf->page();

				my $font = $pdf->corefont('Times-Bold');

				my $text = $page->text();
				$text->font($font, 28);
				$text->translate(300, 600);
				if($surname) {
					$text->text_center("The Surname Book of $surname");
				} else {
					if($language eq 'French') {
						$text->text_center("L'arbre de la famille de");
					} else {
						$text->text_center('The Family Tree of');
					}

					$text->translate(300, 525);
					$text->text_center(normalize_name($opts{'h'}));
				}
				my %args;
				if(defined($ENV{'TZ'}) && ($ENV{'TZ'} !~ /^\//)) {
					$args{'time_zone'} = $ENV{'TZ'};
				} else {
					$args{'time_zone'} = $tz;
				}
				my $dt = DateTime->today(%args);
				my $dtl = DateTime::Locale->load($ENV{'LC_TIME'} // $ENV{'LC_ALL'} // $ENV{'LANG'});
				if($surname) {
					$text->translate(300, 525);
				} else {
					$text->translate(300, 450);
				}
				$text->text_center('Compiled on ' .
					$dt->day() . ' ' .
					@{$dtl->month_format_wide()}[$dt->month - 1] . ' ' .
					$dt->year()
				);
				if($surname && !$opts{'G'}) {
					$text->translate(300, 450);
					if(is_alive(person => $me)) {
						$text->text_center('for ' . normalize_name($opts{'h'}));
					} else {
						my $n = normalize_name($me->as_string(include_years => 1));
						$n =~ s/\sC(\d)/ c$1/;
						$text->text_center("for $n");
					}
				}
				$text->font($font, 12);
				$text->translate(220, 40);
				$text->text('Produced by gedcom - https://github.com/nigelhorne/gedcom');
				$text->textend();

				# my $gfx = $page->gfx();
				# my $image = $pdf->image_png('/Users/njh/src/njh/ged2site/dynamic-site/images/printer.png');
				# $gfx->image($image, 100, 100);
				# $image->height(32);
				# $image->width(32);

				if($opts{'F'}) {
					@everyone = ($me, ancestors($me));
				} else {
					@everyone = ($me, ancestors($me), descendants($me));
					my @siblings = ($me->siblings(), $me->half_siblings());
					foreach my $sibling(@siblings) {
						# print $sibling->as_string(), "\n";
						@everyone = descendants($sibling, \@everyone);
					}
					@everyone = (@everyone, @siblings);
				}
			# } elsif($opts{'s'}) {
				# die '-s and -h must be given together';
			}
		}

		if($surname) {
			my $nara = soundex_nara($surname);
			# @everyone = grep { $_->as_string() =~ /.*$surname$/i } @everyone;
			@everyone = grep { ($_->as_string() =~ /$surname$/i) || ($_->surname() && (soundex_nara($_->surname()) eq $nara)) } @everyone;
		}

		if(scalar(@everyone) == 0) {
			if($me) {
				die 'No matches found for ', $me->as_string(include_years => 1);
			}
			die 'No match';
		}

		if($opts{'B'} || $opts{i} || ((!$opts{'x'}) && (!$opts{'A'}) && !$opts{'g'} && !$opts{'M'})) {
			$pr = String::ProgressBar->new(max => scalar(@everyone), length => 60);
		}

		if($opts{'G'} && $dot && $me) {
			if($me->father() || $me->mother()) {
				print STDERR $me->as_string({ include_years => 1, middle_names => 1, nee => 1 }), ":\n\t";
				die 'A generations book (-B and -G) must have the -h person at the top of the tree';
			}
			# Put a family tree of the first few generations on page 2
			# Fit as many as we can until the text is going to become too small
			my $tmp = File::Temp->new();
			my $filename = $tmp->filename();
			my $png = '/tmp/njh.png';	# FIXME

			my $maxrank = 2;
			while(1) {
				my $d = count_descendants_at_level($me, $maxrank + 1);
				last if($d == 0);
				last if($d >= 3);

				$maxrank++;
			}

			if(open(my $fout, '|-', "$dot -Tpng -o$png -Tcmapx -o$filename")) {
			# if(open(my $fout, '|-', '/usr/bin/tee foo')) {
				print $fout 'digraph family {',
					'rotate = 90 subgraph main { rank="0"; ';
				print_graphviz({ person => $me, fout => $fout, format => 'dynamic' });
				print_graphviz_generation({ person => $me, fout => $fout, format => 'dynamic', rank => 0, maxrank => $maxrank + 1 });
				print $fout '}}';
				close $fout;

				print "Resize $png\n" if($opts{'v'});

				my $image;
				my $resize = Image::Resize->new($png);
				my $width = $resize->width();
				my $height = $resize->height();
				my $gd;
				if($height > 715) {
					my $newwidth = $width * (715 / $height);
					if($newwidth > 550) {
						my $newheight = $height * (550 / $width);
						$gd = $resize->resize(550, $newheight);
					} else {
						$gd = $resize->resize($newwidth, 715);
					}
				} elsif($width > 550) {
					my $newheight = $height * (550 / $width);
					$gd = $resize->resize(550, $newheight);
				}
				if($gd) {
					$image = $pdf->image_gd($gd, -lossless => 1);
					unlink $png;
				} else {
					$image = $pdf->image_png($png);
					push @tmpfiles, $png;
				}
				$pdfpage = NJH::PDFPage->new($pdf);
				my $x = 300 - ($image->width() / 2);
				my $y = $pdfpage->y() - $image->height();
				$pdfpage->page()->gfx()->image($image, $x, $y);
				$pdfpage = NJH::PDFPage->new($pdf);
			}

			# FIXME: This sorting only works when all people are descendants of $me,
			# there are no ancestors involved
			@everyone = map { Class::Simple::Readonly::Cached->new({ object => $_, cache => {}, quiet => 1 }) } @everyone;
			@everyone = sort {
				(stepsabove($a, $me, 0) == stepsabove($b, $me, 0)) ?
					$a->as_sort_key() cmp $b->as_sort_key() :
					stepsabove($a, $me, 0) <=> stepsabove($b, $me, 0);
			} @everyone;

			die "BUG: sort hasn't worked" if($everyone[0]->xref() ne $me->xref());
		} elsif($opts{'h'} && !$opts{'x'}) {
			# Put a family tree going back a few generations on page 2
			# Go back until it looks like it will be very small text
			my $tmp = File::Temp->new();
			my $filename = $tmp->filename();
			my $png = '/tmp/njh.png';	# FIXME
			my $top = $me;

			my $level = 0;
			while(1) {
				my $parent;
				if($top->father()) {
					$parent = $top->father();
				} elsif($top->mother()) {
					$parent = $top->mother();
				} else {
					last;
				}
				if(count_descendants_at_level($parent, $level + 1) > 20) {
					last;
				}
				$top = $parent;
				$level++;
				# print $top->as_string(), " $level, ", count_descendant_at_level($top, $level), "\n";
			}

			if(($top->xref() ne $me->xref()) && $dot && open(my $fout, '|-', "$dot -Tpng -o$png -Tcmapx -o$filename")) {
			# if(open(my $fout, '|-', '/usr/bin/tee foo')) {
				print $fout 'digraph family {',
					'rotate = 90 subgraph main { rank="0"; ';
				print_graphviz({ person => $top, fout => $fout, format => 'dynamic' });
				print_graphviz_generation({ person => $top, fout => $fout, format => 'dynamic', rank => 0, maxrank => $level + 1 });
				print $fout '}}';
				close $fout;

				print "Resize $png\n" if($opts{'v'});

				my $image;
				my $resize = Image::Resize->new($png);
				my $width = $resize->width();
				my $height = $resize->height();
				my $gd;
				if($height > 715) {
					my $newwidth = $width * (715 / $height);
					if($newwidth > 550) {
						my $newheight = $height * (550 / $width);
						$gd = $resize->resize(550, $newheight);
					} else {
						$gd = $resize->resize($newwidth, 715);
					}
				} elsif($width > 550) {
					my $newheight = $height * (550 / $width);
					$gd = $resize->resize(550, $newheight);
				}
				if($gd) {
					$image = $pdf->image_gd($gd, -lossless => 1);
					unlink $png;
				} else {
					$image = $pdf->image_png($png);
					push @tmpfiles, $png;
				}
				$pdfpage = NJH::PDFPage->new($pdf);
				my $x = 300 - ($image->width() / 2);
				my $y = $pdfpage->y() - $image->height();
				$pdfpage->page()->gfx()->image($image, $x, $y);
			}
			# They're already cached
			# @everyone = map { Class::Simple::Readonly::Cached->new({ object => $_, cache => {} }) } @everyone;
			@everyone = Sort::Key::keysort { $_->as_sort_key() } @everyone;
		} elsif($opts{'A'}) {
			@everyone = Sort::Key::keysort { $_->as_sort_key() } @everyone;
		}

		if($opts{'M'}) {
			my @files;
			foreach my $year(-130..70) {
				generate(everyone => \@everyone, year => $year);
				if(($year % 10) == 0) {
					push @files, dump_places(\%all_places, ($year/10)+13);
				}
				%printed = ();
			}

			my $version;

			IPC::Run::run([ 'apngasm', '-v' ], '>', \$version);
			if($version =~ /v3\.1\.\d+/) {
				system("apngasm -o output.png -d 750 frame*.png && apng2gif output.png $surname.gif");
			} else {
				# If this fails, try this:
				#	system("apngasm -o output.png -d 750 frame*.png && apng2gif output.png $surname.gif");

				# apngasm version 2.91
				system("apngasm output.png frame*.png 3 4 && apng2gif output.png $surname.gif");
			}
			unlink 'output.png', @files;
		} elsif($opts{'O'}) {
			generate(everyone => \@everyone, dbh => $dbh);
			dump_occupations(\%all_occupations);
		} else {
			generate(everyone => \@everyone, dbh => $dbh);
			dump_places(\%all_places);
		}

		if($opts{'B'}) {
			$pdf->save();
			unlink @tmpfiles;
		}
	} else {
		foreach my $month(0..11) {
			foreach my $day(1..28) {
				generate(day => $day, month => $month, everyone => \@everyone);
			}
			if($month == 1) {
				my $year = DateTime->today()->year();
				next if($year % 4);
				if(($year % 100) == 0) {
					next unless($year % 400);
				}
				generate(day => 29, month => $month, everyone => \@everyone);
				next;
			}
			generate(day => 29, month => $month, everyone => \@everyone);
			generate(day => 30, month => $month, everyone => \@everyone);
			if(($month == 0) || ($month == 2) || ($month == 4) || ($month == 6) || ($month == 7) || ($month == 9) || ($month == 11)) {
				generate(day => 31, month => $month, everyone => \@everyone);
			}
		}
		generate(day => -1, month => -1, everyone => \@everyone);
	}
} elsif($opts{'b'}) {
	die '-b and -d should not be given together' if($opts{'d'});
	die '-b and -a should not be given together' if($opts{'a'});
	my($day, $month) = (localtime)[3,4];
	if($opts{'D'}) {
		print "Today's birthdays:\n";
	}
	generate(day => $day, month => $month, onlybirthdays => 1, onlydeaths => 0, everyone => \@everyone);
	if($opts{'D'}) {
		print "Today's anniversaries of deaths:\n";
		generate(day => $day, month => $month, onlybirthdays => 0, onlydeaths => 1, everyone => \@everyone);
	}
} elsif($opts{'D'}) {
	die '-D and -d should not be given together' if($opts{'d'});
	die '-D and -a should not be given together' if($opts{'a'});
	my($day, $month) = (localtime)[3,4];
	generate(day => $day, month => $month, onlybirthdays => 0, onlydeaths => 1, everyone => \@everyone);
} elsif($opts{'p'}) {
	die '-p and -D should not be given together' if($opts{'D'});
	die '-p and -b should not be given together' if($opts{'b'});

	my @people = $ged->get_individual($opts{'p'});
	if(scalar(@people)) {
		my($day, $month) = (localtime)[3,4];

		foreach my $person(@people) {
			if(!ref($person)) {
				die "$0: Can't find '$opts{p}' in $ARGV[0]";
			}
			print_person(person => $person, day => $day, month => $month);
		}
	} else {
		die "$0: Can't find '$opts{p}' in $ARGV[0]";
	}
} elsif(!$opts{'t'}) {
	my($day, $month) = (localtime)[3,4];
	generate(day => $day, month => $month, everyone => \@everyone);
} else {
	my %args = ('time_zone' => $tz);
	my $dt = DateTime->now(%args)->add(days => 1);
	print "Generating the data\n" if($opts{'v'});
	generate(day => $dt->day(), month => $dt->month() - 1, everyone => \@everyone);
}

if($ical) {
	open(my $fout, '>', $opts{'i'});
	print $fout $ical->as_string();
	close $fout;
	print "\n" if($pr);
} elsif(defined($dbh)) {
	my $query = "INSERT INTO locations('location') VALUES (?);";
	my $statement = $dbh->prepare($query);
	while(my($k, $v) = each(%all_locations)) {
		die unless($statement->execute($k) == 1);
	}
	$dbh->commit();
	$dbh->disconnect();
}

sub generate
{
	my %params = (ref($_[0]) eq 'HASH') ? %{$_[0]} : @_;

	my $surname_initial;
	if($opts{'B'}) {
		# $params{'font'} = $pdf->corefont('Times-Roman', -encode => 'utf-8');
		# FIXME: corefonts don't include UTF-8
		$params{'font'} = $pdf->corefont('Times-Roman');
	}
	my $index = 1;
	my $generation = 0;

	foreach my $person(@{$params{'everyone'}}) {
	# foreach my $person(sort { $a->get_value('last name') cmp $b->get_value('last name') } $ged->individuals()) {
		my $xref = $person->xref();
		if($me && ($xref eq $me->xref()) && !$opts{'a'}) {
			$index++;
			next;
		}

		next if($printed{$xref} && !$opts{'H'});
		$printed{$xref} = 1;

		if($pr) {
			$| = 1;
			$pr->update($index++);
			$pr->write();
			$| = 0;
		}
		if($dbh) {
			sqlite(person => $person);
			next;
		} elsif($ical) {
			my $dateofbirth = dateofbirth($person);
			if($dateofbirth && ($dateofbirth =~ /^\d+\s\w{3}\s\d{3,4}$/)) {
				add_to_ical(
					ical => $ical,
					datetime => date_to_datetime(date => $dateofbirth),
					summary => 'Birth of ' . $person->as_string()
				);
			}
			my $dateofbaptism = get_value({ person => $person, value => 'baptism date' });
			if((!$dateofbaptism) && (my $baptism = $person->get_record('baptism'))) {
				$dateofbaptism = $baptism->date();
			}
			if($dateofbaptism && ($dateofbaptism =~ /^\d+\s\w{3}\s\d{3,4}$/)) {
				add_to_ical(
					ical => $ical,
					datetime => date_to_datetime(date => $dateofbaptism),
					summary => 'Baptism of ' . $person->as_string()
				);
			}
			if(my $marriage = $person->get_record('marriage') || $person->get_record('fams marriage')) {
				if(my $dateofmarriage = $marriage->date()) {
					if($dateofmarriage && ($dateofmarriage =~ /^\d+\s\w{3}\s\d{3,4}$/)) {
						# FIXME: work with more than one spouse
						my @spouses = $person->spouse();
						if(scalar(@spouses) == 1) {
							add_to_ical(
								ical => $ical,
								datetime => date_to_datetime(date => $dateofmarriage),
								summary => 'Marriage of ' . $person->as_string() . ' and ' . $spouses[0]->as_string()
							);
						}
					}
				}
			}
			my $dateofdeath = dateofdeath($person);
			if($dateofdeath && ($dateofdeath =~ /^\d+\s\w{3}\s\d{3,4}$/)) {
				add_to_ical(
					ical => $ical,
					datetime => date_to_datetime(date => $dateofdeath),
					summary => 'Death of ' . $person->as_string()
				);
			}
			my $dateofburial = get_value({ person => $person, value => 'burial date' });
			if((!defined($dateofburial)) && (my $burial = $person->get_record('burial'))) {
				$dateofburial = $burial->date();
			}
			if($dateofburial && ($dateofburial =~ /^\d+\s\w{3}\s\d{3,4}$/)) {
				add_to_ical(
					ical => $ical,
					datetime => date_to_datetime(date => $dateofburial),
					summary => 'Burial of ' . $person->as_string()
				);
			}
			next;
		} elsif($opts{'B'}) {
			if($me && $opts{'G'}) {
				if(stepsabove($person, $me, 0) != $generation) {
					# FIXME:  only do this if the generation contains dead people if the -l flag is not given
					$pdfpage = NJH::PDFPage->new($pdf);
					$generation = stepsabove($person, $me, 0);

					my $font = $pdf->corefont('Times-Bold');
					my $text = $pdfpage->text();
					$text->font($font, 18);

					$text->translate(300, $pdfpage->newline());

					my $t;

					if($generation >= 5) {
						$t = ($generation - 2) . ' times great-grandchildren';
					} elsif($generation == 1) {
						$t = ucfirst(i18n('children'));
					} elsif($generation == 2) {
						$t = ucfirst(i18n('grandchildren'));
					} elsif($generation == 3) {
						$t = ucfirst(i18n('great-grandchildren'));
					} elsif($generation == 4) {
						$t = 'Great-great-grandchildren';
					} else {
						# May have found a spouse with the same name, so it shouldn't be included
						next unless($person->father() || $person->mother());
						die $person->as_string(), '/', $me->as_string(), "; -G ($generation): Doesn't yet support ancestors";
					}
					$text->text_center($t);

					$text->font($params{'font'}, 12);
				}
			} else {
				my $surname = $person->surname() || '?';
				my $initial = substr $surname, 0, 1;
				if((!defined($surname_initial)) || ($initial ne $surname_initial)) {
					$pdfpage = NJH::PDFPage->new($pdf);
					$surname_initial = $initial;
				}
			}
		}

		$params{'person'} = $person;
		print_person(\%params);

		dump_geocoder_log();
	}
	if($opts{'B'}) {
		print "\n";
	}
}

sub print_person
{
	my %params = (ref($_[0]) eq 'HASH') ? %{$_[0]} : @_;

	# Gather the information on this person
	my $person = $params{'person'};

	my $dateofbirth;

	# https://github.com/nigelhorne/ged2site/compare/master...jhannah:ged2site:115-bday-of-living-is-private?expand=1
	if(!is_alive($person)) {
		$dateofbirth = dateofbirth($person);
	}

	# ACOM starts approximate dates with "Abt." instead of "ABT".
	if(defined($dateofbirth) && length($dateofbirth)) {
		$dateofbirth =~ tr/\.\-/  /;
		$dateofbirth =~ s/\s{2,}/ /gs;
		# FIXME: ../../../gedcoms/gl120368.ged puts dates *inside*
		#	brackets
		$dateofbirth =~ s/\(.+$//;	# some people put information in brackets after the date
		if($dateofbirth =~ /^About[:\s](.+)/i) {
			$dateofbirth = "ABT $1";
		} elsif($dateofbirth =~ /^Bet\s[a-z]{3}.+([a-z]{3}\s+.*)/i) {	# Bet Jun-Jul 1860
			$dateofbirth = "ABT $1";
		} elsif($dateofbirth =~ /^(.+)\s*\?/i) {
			$dateofbirth = "ABT$1";
		}
		if(($dateofbirth !~ /^[\d\sA-Z\/]+$/i) && ($dateofbirth !~ /^Abt\./)) {
			if($dateofbirth =~ /(\d{4})\s*(.+)/) {
				my $d = $1;
				my $t = $2;
				# Allow 1914-1918
				if($t !~ /\d{3,4}$/) {
					$dateofbirth = "ABT$d";
					if(place({ person => $person, place => $t })) {
						complain({ person => $person, warning => "Unexpected text ($t) after the date $d - should be in the location record" });
					} else {
						complain({ person => $person, warning => "Unexpected text ($t) after the date $d - should be in the note field" });
					}
				}
			} elsif($dateofbirth !~ /\d{1,2}$/) {	# Dates can begin with a letter in the US
				complain({ person => $person, warning => "Invalid character in date of birth '$dateofbirth'" });
				$dateofbirth = undef;
			}
		}
	} else {
		undef $dateofbirth;
	}

	my $onlybirthdays = $params{'onlybirthdays'};
	my $onlydeaths = $params{'onlydeaths'};

	die 'BUG: onlydeaths and onlybirths given' if($onlydeaths && $onlybirthdays);

	return if($onlybirthdays && !defined($dateofbirth));

	my $dateofdeath = dateofdeath($person);

	return if($onlydeaths && !defined($dateofdeath));

	my $yod;	# Year of death
	if($dateofdeath) {
		$yod = get_year_from_date($dateofdeath);
		if(!defined($yod)) {
			complain({ person => $person, warning => "Invalid date of death $dateofdeath" });
		}
	}

	my $yob;	# Year of birth
	if($dateofbirth) {
		$yob = get_year_from_date($dateofbirth);
		if(!defined($yob)) {
			complain({ person => $person, warning => "Invalid date of birth $dateofbirth" });
		}
	}

	return unless($dateofbirth || $dateofdeath || $opts{'a'} || $opts{'p'});

	if((!defined($opts{l})) && (!defined($yod)) && defined($yob) && ($yob > 1900)) {
		# Assuming living if we don't have a date of death and
		# they were born after 1900
		return;
	}

	my $marriage = $person->get_record('marriage') || $person->get_record('fams marriage');
	# my $dateofmarriage = get_value({ person => $person, value => 'marriage date' });
	# if((!$dateofmarriage) && $marriage) {
		# $dateofmarriage = $marriage->date();
		# if(!defined($dateofmarriage)) {
			# $dateofmarriage = dateofmarriage($person);
		# }
	# }
	my $dateofmarriage = dateofmarriage($person);
	if($dateofmarriage && ($dateofmarriage =~ /\s$/)) {
		complain({ person => $person, warning => 'Removing trailing spaces from date of marriage' });
		$dateofmarriage =~ s/\s+$//;
	}

	# print 'Checking ', $person->as_string({ include_years => 1 }), "\n" if($opts{'v'});

	my $aob;
	my $aod;
	my $aom;
	my $day = $params{'day'};
	my $month = $params{'month'};

	if($day) {
		my $print = 0;
		if($dateofbirth && ($dateofbirth !~ /^\d{3,4}$/)) {
			my @btime = strptime("$dateofbirth 12:00");
			if(defined($btime[3]) && ($btime[3] == $day) && ($btime[4] == $month) && $btime[5]) {
				$print = 1;
				if(!$opts{a}) {
					$aob = (localtime)[5] - $btime[5];
					if($aob <= 0) {
						$aob += 1900;
					}
				}
			}
		}
		return if($onlybirthdays && !defined($aob));

		if($dateofdeath && ($dateofdeath !~ /^\d{3,4}$/)) {
			my @dtime = strptime("$dateofdeath 12:00");
			if(defined($dtime[3]) && ($dtime[3] == $day) && ($dtime[4] == $month) && $dtime[5]) {
				$print = 1;
				if(!$opts{a}) {
					$aod = (localtime)[5] - $dtime[5];
					if($aod <= 0) {
						$aod += 1900;
					}
				}
			}
		}
		return if($onlydeaths && !defined($aod));

		if($opts{'H'} && $dateofmarriage && ($dateofmarriage !~ /^\d{3,4}$/)) {
			my @mtime = strptime("$dateofmarriage 12:00");
			if(defined($mtime[3]) && ($mtime[3] == $day) && ($mtime[4] == $month) && $mtime[5]) {
				$print = 1;
				if(!$opts{a}) {
					$aom = (localtime)[5] - $mtime[5];
					if($aom <= 0) {
						$aom += 1900;
					}
				}
			}
		}
		return unless($print || ($day == -1) || $opts{'p'});
	}

	if($opts{'w'} && !$person->validate_semantics()) {
		complain({ person => $person, warning => 'failed consistency check' });
	}

	print 'Processing ', $person->as_string({ include_years => 1 }), "\n" if($opts{'v'});

	my @siblings = $person->siblings();
	my $mother = $person->mother();
	my $father = $person->father();
	if($father) {
		$father = Class::Simple::Readonly::Cached->new({ object => $father, cache => {}, quiet => 1 });
	}
	if($mother) {
		$mother = Class::Simple::Readonly::Cached->new({ object => $mother, cache => {}, quiet => 1 });
	}
	my @spouses = $person->spouse();
	@spouses = map { Class::Simple::Readonly::Cached->new({ object => $_, cache => {}, quiet => 1 }) } @spouses;

	# TODO: Properly chart which spouse a child comes from
	if($opts{'w'} && !$opts{'H'}) {
		my $family;
		foreach my $f($person->fams()) {
			if($f->number_of_children()) {
				$family = $f;
				last;
			}
		}

		if((!$family) && (scalar(@siblings) == 0) && (!$mother) && !$father) {
			if(scalar(@spouses) == 0) {
				# This person isn't connected to anyone
				# TODO: catch "islands" of people connected to each other, but nobody else
				complain({ person => $person, warning => 'Not connected to the tree' });
			} elsif(scalar(@spouses) == 1) {
				my $spouse = $spouses[0];
				my $sf;
				foreach my $f($spouse->fams()) {
					if($f->number_of_children()) {
						$sf = $f;
						last;
					}
				}
				my @ss = $spouse->spouse();
				if((!$sf) && (!$spouse->mother()) && (!$spouse->father()) && (!$spouse->siblings()) && (scalar(@ss) == 1)) {
					complain({ person => $person, warning => 'Spouses connect to each other but no-one else' });
				}
			}
		}
		if((!$family) && (scalar(@siblings) == 1) && (scalar(@spouses) == 0) && (!$mother) && !$father) {
			my $sibling = $siblings[0];
			my $sf;
			foreach my $f($sibling->fams()) {
				if($f->number_of_children()) {
					$sf = $f;
					last;
				}
			}
			my @ss = $sibling->spouse();
			if((!$sf) && (!$sibling->mother()) && (!$sibling->father()) && (scalar(@ss) == 0)) {
				complain({ person => $person, warning => 'Siblings connect to each other but no-one else' });
			}
		}

		# FIXME: needs to only complain about more than two biological parents
		my @parents = $person->parents();
		if(scalar(@parents) > 2) {
			complain({ person => $person, warning => 'Has more than two parents' });
		}
	}

	my $year = $params{'year'} || (localtime)[5];
	$year += 1900 if($year < 1900);

	my $name = $person->name();
	$name =~ s/\///g;
	print "Look at $name\n" if($opts{'v'});
	$nameparser->parse($name);
	my %name_components = $nameparser->components();
	# my $lastname = $name_components{'surname_2'} || $name_components{'surname_1'};
	my $lastname = ucfirst(lc($person->surname())); # RT109786

	if(defined($opts{'h'}) && $opts{'s'} && defined($lastname)) {
		my $surname;

		if($opts{'h'} =~ /\s*([A-Z]+?)$/i) {
			$surname = $1;
		} else {
			$surname = $opts{'h'};
		}
		if($lastname ne $surname) {
			if((my $l = soundex_nara($lastname)) && (my $s = soundex_nara($surname))) {
				return if($l ne $s);
			} else {
				return;
			}
		}
	}

	my $firstname = $name_components{'given_name_1'} // $name_components{'initials_1'};
	if((!defined($firstname)) && ($name =~ /(.+)\s(.+)/)) {
		$firstname = $1;
		if(!defined($lastname)) {
			$lastname = $2;
		}
		# utf8::decode($firstname);
		complain({ person => $person, warning => "Can't parse the name - assuming first name: $firstname, last name: $lastname" });
	}

	if($opts{'H'}) {
		# print STDERR __LINE__, ": $day/", $month + 1, "/$year\n";
		my $dt = DateTime->new(month => $month + 1, day => $day, year => $year);

		my $row = $dt->weekday_of_month() + 1;
		my $first_day_of_month = DateTime->new(month => $month + 1, day => 1, year => $year)->day_of_week();
		if(($first_day_of_month < 7) && ($dt->day_of_week() < $first_day_of_month)) {
			$row++;
		}
		my $column = $dt->day_of_week();
		my $dtl = $params{'dtl'};

		if(!defined($dtl)) {
			print STDERR "\n";
			my $i = 0;
			while((my @call_details = caller($i++))) {
				print STDERR "\t", colored($call_details[2] . ' of ' . $call_details[1], 'red'), "\n";
			}
			die 'dtl is not optional with -H';
		}

		if($dtl->first_day_of_week() == 7) {
			$column++;
			if($column == 8) {
				$column = 1;
				$row++ unless($first_day_of_month == 7);
			}
		}
		die "BUG: row cannot be 8 or greater" if($row >= 8);

		my $table = $params{'table'};
		if(!defined($table)) {
			my $i = 0;
			while((my @call_details = caller($i++))) {
				print STDERR "\t", colored($call_details[2] . ' of ' . $call_details[1], 'red'), "\n";
			}
			die 'BUG: table not set';
		}

		# print STDERR "$row, $column\n";
		my $str = $table->getCell($row, $column);
		if(index($str, $person->as_string()) != -1) {
			return;
		}
		$str .= '<br>';
		if($opts{'L'} && ($opts{'l'} || !is_alive(person => $person))) {
			# Add a link to the person's web page from the calendar
			$str .= '<a href="';
			if($opts{'e'}) {
				$str .= 'http://' . $opts{'e'} . '/cgi-bin/page.fcgi?page=people&entry=' . $person->xref();
			} else {
				$str .= '/' . make_filename_from_person(person => $person);
			}
			$str .= '">' . wide_to_html({ string => $person->as_string(), keep_apos => 1 }) . '</a>';
		} else {
			$str .= wide_to_html({ string => $person->as_string(), keep_apos => 1 });
		}
		if($aob) {
			if(my $d = $dfg->parse_datetime(date => dateofbirth($person))) {
				$str .= ' b' . $d->strftime('%Y');
			} else {
				red_warning({ person => $person, warning => "Can't parse date of birth '$dateofbirth'" });
			}
		}
		if($aom) {
			if(my $d = $dfn->parse_datetime($dateofmarriage) //
				$dfg->parse_datetime(date => $dateofmarriage)) {
				$str .= ' m' . $d->strftime('%Y');
			} else {
				red_warning({ person => $person, warning => "Can't parse date of marriage '$dateofmarriage'" });
			}
		}
		if($aod) {
			if(my $d = $dfg->parse_datetime(date => dateofdeath($person))) {
				$str .= ' d' . $d->strftime('%Y');
			} else {
				red_warning({ person => $person, warning => "Can't parse date of death '$dateofdeath'" });
			}
		}

		$table->setCell($row, $column, $str);
		return;
	}
	if($ged2 && !defined($ged2->get_individual($person->as_string()))) {
		complain({
			person => $person,
			warning => "not found in $ARGV[1]"
		});
	}

	my $args = {
		include_years => 1,
		middle_names => 1,
		title => 1,
		print_unknown => 1,
	};
	if(!($opts{'A'} || $opts{'G'})) {
		$args->{'nee'} = 1;
	}
	my $text;
	my %places_printed;
	if($opts{'B'}) {
		# Print the person's name in the book in larger text
		if($pdfpage->full() || ($pdfpage->linesleft() <= 10)) {
			# Start this person on a new page
			$pdfpage->text()->textend();
			$pdfpage = NJH::PDFPage->new($pdf);
		} else {
			$pdfpage->newline();
		}
		$text = $pdfpage->text();
		$text->font($params{'font'}, 18);

		$text->translate(25, $pdfpage->newline());
		my $string = $person->as_string($args);

		# TODO: support UTF-8 fonts
		# $text->text(sprintf '%v02X', $tulip);
		# $string =~ s/\xc4\x8d/Ä/g;
		utf8::decode($string);
		$string = Unicode::Diacritic::Strip::strip_diacritics($string);

		$text->text($string);

		$text->font($params{'font'}, 12);
	} elsif($opts{'M'}) {
		return if((!defined($yob)) || ($yob != $year));
		my $p;
		if(my $r = $person->get_record('birth')) {
			$p = place({ person => $person, record => $r, places_printed => \%places_printed, nopreposition => 1 });
			$p = $r->place();
		} elsif($p = get_value({ person => $person, value => 'birth place' })) {
			$p = place({ person => $person, place => $p, places_printed => \%places_printed, nopreposition => 1 });
			$p = $r->place();
		}
		if($p) {
			$p =~ s/^\s//;
			if($p =~ /Kent, England$/) {
				push @{$all_places{$p}}, $person;
			}
		}
		return;
	} elsif($opts{'r'}) {
		foreach my $place(get_all_residences($person)) {
			if(my $p = place({ person => $person, record => $place, places_printed => \%places_printed, nopreposition => 1 })) {
				if($opts{'y'}) {
					if(my $d = $place->date()) {
						$d =~ /(\d{3,4})$/;
						if($1) {
							if($1 != $opts{'y'}) {
								next;
							}
						} else {
							next;
						}
					} else {
						next;
					}
				}
				$p =~ s/^\s//;
				if($opts{'v'}) {
					get_location($p);
				}
				push @{$all_places{$p}}, $person;
			}
		}
		# FIXME: if there is more than one marriage, only gets one
		for my $event('birth', 'baptism', 'marriage', 'death', 'burial') {
			my $p;
			if(my $r = $person->get_record($event)) {
				if($opts{'y'}) {
					if(my $d = $r->date()) {
						$d =~ /(\d{3,4})$/;
						if($1) {
							if($1 != $opts{'y'}) {
								next;
							}
						} else {
							next;
						}
					} else {
						next;
					}
				}
				$p = place({ person => $person, record => $r, places_printed => \%places_printed, nopreposition => 1 });
			} elsif($p = get_value({ person => $person, value => "$event place" })) {
				if($opts{'y'}) {
					if(my $d = get_value({ person => $person, value => "$event date" })) {
						$d =~ /(\d{3,4})$/;
						if($1) {
							if($1 != $opts{'y'}) {
								next;
							}
						} else {
							next;
						}
					} else {
						next;
					}
				}
				$p = place({ person => $person, place => $p, places_printed => \%places_printed, nopreposition => 1 });
			}
			if($p) {
				$p =~ s/^\s//;
				if($opts{'v'}) {
					get_location($p);
				}
				push @{$all_places{$p}}, $person;
			}
		}

		dump_geocoder_log();

		return;
	} elsif($opts{'O'}) {
		foreach my $occupation(get_all_occupations($person)) {
			push @{$all_occupations{$occupation}}, $person;
		}

		return;
	} else {
		print $person->as_string($args), "\n";
	}

	if($firstname && ($firstname =~ /\d/)) {
		complain({ person => $person, warning => 'First name contains a digit' });
	}
	if($lastname) {
		if($lastname =~ /\d/) {
			complain({ person => $person, warning => 'Last name contains a digit' });
		} elsif($mother && $father && (uc($mother->surname()) ne uc($lastname)) && (uc($father->surname()) ne uc($lastname))) {
			complain({ person => $person, warning => 'Surname is different from both parents' });
		}
	}

	print "Gathering basic information\n" if($opts{'v'});

	my $birth = $person->get_record('birth');

	my $placeofbirth = get_value({ person => $person, value => 'birth place' });
	if((!$placeofbirth) && $birth) {
		$placeofbirth = $birth->place();
	}

	if($placeofbirth && ($placeofbirth =~ /[,\.]\s*$/) && ($placeofbirth ne 'U.S.A.')) {
		complain({ person => $person, warning => "Trailing punctuation in birth location '$placeofbirth'" });
		$placeofbirth =~ s/\s*[,\.]\s*$//;
	}

	if($placeofbirth && ($placeofbirth =~ /^,/)) {
		complain({ person => $person, warning => "Leading comma in birth location: $placeofbirth" });
		$placeofbirth =~ s/^,\s*//g;
	}

	if($placeofbirth && ($placeofbirth =~ /(.+[a-z]) USA$/i)) {
		complain({ person => $person, warning => "Comma missing before USA in birth location '$placeofbirth'" });
		$placeofbirth = "$1, USA";
		$birth_country = 'United States';
	} elsif($placeofbirth && ($placeofbirth =~ /.+,\s?(.+)$/)) {
		my $c = $1;

		if($c =~ /\s+$/) {
			complain({ person => $person, warning => "Removing trailing spaces from place of birth '$c'" });
			$c =~ s/\s+$//;
		}
		if($c =~ /\)$/) {
			complain({ person => $person, warning => 'Trailing bracket in birth location' });
			$c =~ s/\)$//;
		}

		if(length($c) > 3) {
			$c = sortoutcase($c);
		}

		if($c eq 'England') {
			$birth_country = 'United Kingdom';
		} elsif($c eq 'USA') {
			$birth_country = 'United States';
		} elsif($c eq 'United States Of America') {
			$birth_country = 'United States';
		} elsif($c eq 'U.S.A.') {
			$birth_country = 'United States';
		} elsif($c eq 'Scotland') {
			$birth_country = 'United Kingdom';
		} elsif($c eq 'Wales') {
			$birth_country = 'United Kingdom';
		} elsif($c eq 'Isle of Man') {
			$birth_country = 'United Kingdom';
		} elsif($c eq 'Northern Ireland') {
			$birth_country = 'United Kingdom';
		} elsif(($c eq 'PreuÃen') || ($c eq 'Deutschland')) {	# Prussia
			$birth_country = 'Germany';
		} elsif(($c eq 'Holland') || ($c eq 'The Netherlands')) {
			$birth_country = 'Netherlands';
		} elsif($c eq 'NL') {
			$birth_country = 'Netherlands';
			complain({ person => $person, warning => 'Assuming country of birth is Netherlands' });
		} elsif(($c =~ /[A-Z]{2}/) && ($us->{code2state}{$c})) {
			complain({ person => $person, warning => "$c: assuming country of birth is USA" });
			$birth_country = 'United States';
			$placeofbirth .= ', USA';
		} elsif($us->{state2code}{uc($c)}) {
			complain({ person => $person, warning => "$c: assuming country of birth is USA" });
			$birth_country = 'United States';
			$placeofbirth .= ', USA';
		} elsif(($c =~ /[A-Z]{2}/) && ($ca_en->{code2province}{$c}) || $ca_fr->{code2province}{$c}) {
			complain({ person => $person, warning => "$c: assuming country of birth is Canada" });
			$birth_country = 'Canada';
			$placeofbirth .= ', Canada';
		} elsif($ca_en->{province2code}{uc($c)} || $ca_fr->{province2code}{uc($c)}) {
			complain({ person => $person, warning => "$c: assuming country of birth is Canada" });
			$birth_country = 'Canada';
			$placeofbirth .= ', Canada';
		} elsif(($c =~ /[A-Z]{2,3}/) && ($au->{code2state}{$c})) {
			complain({ person => $person, warning => "$c: assuming country of birth is Australia" });
			$birth_country = 'Australia';
			$placeofbirth .= ', Australia';
		} elsif($au->{state2code}{uc($c)}) {
			complain({ person => $person, warning => "$c: assuming country of birth is Australia" });
			$birth_country = 'Australia';
			$placeofbirth .= ', Australia';
		} elsif(uc($c) eq 'NFLD') {
			complain({ person => $person, warning => 'Assuming country of birth is Canada' });
			$birth_country = 'Canada';
			$placeofbirth .= ', Canada';
		} elsif(($c eq 'Norfolk') || ($c eq 'Kent') || ($c eq 'Sussex') || ($c eq 'Northumberland') || ($c eq 'London')) {
			$birth_country = 'United Kingdom';
			complain({ person => $person, warning => 'Assuming country of birth is UK' });
		} elsif($c =~ 'England,?\sUK') {
			$birth_country = 'United Kingdom';
		} elsif($c eq 'Scot') {
			complain({ person => $person, warning => "$c: birth country should be Scotland'" });
			$birth_country = 'United Kingdom';
		} elsif($c eq 'Slovenija') {
			$birth_country = 'Slovenia';
		} elsif(my $b = Locale::Object::Country->new(name => $c)) {
			$birth_country = $b->name();
		} else {
			complain({ person => $person, warning => "Unknown birth country: '$c' in '$placeofbirth'" });
		}
	}

	my $death = $person->get_record('death');
	my $placeofdeath = get_value({ person => $person, value => 'death place' });
	if((!$placeofdeath) && $death) {
		$placeofdeath = $death->place();
	}

	if($placeofdeath) {
		if(lc($placeofdeath) eq 'unknown') {
			$placeofdeath = undef;
			complain({ person => $person, warning => "Assuming place of death ', , ' means unknown place" });
		} elsif($placeofdeath =~ /\s\s/) {
			complain({ person => $person, warning => 'Removing successive spaces from place of death' });
			$placeofdeath =~ s/\s\s+/ /g;
		}
	}

	if($placeofdeath && ($placeofdeath =~ /[,\.]\s*$/) && ($placeofdeath ne 'U.S.A.')) {
		complain({ person => $person, warning => "Trailing punctuation in death location '$placeofdeath'" });
		$placeofdeath =~ s/\s*[,\.]\s*$//;
	}

	if($placeofdeath && ($placeofdeath =~ /,\s*$/)) {
		complain({ person => $person, warning => 'Trailing comma in death location' });
		$placeofdeath =~ s/\s*,\s*$//;
	}
	if($placeofdeath && ($placeofdeath =~ /^,/)) {
		complain({ person => $person, warning => 'Leading comma in death location' });
		1 while($placeofdeath =~ s/^,\s*//g);
	}

	if($placeofdeath && ($placeofdeath =~ /(.+[a-z]) USA$/)) {
		complain({ person => $person, warning => "Comma missing before USA in death location '$placeofdeath'" });
		$placeofdeath = "$1, USA";
	} elsif($placeofdeath && ($placeofdeath =~ /.+,\s?(.+)$/)) {
		my $c = $1;
		if($c eq 'England') {
			# $death_country = 'United Kingdom';
		} elsif($c eq 'USA') {
			# $death_country = 'United States';
		# } elsif($c eq 'Texas') {
			# $death_country = 'United States';
		} elsif(($c =~ /[A-Z]{2}/) && ($us->{code2state}{$c})) {
			complain({ person => $person, warning => "$c: assuming country of death is USA" });
			# $death_country = 'United States';
		} elsif($us->{state2code}{uc($c)}) {
			complain({ person => $person, warning => "$c: assuming country of death is USA" });
			# $death_country = 'United States';
		} elsif($c eq 'United States of America') {
			# $death_country = 'United States';
		} elsif($c eq 'U.S.A.') {
			# $death_country = 'United States';
		} elsif($c eq 'Scotland') {
			# $death_country = 'United Kingdom';
		} elsif($c eq 'Scot') {
			complain({ person => $person, warning => "$c: death country should be Scotland'" });
			# $death_country = 'United Kingdom';
		} elsif($c eq 'Wales') {
			# $death_country = 'United Kingdom';
		} elsif(($c eq 'Norfolk') || ($c eq 'Kent') || ($c eq 'Sussex') || ($c eq 'Northumberland')) {
			# $death_country = 'United Kingdom';
			complain({ person => $person, warning => 'Assuming country of death is UK' });
		} elsif(($c eq 'Nova Scotia') || (uc($c) eq 'NFLD') || ($c eq 'Newfoundland') || ($c eq 'NS')) {
			complain({ person => $person, warning => "Country 'Canada' missing from death record" });
			# $death_country = 'Canada';
			if($opts{'w'} && defined($yod) && ($yod < 1500)) {
				complain ({ person => $person, warning => "Canada did not exist in $yod, check place of death ($placeofdeath)" });
				$placeofdeath = undef;
				# $death_country = '';
			}
		} elsif(($c =~ /[A-Z]{2,3}/) && ($au->{code2state}{$c})) {
			complain({ person => $person, warning => "$c: assuming country of death is Australia" });
			# $death_country = 'Australia';
		} elsif($au->{state2code}{uc($c)}) {
			complain({ person => $person, warning => "$c: assuming country of death is Australia" });
			# $death_country = 'Australia';
		} elsif(($c eq 'Holland') || ($c eq 'The Netherlands')) {
			# $death_country = 'Netherlands';
		} elsif($c eq 'Isle of Man') {
			# $death_country = 'United Kingdom';
		} elsif($c eq 'Northern Ireland') {
			# $death_country = 'United Kingdom';
		} elsif(($c eq 'PreuÃen') || ($c eq 'Deutschland')) {	# Prussia
			# $death_country = 'Germany';
		} elsif($c =~ /Can\./) {
			complain({ person => $person, warning => 'Assuming country of death is Canada' });
			# $death_country = 'Canada';
			if($opts{'w'} && defined($yod) && ($yod < 1500)) {
				complain ({ person => $person, warning => "Canada did not exist in $yod, check place of death ($placeofdeath)" });
				$placeofdeath = undef;
				# $death_country = '';
			}
		} elsif(($c =~ /[A-Z]{2} USA/) && ($us->{code2state}{substr($c, 0, 2)})) {
			complain({ person => $person, warning => "$c: assuming country of death is USA" });
			# $death_country = 'United States';
		} elsif(my $b = Locale::Object::Country->new(name => $c)) {
			# Country is found, nothing to be done
			# $death_country = $b->name();
		} else {
			complain({ person => $person, warning => "Unknown death country: '$c' in '$placeofdeath'" });
		}
	}

	if($opts{'w'} && $firstname && $lastname) {
		my %chronicling_params = ( ua => $cached_browser );
		if($dateofbirth && ($dateofbirth =~ /(\d{4})$/)) {
			if($1 <= 1789) {
				$chronicling_params{'date_of_birth'} = 1789;
			} else {
				$chronicling_params{'date_of_birth'} = $1;
			}
		}
		if($dateofdeath && ($dateofdeath =~ /(\d{4})$/)) {
			if($1 >= 1963) {
				$chronicling_params{'date_of_death'} = 1963;
			} else {
				$chronicling_params{'date_of_death'} = $1;
			}
		}
		$chronicling_params{'lastname'} = $lastname;
		$chronicling_params{'firstname'} = $firstname;
		my $stateofbirth;
		if($placeofbirth && (($placeofbirth =~ /USA$/) || ($placeofbirth =~ /United States$/)) && ($placeofbirth =~ /^.+,\s*([\w\s]+),[\w\s]+$/)) {
			$stateofbirth = uc($1);
			if($us->{code2state}{$stateofbirth}) {
				$stateofbirth = $us->{code2state}{$stateofbirth};
			} elsif(!$us->{state2code}{$stateofbirth}) {
				complain({ person => $params{'person'}, warning => "Unknown state '$stateofbirth' in birth place $placeofbirth" });
			}
			$chronicling_params{'state'} = ucfirst(lc($stateofbirth));
			chronicling_america($person, \%chronicling_params);

		}
		if($placeofdeath) {
			if((($placeofdeath =~ /USA$/) || ($placeofdeath =~ /United States$/)) && ($placeofdeath =~ /^.+,\s*([\w\s]+),[\w\s]+$/)) {
				my $stateofdeath = uc($1);
				if($us->{code2state}{$stateofdeath}) {
					$stateofdeath = $us->{code2state}{$stateofdeath};
				} elsif(!$us->{state2code}{$stateofdeath}) {
					complain({ person => $params{'person'}, warning => "Unknown state '$stateofdeath' in death place $placeofbirth" });
				}
				if((!defined($stateofbirth)) || (lc($stateofdeath) ne lc($stateofbirth))) {
					$chronicling_params{'state'} = ucfirst(lc($stateofdeath));

					# TODO: married and maiden names, could be two searches
					chronicling_america($person, \%chronicling_params);
				}
			}
			if(defined($yob) && defined($yod)) {
				obituaries({ person => $person, first => $firstname, last => $lastname, yob => $yob, yod => $yod, age => $yod - $yob });

				my $sex = get_value({ person => $person, value => 'sex' });
				if(defined($sex) && ($sex eq 'F') && (my $husband = $person->husband())) {
					my $married_name = ucfirst(lc($husband->surname()));
					if($married_name eq $lastname) {
						complain({ person => $person, warning => 'Maiden name same as married name' });
					}
					obituaries({ person => $person, first => $firstname, last => $married_name, yob => $yob, yod => $yod, age => $yod - $yob });
				}
			}

			# The wills database currently only contains Kent
			if($yod && ($placeofdeath =~ /Kent, England/)) {
				wills({ person => $person, first => $firstname, last => $lastname, year => $yod });
			}
		}
	}

	my %citations;
	my $citationcount = 0;
	my @birthcitations;
	my @deathcitations;
	if($opts{'c'}) {
		print "Gathering citations for basic information\n" if($opts{'v'});

		if($birth) {
			my @s = $birth->source();
			if($opts{'w'}) {
				foreach my $s(@s) {
					if((!defined(get_source({ gedcom => $ged, person => $person, source => $s }))) &&
					    !defined($s->items())) {
						complain({ person => $person, warning => 'Birth citation is missing a source' });
					}
				}
			}
			@s = cache_array(@s);
			@s = sort { (get_source({ gedcom => $ged, person => $person, source => $a }) && get_source({ gedcom => $ged, person => $person, source => $b })) ? get_source({ gedcom => $ged, person => $person, source => $a })->title() cmp get_source({ gedcom => $ged, person => $person, source => $b })->title() : 0 } @s;
			if(scalar(@s)) {
				my $previous;
				foreach my $src(@s) {
					$src = get_source({ gedcom => $ged, person => $person, source => $src}) unless ref($src);
					if(defined($src) && (my $title = $src->title())) {
						next if($previous && ($title eq $previous));
						$previous = $title;
						push @birthcitations, ++$citationcount;
						$citations{$citationcount} = $src;
					} elsif($src->items()) {
						my @items = $src->items();
						if($items[0]->{'value'}) {
							push @birthcitations, ++$citationcount;
							$citations{$citationcount} = $items[0];
						}
					}
				}
			} elsif($opts{'w'}) {
				if($dateofbirth) {
					complain({ person => $person, warning => "Birth date ($dateofbirth) has no citations" });
				} elsif($placeofbirth) {
					complain({ person => $person, warning => "Birth place ($placeofbirth) has no citations" });
				} else {
					complain({ person => $person, warning => 'Birth record has no citations' });
				}
			}
		}
		if($death) {
			my @s = $death->source();
			if($opts{'w'}) {
				foreach my $s(@s) {
					if((!defined(get_source({ gedcom => $ged, person => $person, source => $s }))) &&
					   (!defined($s->items())) &&
					   (!defined($s->value()))) {
						complain({ person => $person, warning => 'Death citation is missing a source' });
					}
				}
			}
			@s = sort { (get_source({ gedcom => $ged, person => $person, source => $a }) && get_source({ gedcom => $ged, person => $person, source => $b })) ? get_source({ gedcom => $ged, person => $person, source => $a })->title() cmp get_source({ gedcom => $ged, person => $person, source => $b })->title() : 0 } @s;
			if(scalar(@s)) {
				foreach my $src(@s) {
					$src = $ged->get_source($src) unless ref($src);
					my $seen;
					foreach my $bc(@birthcitations) {
						if($src eq $citations{$bc}) {
							push @deathcitations, $bc;
							$seen++;
							last;
						}
					}
					if(!$seen) {
						push @deathcitations, ++$citationcount;
						$citations{$citationcount} = $src;
					}
				}
				@deathcitations = cache_array(@deathcitations);
			} elsif($opts{'l'} || !is_alive(person => $person)) {
				if($dateofdeath) {
					# my $dateismissing = 0;
					# my @objects = $person->obje();
					# foreach my $o(@objects) {
						# my $obje;
						# if(ref($o) eq 'Gedcom::Record') {
							# $obje = $o;	# e.g. Ancestry
						# } else {
							# $obje = $ged->resolve_xref($o);	# e.g. FMP
						# }
						# foreach my $item($obje->items()) {
							# next if($item->tag() ne '_DATE');
							# if($item->value() eq $dateofdeath) {
								# $dateismissing = 0;
								# last;
							# }
						# }
					# }
					# if($dateismissing) {
						complain({ person => $person, warning => "Death date ($dateofdeath) has no citations" });
					# }
				} elsif($placeofdeath) {
					complain({ person => $person, warning => "Death place ($placeofdeath) has no citations" });
				} else {
					complain({ person => $person, warning => 'Death record exists with no date or place' });
				}
			}
		}
	}

	my @events = $person->event();

	if(scalar(@events) > 1) {
		# my $all_have_dates = 1;
		# foreach my $event(@events) {
			# if(!ref($event)) {
				# $all_have_dates = 0;
				# last;
			# }
			# if(ref($event) ne 'Gedcom::Record') {
				# $all_have_dates = 0;
				# last;
			# }
			# if(my $date = $event->date()){
				# if(($date =~ /^abt/) || !$dfg->parse_datetime(date => $date)) {
					# $all_have_dates = 0;
					# last;
				# }
			# } else {
				# $all_have_dates = 0;
				# last;
			# }
		# }
		# if($all_have_dates) {
		if(all_records_have_date({ person => $person, records => \@events })) {
			# print join(' ', map { $_->date() } @events), "\n";
			# @events = Sort::Key::DateTime::dtkeysort { $dfg->parse_datetime(date => $_->date()) } @events;
			@events = Sort::Key::DateTime::dtkeysort { $dfn->parse_datetime(@{$date_parser->parse(date => $_->date())}[0]->{'canonical'}) } @events;
			# print join(' ', map { $_->date() } @events), "\n";
		}
	}

	if((!defined($marriage)) && scalar(@spouses)) {
		$marriage = $spouses[0]->get_record('marriage');
		if(!defined($marriage)) {
			if(scalar(@events) == 1) {
				my $event = $person->event();
				if(!ref($event)) {
					my $e = $person->tag_record('EVEN');
					if(ref($e) eq 'Gedcom::Record') {
						$event = $e;
					}
				}
				if((ref($event) eq 'Gedcom::Record') &&
				  ($event->type() eq 'Custom Marriage')) {
					# FindMyPast
					$marriage = $event;
				}
			} else {
				foreach my $event(@events) {
					if((ref($event) eq 'Gedcom::Record') &&
					  ($event->type() eq 'Custom Marriage')) {
						# FindMyPast
						$marriage = $event;
						last;
					}
				}
			}
		}
	}

	my $birth_dt = date_to_datetime(date => $dateofbirth);

	if($birth_dt && (my $spouse = $spouses[0])) {
		my $sdob = dateofbirth($spouse);
		if($sdob && (my $sbirth_dt = date_to_datetime(date => $sdob))) {
			if($sbirth_dt > ($birth_dt + $fortyyears)) {
				complain({
					person => $person,
					warning => 'Spouse born more than 40 years after date of birth'
				});
			} elsif($birth_dt > ($sbirth_dt + $fortyyears)) {
				complain({
					person => $person,
					warning => 'Born more than 40 years after date of birth of spouse'
				});
			}
		}
	}

	my $marriage_dt;
	if($dateofmarriage) {
		$marriage_dt = $dfg->parse_datetime(date => $dateofmarriage, quiet => 1);
	}

	if($birth_dt && $marriage_dt && $opts{'w'} && ($marriage_dt < ($birth_dt + $sixteenyears))) {
		complain({
			person => $person,
			warning => 'married when less than 16 years old'
		});
	}

	my $death_dt = date_to_datetime(date => $dateofdeath);

	if($opts{'d'} || $opts{'B'}) {
		my $baptism = $person->get_record('baptism');
		my $dateofbaptism = get_value({ person => $person, value => 'baptism date' });
		if((!$dateofbaptism) && $baptism) {
			$dateofbaptism = $baptism->date();
		}
		if(defined($dateofbaptism) && ($dateofbaptism =~ /^0/)) {
			complain({ person => $person, warning => "Removing leading 0 from baptism date '$dateofbaptism'" });
			$dateofbaptism =~ s/^0//;
		}
		if($dateofbaptism && $dateofbirth && ($dateofbirth !~ /^abt\s/i) && ($dateofbaptism !~ /^bet \d{3,4} and \d{3,4}$/) && (datecmp($dateofbaptism, $dateofbirth) <= 0)) {
			complain({ person => $person, warning => "Date of baptism ($dateofbaptism) before date of birth ($dateofbirth)" });
		}
		my $placeofbaptism = get_value({ person => $person, value => 'baptism place' });
		if((!$placeofbaptism) && $baptism) {
			$placeofbaptism = $baptism->place();
		}

		my $placeofmarriage = get_value({ person => $person, value => 'marriage place' });
		if((!$placeofmarriage) && $marriage) {
			$placeofmarriage = $marriage->place();
		}
		if($placeofmarriage) {
			if(lc($placeofmarriage) eq 'unknown') {
				$placeofmarriage = undef;
			} elsif($placeofmarriage =~ /.+,\s?(.+)$/) {
				my $c = $1;
				if($c eq 'Scot') {
					complain({ person => $person, warning => "$c: marriage country should be Scotland'" });
					$placeofmarriage .= 'land';
				}
			}
		}

		my $burial;
		my $dateofburial;
		my $placeofburial;
		my $cremation;
		my $dateofcremation;
		my $placeofcremation;
		if($burial = $person->get_record('burial')) {
			$dateofburial = get_value({ person => $person, value => 'burial date' });
			if(!$dateofburial) {
				$dateofburial = $burial->date();
			}
			$placeofburial = get_value({ person => $person, value => 'burial place' });
			if(!$placeofburial) {
				$placeofburial = $burial->place();
			}
		} elsif($cremation = $person->get_record('cremation')) {
			$dateofcremation = get_value({ person => $person, value => 'cremation date' });
			if(!$dateofcremation) {
				$dateofcremation = $cremation->date();
			}
			$placeofcremation = get_value({ person => $person, value => 'cremation place' });
			if(!$placeofcremation) {
				$placeofcremation = $cremation->place();
			}
		}

		my $marriagecitation;
		my @burialcitations;
		if($opts{'c'}) {
			if($marriage) {
				if(my $src = $marriage->source()) {
					$src = $ged->get_source($src) unless ref($src);
					# FIXME:  Only looks for matches in the first citations
					if(!defined($src)) {
						complain({
							person => $person,
							warning => [ "marriage citation can't find source ", $marriage->source() ]
						});
					} elsif($birthcitations[0] && ($citations{$birthcitations[0]} eq $src)) {
						$marriagecitation = $birthcitations[0];
					} elsif($birthcitations[1] && ($citations{$birthcitations[1]} eq $src)) {
						$marriagecitation = $birthcitations[1];
					} elsif($deathcitations[0] && ($citations{$deathcitations[0]} eq $src)) {
						$marriagecitation = $deathcitations[0];
					} else {
						$marriagecitation = ++$citationcount;
						$citations{$marriagecitation} = $src;
					}
				} elsif($opts{'w'}) {
					if($dateofmarriage) {
						red_warning({ person => $person, warning => "Marriage date ($dateofmarriage) has no citations" });
					} elsif($placeofmarriage) {
						red_warning({ person => $person, warning => "Marriage place ($placeofmarriage) has no citations" });
					} else {
						red_warning({ person => $person, warning => 'Marriage record has no citations' });
					}
				}
			}
			if($burial) {
				if($opts{'w'} && defined($cremation)) {
					complain({ person => $person, warning => 'Person has both burial and cremation records' });
				}
				my @s = $burial->source();
				if(scalar(@s)) {
					foreach my $src(@s) {
						$src = $ged->get_source($src) unless ref($src);
						if(!defined($src)) {
							complain({
								person => $person,
								warning => [ "burial citation can't find source ", $burial->source() ]
							});
							next;
						}
						my $seen;
						foreach my $dc(@deathcitations) {
							if($src eq $citations{$dc}) {
								push @burialcitations, $dc;
								$seen++;
								last;
							}
						}
						if(!$seen) {
							if($marriagecitation && ($citations{$marriagecitation} eq $src)) {
								push @burialcitations, $marriagecitation;
							} else {
								push @burialcitations, ++$citationcount;
								$citations{$citationcount} = $src;
							}
						}
					}
				} elsif($opts{'w'}) {
					if($dateofburial) {
						complain({ person => $person, warning => "Burial date ($dateofburial) has no citations" });
					} elsif($dateofcremation) {
						complain({ person => $person, warning => "Cremation date ($dateofcremation) has no citations" });
					} elsif($placeofburial) {
						# utf8::decode($placeofburial);
						complain({ person => $person, warning => "Burial place ($placeofburial) has no citations" });
					} else {
						# utf8::decode($placeofcremation);
						complain({ person => $person, warning => "Cremation place ($placeofcremation) has no citations" });
					}
				}
			}
		}

		my $pronoun = ucfirst(i18n($person->pronoun()));

		my $sex = $person->sex();

		if($opts{'w'} && $firstname && $sex) {
			# FIXME: This throws up a number of false positives
			my $guess;
			if($placeofbirth && ($placeofbirth =~ /, USA$/)) {
				$guess = Text::Names::guessGender($firstname);
			} else {
				$guess = Text::Names::GB::guessGender($firstname);
			}
			if($guess && ($sex ne $guess)) {
				my $error = 1;
				if(my $middle_name = $name_components{'middle_name'}) {
					if($placeofbirth && ($placeofbirth =~ /, USA$/)) {
						$guess = Text::Names::guessGender($middle_name);
					} else {
						$guess = Text::Names::GB::guessGender($middle_name);
					}
					if($guess && ($sex eq $guess)) {
						$error = 0;
					}
				}
				if($error) {
					complain({ person => $person, warning => 'Check the gender of the record' });
				}
			}
		}

		my @children = map { $_->children() } $person->fams();
		my $numberofchildren = scalar(@children);

		if($opts{'w'} && $numberofchildren) {
			foreach my $child(@children) {
				if($child->xref() eq $person->xref()) {
					complain({ person => $person, warning => 'person is own parent' });
					# Avoid loops in G::I::Relationship
					return;
				}
				if($dateofdeath && (my $cdob = dateofbirth($child))) {
					if(($cdob =~ /\d{3,4}$/) && (datecmp($cdob, $dateofdeath) > 0)) {
						complain({ person => $person,
							warning => "Date of birth $pronoun child " . $child->as_string() . " ($cdob) is later than " . ($sex eq 'M' ? 'his' : 'her') . " own date of death ($dateofdeath)"
						})
					}
				}
			}
			if($numberofchildren >= 2) {
				if((my $first = dateofbirth(person => $children[0])) &&
				   (my $second = dateofbirth(person => $children[1]))) {
					if($first =~ /.*?(\d{3,4})$/) {
						$first = $1;
						if($second =~ /.*?(\d{3,4})$/) {
							$second = $1;
							my $gap = abs($first - $second);
							if($gap >= 40) {
								complain({
									person => $person,
									warning => "Large age gap ($gap years) between the two children"
								});
							}
						}
					}
				}
			}
		}

		my $relationship;
		my $spouserelationship;
		my $spouse;

		if($dateofbirth && $opts{'w'} && scalar(@siblings)) {
			foreach my $sibling(@siblings) {
				if(($sibling->name() eq $person->name()) || Text::Names::samePerson($sibling->name(), $person->name())) {
					my $siblingbirth = dateofbirth($sibling);
					if($siblingbirth && ($siblingbirth eq $dateofbirth)) {
						complain({ person => $sibling, warning => 'possible duplicate person' });
					} elsif((!$dateofdeath) && !dateofdeath($sibling)) {
						complain({ person => $sibling, warning => 'two siblings of the same name alive at the same time'});
					}
				}
			}
		}

		if($me && ($person->xref() ne $me->xref()) && !$opts{'G'}) {
			$relationship = $me->relationship($person);
			if((!$relationship) && scalar(@spouses)) {
				if($person->spouse()->xref() eq $me->xref()) {
					$relationship = i18n(($sex eq 'F') ? 'wife' : 'husband');
				} else {
					foreach my $s(@spouses) {
						$spouserelationship = $me->relationship($s);
						if($spouserelationship) {
							$spouse = $s;
							last;
						}
					}
				}
			}
			if((!$relationship) && (!$spouserelationship)) {
				complain({
					person => $person,
					warning => "Can't find relationship with the home person"
				});
			}
		}

		# if($opts{'w'} && (my $dbpedia = dbpedia({ person => $person, birth_dt => $birth_dt, yob => $yob, yod => $yod }))) {
			# FIXME: add citation
			# if($opts{'B'}) {
				# pdfprint(string => "\t$dbpedia\n\t", text => $text, pdfpage => $pdfpage);
			# } else {
				# print "\t$dbpedia\n\t";
			# }
		# }

		my @phrases;
		my $bio = Data::Text->new("\t");
		my $phrase = Data::Text->new();
		my $haveprintedspousename;
		my $noun = $firstname // $pronoun;

		if($aob || $aod || $relationship || $spouserelationship) {
			my $str = $noun;

			$noun = $pronoun;
			if(my $aka = $person->as_string({ use_aka => 1 })) {
				$str .= " (also known as $aka)";
			}
			if($aob || $aod) {
				$str .= ',';
			}

			$phrase->append("$str ");
		}

		if($relationship) {
			if($aob || $aod) {
				$phrase->append(i18n('your'))->append(" $relationship, ");
			} else {
				$noun = $firstname // $pronoun;
				$phrase->set("$noun ");	# Overwrites what was stored above
				$noun = $pronoun;
				if(is_alive(person => $person)) {
					$phrase->append(i18n('is '));
				} else {
					$phrase->append(i18n('was '));
				}
				$phrase->append(i18n('your'))->append(" $relationship");
			}
		} elsif($spouserelationship) {
			if((!$aob) && (!$aod)) {
				if(is_alive(person => $person)) {
					$phrase->append(i18n('is '));
				} else {
					$phrase->append(i18n('was '));
				}
			}
			if($language eq 'French') {
				if($sex eq 'F') {
					$phrase->append('la femme');
				} else {
					$phrase->append('le mari');
				}
			} else {
				if($sex eq 'F') {
					$phrase->append('the wife');
				} else {
					$phrase->append('the husband');
				}
			}
			$phrase->append(i18n(' of '));
			if(my $s = $spouse->as_string({ middle_names => 1, title => 1 })) {
				$phrase->append("$s (");
			} else {
				complain({ person => $spouse, warning => 'Seems to have no name' });
			}
			$phrase->append(i18n('your ') . $spouserelationship)->append(') ');
			$haveprintedspousename = 1;
		}

		my @occupations = get_all_occupations(person => $person);
		my $same_occupation_as_father;

		if($aob && $aod) {
			if($aob == $aod) {
				$phrase->append("was born and died $aod years ago ");
			} else {
				$phrase->append("was born $aob years and died $aod years ago ");
			}
			$phrase->append(i18n(($opts{'t'} ? 'tomorrow' : 'today')));
			$phrase->append("[$_]") foreach(@birthcitations);
			$phrase->append("[$_]") foreach(@deathcitations);
		} elsif($aob) {
			$phrase->append(i18n({ person => $person, format => 'was born ' }));
			if($language eq 'French') {
				$phrase->append("il y a $aob " . (($aob == 1) ? 'an' : 'ans') .
					($opts{'t'} ? ' demain' : " aujourd'hui"));
			} else {
				$phrase->append("$aob " . (($aob == 1) ? 'year' : 'years') . ' ago ' .
					i18n(($opts{'t'} ? 'tomorrow' : 'today')));
			}
			if($placeofbirth) {
				my $p = place({ person => $person, record => $birth, places_printed => \%places_printed, encode => 0 });
				if(!defined($p)) {
					# Most likely there was more than one birth() record
					die 'BUG: ', $person->as_string(), ": place() returned undef on '$placeofbirth'";
				}
				$phrase->append($p);
				$places_printed{$p} = 1;
			} else {
				complain({ person => $person, warning => 'Date of birth is known, but not place' });
			}
			$phrase->append("[$_]") foreach(@birthcitations);
		} elsif($aod) {
			if($language eq 'French') {
				$phrase->append('est mort');
				if($sex eq 'F') {
					$phrase->append('e');
				}
				$phrase->append(" il y a $aod " . (($aod == 1) ? 'an' : 'ans') .
					($opts{'t'} ? ' demain' : " aujourd'hui"));
			} else {
				$phrase->append("died $aod " . (($aod == 1) ? 'year' : 'years') . ' ago ' .
					i18n(($opts{'t'} ? 'tomorrow' : 'today')));
			}
			if($placeofdeath) {
				$phrase->append(place({ person => $person, record => $death, places_printed => \%places_printed }));
			}
			$phrase->append("[$_]") foreach(sort @deathcitations);

			# Cause of death
			if(my $cause = $person->cause()) {
				$cause = lc($cause);
				$phrase->append(" ($cause)");
			}

			if($death && (my $notes = notes({ person => $person, record => $death, paragraph => 0 }))) {
				$notes =~ s/\.$//;
				$notes = lcfirst($notes) unless($notes =~ /^[A-Z]{2}/);
				$phrase->append(" ($notes)");
				push @phrases, $phrase;
				$bio->append(conjunction(map { $_->as_string() } @phrases));
				undef @phrases;
				$phrase = Data::Text->new();
				if($notes !~ /\."$/) {
					$bio->append('.');
				}
				if(length($notes) > 160) {
					$bio->append("\n\t");
				} else {
					$bio->append('  ');
				}
			}
		}

		if($phrase->length()) {
			push @phrases, $phrase->trim();
			$phrase = Data::Text->new();
		}
		if(scalar(@phrases)) {
			$bio->append(conjunction(map { $_->as_string() } @phrases))->append('.  ');
			$phrase = Data::Text->new();
			@phrases = ();
		}

		if($father || $mother) {
			if($phrase->length() > 0) {
				if($language eq 'French') {
					$phrase->append(' et l');
				} else {
					$phrase->append(' and the ');
				}
			} else {
				if(scalar(@phrases) == 0) {
					$phrase->set(ucfirst($noun));
					if(($noun eq $firstname) && (my $aka = $person->as_string({ use_aka => 1 }))) {
						$phrase->append(", also known as $aka,");
					}
					$noun = $pronoun;
				}
				if(is_alive(person => $person)) {
					$phrase->append(i18n(' is '));
				} else {
					$phrase->append(i18n(' was '));
				}
				if($language eq 'French') {
					$phrase->append('l');
				} else {
					$phrase->append('the ');
				}
			}

			if($birth_dt) {
				if(scalar(@siblings)) {
					# If possible, sort siblings by date of birth
					my $all_siblings_have_dob = 1;
					foreach my $sibling(@siblings) {
						if(my $dob = dateofbirth($sibling)) {
							if($dob =~ /\s$/) {
								complain({ person => $sibling, warning => 'Removing trailing spaces from date of birth' });
								$dob =~ s/\s+$//;
							}
							if($dob =~ /\d{3,4}$/) {
								if(!date_parser_cached(date => $dob)) {
									complain({
										person => $sibling,
										warning => "has an invalid date of birth: $dob"
									});
									$all_siblings_have_dob = 0;
									last;
								}
								if(($dob !~ /^\d/) || ($dob =~ /[a-z]$/i) ||
								   ($dob =~ /[\/\-]/)) {
									$all_siblings_have_dob = 0;
									last;
								}
							} else {
								$all_siblings_have_dob = 0;
								last;
							}
						} else {
							$all_siblings_have_dob = 0;
							last;
						}
					}
					if($all_siblings_have_dob) {
						@siblings = Sort::Key::DateTime::dtkeysort { $dfn->parse_datetime(@{$date_parser->parse(date => dateofbirth($_))}[0]->{'canonical'}) } @siblings;
					}
					my $age_index = 1;	# count of siblings born before $person + 1 (i.e. where $person is in the date order)
					foreach my $sibling(@siblings) {
						if(my $dob = dateofbirth($sibling)) {
							if($dob =~ /\s$/) {
								complain({ person => $sibling, warning => 'Removing trailing spaces from date of birth' });
								$dob =~ s/\s+$//;
							}
							if(($dob =~ /\d{3,4}$/) &&
							   (my $d = date_parser_cached(date => $dob))) {
								$d = $dfn->parse_datetime($d->{'canonical'});
								if($opts{'w'} &&
								  ($dob =~ /^\d/) && ($dob !~ /[a-z]$/i) &&
								  ($d < $birth_dt) &&
								  ($d < ($birth_dt - $oneday)) &&
								  ($d > ($birth_dt - $tenmonths))) {
									complain({
										person => $sibling,
										warning => 'Born less than 10 months before sibling ' . $person->as_string()
									});
								}
								$age_index++ if($d && ($d < $birth_dt));
							} else {
								$all_siblings_have_dob = 0;
								last;
							}
						} else {
							$all_siblings_have_dob = 0;
							last;
						}
					}
					if($all_siblings_have_dob) {
						if($language eq 'French') {
							$phrase->append('e ');
						}
						if(scalar(@siblings) && ($age_index == (scalar(@siblings) + 1))) {
							if($language eq 'French') {
								$phrase->append(($sex eq 'M') ? 'dernier' : "derni\N{U+00E8}re");
							} else {
								$phrase->append(((scalar(@siblings) > 1) ? 'youngest' : 'younger'));
							}
						} elsif(scalar(@siblings) && ($age_index == 1)) {
							if(scalar(@siblings) > 1) {
								$phrase->append(i18n({ person => $person, format => 'eldest' }));
							} else {
								$phrase->append(i18n({ person => $person, format => 'older' }));
							}
						} elsif($language eq 'French') {
							$phrase->append(Lingua::FR::Numbers::Ordinate::ordinate($age_index));
						} else {
							$phrase->append(ordinate($age_index));
						}
						$phrase->append(i18n(' of %d children', scalar(@siblings) + 1));
					} else {
						if($language eq 'French') {
							$phrase->append("'enfant");
						} else {
							$phrase->append(i18n('child'));
						}
					}
				} else {
					# print ' only child of';
					if($language eq 'French') {
						$phrase->append("'enfant");
					} else {
						$phrase->append(i18n('child'));
					}
				}
			} else {
				if($language eq 'French') {
					$phrase->append("'enfant");
				} else {
					$phrase->append(i18n('child'));
				}
			}
			if($language eq 'French') {
				$phrase->replace({ 'Le a' => "L'a" });
				$phrase->replace({ 'le a' => "l'a" });
			}

			if($father) {
				if(($language eq 'French') && ($father->as_string() =~ /^[aehiou]/i)) {
					$phrase->append(" d'");
				} else {
					$phrase->append(i18n(' of '));
				}
				$phrase->append($father);
				if(!$same_occupation_as_father) {
					my @occupations = get_all_occupations(person => $father);
					# TODO: print all occupations
					if(my $occupation = $occupations[0]) {
						$occupation = lc($occupation);
						if($language eq 'English') {
							if($ENV{'LANG'} =~ /^en_US/) {
								$occupation = Lingua::EN::ABC::b2a($occupation);
							} elsif($ENV{'LANG'} =~ /^en_CA/) {
								$occupation = Lingua::EN::ABC::b2c($occupation);
							} else {
								$occupation = Lingua::EN::ABC::a2b($occupation);
							}
						}
						if($language eq 'French') {
							$phrase->append(" (un $occupation)");
						} else {
							$phrase->append(' (' . Lingua::EN::Inflect::A($occupation) . ')');
						}
					}
				}
				if($mother) {
					$phrase->append(i18n(' and'));
				} elsif(($aob || $dateofbirth || $dateofbaptism || $placeofbirth || $placeofbaptism || $relationship || scalar(@spouses)) && $occupations[0]) {
					push @phrases, $phrase;
					$phrase = Data::Text->new();
				}
			} else {
				$phrase->append(i18n(' of'));
			}

			if($mother) {
				if(my $m = $mother->as_string(give_maidenname => 0)) {
					$phrase->append(" $m");
				}
				my @occupations = get_all_occupations($mother);
				# TODO: print all occupations
				if($occupations[0]) {
					$phrase->append(' (' . Lingua::EN::Inflect::A(lc($occupations[0])) . ')');
				}
				if($opts{'w'} && $birth_dt && (my $mdod = dateofdeath($mother))) {
					if(my $dt = date_to_datetime(date => $mdod)) {
						if($birth_dt > $dt) {
							complain({ person => $person, warning => 'Born after mother died' });
						}
					}
				}
			}
			if($language eq 'French') {
				if($father && ($father->as_string() =~ /^[aehiou]/i)) {
					$phrase->replace({ "\tThe child of", "\tL'enfant d'" });
					$phrase->replace({ ' and the child of ', " et l'enfant d'" });
				} else {
					$phrase->replace({ "\tThe child of", "\tL'enfant de " });
					$phrase->replace({ ' and the child of ', " et l'enfant de " });
				}
			}
			if($phrase->length()) {
				push @phrases, $phrase;
				$phrase = Data::Text->new();
			}
		}

		if($occupations[0]) {
			my @foccupations;
			if($father) {
				@foccupations = get_all_occupations(person => $father);
			}
			if(scalar(@foccupations) && ($occupations[0] eq $foccupations[0])) {
				$same_occupation_as_father = $occupations[0];
				@occupations = ();
			} else {
				if((!$aob) && (!$aod) && ($mother || $father)) {
					if($phrase->length()) {
						push @phrases, $phrase;
					}
					if(scalar(@phrases)) {
						$bio->append(conjunction(map { $_->as_string() } @phrases))->append('.  ');
						$phrase = Data::Text->new();
						@phrases = ();
					}
				}

				if(scalar(@phrases) == 0) {
					$phrase->set("$noun ");
					$noun = $pronoun;
				}

				if(is_alive(person => $person)) {
					$phrase->append(i18n('is '));
				} else {
					$phrase->append(i18n('was '));
				}

				my $article;
				if($occupations[0] =~ /^[aeiou]/i) {
					$article = 'an';
				} else {
					$article = 'a';
				}

				$phrase->append(i18n({
					person => $person,
					format => "$article %s",
					args => lc(conjunction(@occupations))
				}));

				push @phrases, $phrase;
				$phrase = Data::Text->new();
			}
		}

		if(($dateofbaptism || $placeofbaptism) && !($mother || $father)) {
			complain({ person => $person, warning => 'Baptism information not used to determine a parent' });
		}

		if($birth_dt) {
			my @twins = twins({ birth_dt => $birth_dt, siblings => \@siblings });

			if(scalar(@twins) == 1) {	# TODO triplets and higher order
				if((scalar(@phrases) > 0) && ($phrase->length == 0)) {
					$phrase->set(i18n({ person => $person, format => 'twin of' }));
				} else {
					if($language eq 'French') {
						if($sex eq 'M') {
							$phrase->set("Le jumeau fr\N{U+00E8}re de");
						} else {
							$phrase->set('La jumelle sÅer de');
						}
					} else {
						$phrase->set('The twin ' . i18n((($sex eq 'M') ? 'brother' : 'sister')) .
							i18n(' of'));
					}
				}
				$phrase->append(' ' . $twins[0]->{'sibling'}->given_names());
			}
		}

		if(($aob || $aod) && scalar(@phrases)) {
			push @phrases, $phrase;
			$bio->append(conjunction(map { $_->as_string() } @phrases))->append('.  ');
			$phrase = Data::Text->new();
			@phrases = ();
		}

		if((!$aob) && ($dateofbirth || $dateofbaptism || $placeofbirth || $placeofbaptism)) {

			if($dateofbirth || $placeofbirth) {
				my $birth_place;
				if($placeofbirth) {
					if($aod && $placeofdeath && ($placeofbirth eq $placeofdeath) && !$death->address()) {
						if($language eq 'French') {
							$phrase->append('y ');
						} elsif($language eq 'German') {
							$birth_place = ' dort';
						} else {
							$birth_place = ' there';
						}
					} else {
						$birth_place = place({ person => $person, place => $placeofbirth, places_printed => \%places_printed });
					}
				} else {
					complain({ person => $person, warning => 'Date of birth is known, but not place' });
				}

				if(scalar(@phrases) == 0) {
					$phrase->set("$pronoun ");
				}
				$phrase->append(i18n({ person => $person, format => 'was born' }));
				$phrase->append($birth_place) if($birth_place);

				if($dateofbirth) {
					if($dateofbirth =~ /\s$/) {
						complain({ person => $person, warning => "Removing trailing spaces from date of birth '$dateofbirth'" });
						$dateofbirth =~ s/\s+$//;
					}
					my $y = between(year({
						person => $person,
						date => $dateofbirth,
						must_predate => $death_dt
					}));
					$phrase->append(" $y") if($y);
				}
				$phrase->append("[$_]") foreach(@birthcitations);
				if($opts{'w'}) {
					if($mother && $yob && (my $mumdateofbirth = dateofbirth($mother))) {
						if($mumdateofbirth =~ /.*?(\d{3,4})/) {
							$mumdateofbirth = $1;
							if(($yob - $mumdateofbirth) <= 13) {
								complain({
									person => $person,
									warning => "Something is wrong with the date of birth which is less than 13 years after the mother was born ($mumdateofbirth)"
								});
							} elsif(($yob - $mumdateofbirth) >= 52) {
								complain({
									person => $person,
									warning => "Something is wrong with the date of birth which is more than 52 years after the mother was born ($mumdateofbirth)"
								});
							}
						}
					}
					if($father && $yob && (my $daddateofbirth = dateofbirth($father))) {
						if($daddateofbirth =~ /.*?(\d{3,4})/) {
							$daddateofbirth = $1;
							if(($yob - $daddateofbirth) <= 13) {
								complain({
									person => $person,
									warning => "Something is wrong with the date of birth which is less than 13 years after the father was born ($daddateofbirth)"
								});
							}
						}
					}
					# if($birth_dt || ($dateofbirth && ($dateofbirth =~ /^\d{3,4}$/))) {
						# TODO: Add more checking
						# TODO: remove this code once I've done a run
						# my $yob;
						# if($birth_dt) {
							# $yob = $birth_dt->year();
						# } elsif($dateofbirth =~ /^(\d{3,4})$/) {
							# $yob = $1;
						# } else {
							# die 'BUG: Impossible case';
						# }
					# }
					if(defined($yob)) {
						foreach my $dc(@deathcitations) {
							my $citation = $citations{$dc};
							if(my $title = $citation->title()) {
								if($title =~ /^(\d{3,4})\s/) {
									if($1 < $yob) {
										complain({
											person => $person,
											warning => "Year of citation of $title is before the birth year of $yob"
										});
									}
								}
							}
						}
					}
					# if($death_dt || ($dateofdeath && ($dateofdeath =~ /^\d{3,4}$/))) {
						# # TODO: Add more checking
						# my $yod;
						# if($death_dt) {
							# $yod = $death_dt->year();
						# } elsif($dateofdeath =~ /^(\d{3,4})$/) {
							# $yod = $1;
						# } else {
							# die "BUG: Impossible case";
						# }
					# }
					if(defined($yod)) {
						foreach my $bc(@birthcitations) {
							my $citation = $citations{$bc};
							if(my $title = $citation->title()) {
								if($title =~ /^(\d{3,4})\s/) {
									if($1 > $yod) {
										complain({
											person => $person,
											warning => "Year of citation of $title is after the death year of $yod"
										});
									}
								}
							}
						}
					}
				}
				if($dateofbaptism || $placeofbaptism) {
					push @phrases, $phrase;
					$phrase = Data::Text->new();
				} elsif($birth_dt) {
					if(!$aob) {
						my @twins = twins({ birth_dt => $birth_dt, siblings => \@siblings });
						if(scalar(@twins) == 1) {	# TODO triplets and higher order
							my $t = $twins[0];
							my $sibling = $t->{'sibling'};
							my $dob = $t->{'dob'};
							if($dob == $birth_dt) {
								$phrase->append(' along with ');
							} else {
								push @phrases, $phrase;
								$phrase = Data::Text->new();

								if($dob == ($birth_dt + $oneday)) {
									$phrase->set(i18n('a day before '));
								} else {
									$phrase->set('a day after ');
								}
							}
							my $ssex = $sibling->sex();
							if($language eq 'French') {
								$phrase->append(($ssex eq 'M' ? "son jumeau fr\N{U+00E8}re " : "sa jumelle s\N{U+0153}er "));
							} else {
								$phrase->append(($sex eq 'M' ? 'his' : 'her') . ' twin ' .
									i18n(($ssex eq 'F') ? 'sister ' : 'brother '));
							}
							if(my $given = given_names($sibling)) {
								$phrase->append($given);
							}
						}
					}

					if($phrase->length() > 0) {
						push @phrases, $phrase;
						$phrase = Data::Text->new();
					}
				}
			}
			if($dateofbaptism || $placeofbaptism) {
				if((scalar(@phrases) == 0) && ($phrase->length() == 0)) {
					$phrase->set("$pronoun ");
				} elsif(scalar(@phrases) >= 3) {
					push @phrases, $phrase;
					$bio->append(conjunction(map { $_->as_string() } @phrases))->append('.  ');
					$phrase = Data::Text->new("$pronoun ");
					@phrases = ();
				}
				unless($dateofbirth || $placeofbirth) {
					if($language eq 'French') {
						if(($aod || $opts{'a'} || $opts{'p'}) && $placeofbaptism && $placeofbirth && ($placeofbaptism eq $placeofbirth)) {
							$phrase->append('y ');
						}
					}
				}
				if($language eq 'French') {
					$phrase->append("a \N{U+00E9}t\N{U+00E9} baptis\N{U+00E9}");
					if($sex eq 'F') {
						$phrase->append('e');
					}
				} elsif($ENV{'LANG'} =~ /^en_US/) {
					$phrase->append('was baptized');
				} else {
					$phrase->append('was baptised');
				}
				if($placeofbaptism) {
					if(($aod || $opts{'a'} || $opts{'p'}) && $placeofbirth && ($placeofbaptism eq $placeofbirth)) {
						$phrase->append(' there') unless($language eq 'French');
						if(my $address = $baptism->address()) {
							if($address =~ /(.+),\s*$placeofbirth$/) {
								$address = $1;
							}
							$phrase->append(i18n(' at') . " $address");
						}
					} else {
						my $p;
						if(defined($baptism)) {
							$p = place({ person => $person, record => $baptism });
						} else {
							$p = place({ person => $person, place => $placeofbaptism });
						}
						$phrase->append($p);
						$places_printed{$p} = 1;
					}
				}
				if($dateofbaptism) {
					if($opts{'w'} && $yob && ($dateofbaptism =~ /(\d{3,4})$/)) {
						# must_predate doesn't work when only years are known
						if($1 < $yob) {
							complain({
								person => $person,
								warning => "Year of baptism $1 is before the year of birth $yob"
							});
						}
					}
					$phrase->append(' ' . year({
						person => $person,
						date => $dateofbaptism,
						must_postdate => $birth_dt,
						must_predate => $death_dt
					}) . sibling_baptism_string({
						person => $person,
						siblings => \@siblings,
						date => $dateofbaptism,
						birthdate => $dateofbirth,
					}));
					if(!$death_dt) {
						must_predate({
							person => $person,
							date => $dateofbaptism,
							predate => $dateofdeath
						});
					}
					if($mother && $opts{'w'}) {
						if($dateofbaptism =~ /.*?(\d{3,4})/) {
							my $yobaptism = $1;
							if(my $motherdob = dateofbirth($mother)) {
								my $d = $date_parser->parse(date => $motherdob);
								if($d && (ref($d) eq 'ARRAY')) {
									$d = $d->[0];
									if(defined($d) && !$d->{'flag'}) {
										$d = $dfn->parse_datetime($d->{'canonical'})->strftime('%Y');
										if($d > ($yobaptism - 13)) {
											complain({
												person => $person,
												warning => "Something is wrong with the date of baptism which is less than 13 years after the mother was born ($d)"
											});
										}
									}
								}
							}
						} else {
							complain({
								person => $person,
								warning => "invalid date of baptism $dateofbaptism"
							});
						}
					}
				}
			}
			if($phrase->length()) {
				push @phrases, $phrase;
				$phrase = Data::Text->new();
			}
		} elsif($aob && ($dateofbaptism || $placeofbaptism)) {
			if((scalar(@phrases) == 0) && ($phrase->length() == 0)) {
				$phrase->set("$pronoun ");
			}
			if($language eq 'French') {
				if($placeofbaptism && $placeofbirth && ($placeofbaptism eq $placeofbirth)) {
					$phrase->append("y a \N{U+00E9}t\N{U+00E9} ");	# a Ã©tÃ©
				} else {
					$phrase->append("a \N{U+00E9}t\N{U+00E9} ");	# a Ã©tÃ©
				}
			} else {
				$phrase->append('was ');
			}

			if($language eq 'French') {
				$phrase->append("baptis\N{U+00E9}");
				if($sex eq 'F') {
					$phrase->append('e');
				}
			} elsif($ENV{'LANG'} =~ /^en_US/) {
				$phrase->append('baptized');
			} else {
				$phrase->append('baptised');
			}
			if($placeofbaptism) {
				if($placeofbirth && ($placeofbaptism eq $placeofbirth)) {
					if($aod) {
						$phrase->append(' in ' .
							lcfirst($person->possessive()) .
							' home town');
					} elsif($language eq 'French') {
						if(my $address = $baptism->address()) {
							$phrase->append(" \N{U+00E0} $address");
						}
					} else {
						$phrase->append(' there');
						if(my $address = $baptism->address()) {
							$phrase->append(" at $address");
						}
					}
				} else {
					my $opts = {
						person => $person,
						place => $placeofbaptism,
						places_printed => \%places_printed
					};
					if(my $address = $baptism->address()) {
						$opts->{'address'} = $address;
					}
					my $p = place($opts);
					$phrase->append($p);
					$places_printed{$p} = 1;
				}
			}
			if($dateofbaptism) {
				$phrase->append(' ' . year({
					person => $person,
					date => $dateofbaptism,
					must_postdate => $birth_dt,
					must_predate => $death_dt
				}) . sibling_baptism_string({
					person => $person,
					siblings => \@siblings,
					date => $dateofbaptism,
					birthdate => $dateofbirth,
				}));
			}
			push @phrases, $phrase;
			if(scalar(@spouses) == 0) {
				$bio->append(conjunction(map { $_->as_string() } @phrases))->append('.  ');
				@phrases = ();
			}
			$phrase = Data::Text->new();
		}

		# Is/was this person an orphan?
		if($mother && $father && $yob &&
		  ((my $mdod = dateofdeath($mother)) &&
		  (my $fdod = dateofdeath($father)))) {
			my $myod;
			my $fyod;
			if(($fdod =~ /.*?(\d{3,4})/)) {
				$fyod = $1;
			}
			if(($mdod =~ /.*?(\d{3,4})/)) {
				$myod = $1;
			}
			if((!defined($fyod)) || (!defined($myod))) {
				die "BUG: !fyod || !myod";
			}
			if((($fyod - $yob) < 16) && (($myod - $yob) < 16)) {
				if(scalar(@phrases) == 0) {
					$phrase->append("$pronoun ");
				}
				$phrase->append('was orphaned ');
				if($myod == $fyod) {
					$phrase->append('when both of ')
						->append(($person->pronoun() eq 'She') ? 'her' : 'his')
						->append(" parents died in $myod when ")
						->append(lcfirst($person->pronoun()))
						->append(' was ')
						->append($myod - $yob)
						->append(' years old');
				} elsif($myod > $fyod) {
					$phrase->append('at the age of ' . ($myod - $yob) .
						i18n(' following the death of ') .
						(($person->pronoun() eq 'She') ? 'her' : 'his') .
						" father in $fyod and mother in $myod");
				} else {
					$phrase->append('at the age of ' . ($fyod - $yob) .
						i18n(' following the death of ') .
						(($person->pronoun() eq 'She') ? 'her' : 'his') .
						" mother in $myod and father in $fyod");
				}
				push @phrases, $phrase;
				$bio->append(conjunction(map { $_->as_string() } @phrases))->append(".\n\t");
				$phrase = Data::Text->new();
				@phrases = ();

				if($opts{'B'} && $bio->length()) {
					if(!pdfprint(string => $bio, text => $text, pdfpage => $pdfpage)) {
						$text->textend();

						$pdfpage = NJH::PDFPage->new($pdf);

						$text = $pdfpage->text();
						$text->font($params{'font'}, 12);
						pdfprint(string => $bio, text => $text, pdfpage => $pdfpage);
					}
					$bio = Data::Text->new();
				}
			}
		}

		my $all_children_are_alive = 1;

		if($yob && ($year >= $yob + 150)) {
			$all_children_are_alive = 0;
		} else {
			foreach my $child(@children) {
				if(!is_alive(person => $child)) {
					$all_children_are_alive = 0;
					last;
				}
			}
		}

		print "all_children_are_alive = $all_children_are_alive\n" if($opts{'v'});

		my @education = $person->education();

		if(scalar(@education)) {
			if($phrase->length() > 0) {
				push @phrases, $phrase;
				$phrase = Data::Text->new();
			} elsif(scalar(@phrases) == 0) {
				$phrase->set("$pronoun ");
			}

			if($language eq 'French') {
				$phrase->append("a fait ses \N{U+00E9}tudes \N{U+00E0}");
			} else {
				$phrase->append('went to');
			}

			# FIXME: do all schools
			$phrase->append(place({ person => $person, record => $education[0], places_printed => \%places_printed, nopreposition => 1 }));
			push @phrases, $phrase;
			$phrase = Data::Text->new();
			if($numberofchildren) {
				$bio->append(conjunction(map { $_->as_string() } @phrases))->append('.  ');
				@phrases = ();
			}
		}

		my @childrenunknownparent;
		# TODO: children != 0 && spouses == 0
		if(scalar(@spouses) &&
		   ((!$spouserelationship) || $placeofmarriage || $dateofmarriage)) {
			if((scalar(@phrases) == 0) && ($phrase->length() == 0)) {
				$phrase->set("$pronoun ");
			}
			if(scalar(@spouses) == 1) {
				if($placeofmarriage || $dateofmarriage) {
					if($placeofbaptism && $placeofmarriage && ($placeofmarriage eq $placeofbaptism) &&
					   $phrase->length()) {
						$phrase->append(i18n('also '));
					}
					my %args = (person => $person);
					if($spouserelationship) {
						$args{'format'} = 'married ';
					} elsif(is_alive(person => $person) && is_alive(person => $spouses[0])) {
						if($placeofmarriage || $dateofmarriage) {
							$args{'format'} = 'married ';
						} else {
							$args{'format'} = 'is married to ';
						}
					} else {
						$args{'format'} = 'married ';
					}
					$phrase->append(i18n(\%args));

					# Note if this person married a relative
					if(my $srelationship = $person->relationship($spouses[0])) {
						$phrase->append(($person->pronoun() eq 'She') ? 'her ' : 'his ')
							->append("$srelationship ");
					}

					if($haveprintedspousename) {
						$nameparser->parse($spouses[0]->name());

						my %name_components = $nameparser->components();
						if(my $n = $name_components{'given_name_1'}) {
							$phrase->append($n);
						} else {
							complain({ person => $spouses[0], warning => 'seems to have no first name' });
						}
					} else {
						$phrase->append($spouses[0]);
						$haveprintedspousename = 1;
					}
				}

				my $parentheses = 0;
				if($numberofchildren) {
					if($placeofmarriage || $dateofmarriage) {
						my @spouse_occupations = get_all_occupations($spouses[0]);
						if(my $soccupation = $spouse_occupations[0]) {
							$parentheses = 1;
							if($language eq 'English') {
								$phrase->append(' (' . Lingua::EN::Inflect::A(lc($soccupation)) . ' ');
							} else {
								# FIXME - handle feminine versions for women
								$phrase->append(' (un ' . lc($soccupation) . ' ');
							}
						}
					}
					my @childrenofthisspouse;
					my $numberofchildrenwiththisspouse = $numberofchildren;
					my $spouse = $spouses[0];
					my $sxref = $spouse->xref();
					foreach my $child(@children) {
						if($sex eq 'F') {
							# Check through all possible fathers, since there could be a biological and
							# and adoptive ones listed
							# FIXME: this assumes that the spouse is the biological father, which is not
							#	a good assumption to make
							my @candidates = $child->father();
							my $father;
							foreach (@candidates) {
								if($_->xref() eq $sxref) {
									$father = $_;
									last;
								}
							}
							if((!defined($father)) || ($father->xref() ne $sxref)) {
								push @childrenunknownparent, $child;
								$numberofchildrenwiththisspouse--;
							} else {
								push @childrenofthisspouse, $child;
							}
						} else {
							my $mother = $child->mother();
							if((!defined($mother)) || ($mother->xref() ne $sxref)) {
								push @childrenunknownparent, $child;
								$numberofchildrenwiththisspouse--;
							} else {
								push @childrenofthisspouse, $child;
							}
						}
						if($opts{'w'} && $yob && (my $cdob = dateofbirth($child))) {
							my $age = get_year_from_date($cdob) - $yob;
							if($age <= 14) {
								complain({ person => $person, warning => "Only $age years old at time of birth of their child " . $child->as_string() });
							}
						}
					}
					if(scalar(@childrenunknownparent) < $numberofchildren) {
						if($placeofmarriage || $dateofmarriage) {
							if(!$parentheses) {
								$phrase->append(' (');
								$parentheses = 1;
							}
							if($language eq 'French') {
								$phrase->append("avec qu'");
							} elsif($language eq 'German') {
								$phrase->append('mit wem ');
							} else {
								$phrase->append('with whom ');
							}
							$phrase->append(lcfirst($pronoun) . ' ');
						}
						if((!$all_children_are_alive) || (!$opts{'l'}) || ($yob && ($year > $yob + ASSUME_NOT_LIVING))) {
							if($language eq 'French') {
								$phrase->append('a eu ');
							} else {
								if(is_alive(person => $person)) {
									$phrase->append('has ');
								}
								$phrase->append('had ');
							}
						} elsif((!$dateofdeath) && (!$dateofburial) && ($spouses[0]) && !$spouses[0]->death()) {
							$phrase->append(i18n('has had '));
						} else {
							if($language eq 'French') {
								$phrase->append($dateofdeath || $dateofburial ? 'a eu ' : 'a ');
							} else {
								$phrase->append($dateofdeath || $dateofburial ? 'had ' : 'has ');
							}
						}

						if($numberofchildrenwiththisspouse == 1) {
							if($all_children_are_alive) {
								if($language eq 'French') {
									$phrase->append('1 surviving enfant');
								} else {
									$phrase->append('1 surviving child');
								}
							} elsif($language eq 'French') {
								$phrase->append('1 enfant');
							} else {
								$phrase->append('1 child');
							}
							if($placeofmarriage || $dateofmarriage) {
								$phrase->append(',');
							}
						} else {
							if($all_children_are_alive) {
								$phrase->append("$numberofchildrenwiththisspouse surviving children");
							} elsif($language eq 'French') {
								$phrase->append("$numberofchildrenwiththisspouse enfants");
							} else {
								$phrase->append("$numberofchildrenwiththisspouse children");
							}
							if($placeofmarriage || $dateofmarriage) {
								$phrase->append(':');
							}
						}
						$phrase->append(' ');
						if((!$placeofmarriage) && !$dateofmarriage) {
							if(length(my $spouse_name = $spouse->as_string({ middle_names => 1, title => 1 }))) {
								$phrase->append(i18n({ format => 'with %s', args => $spouse_name }));
							} else {
								complain({ person => $person, warning => "Can't determine spouse name from record" });
							}
							my @spouse_occupations = get_all_occupations($spouses[0]);
							if(my $soccupation = $spouse_occupations[0]) {
								if($language eq 'English') {
									$phrase->append(' (' . Lingua::EN::Inflect::A(lc($soccupation)) . ')');
								} else {
									# FIXME - handle feminine versions for women
									$phrase->append(' (un ' . lc($soccupation) . ')');
								}
							}
							$phrase->append(': ');
							$haveprintedspousename = 1;
						}
						if($numberofchildrenwiththisspouse == 1) {
							my $child = $children[0];
							if($opts{'l'} || (!is_alive(person => $child)) || (defined($me) && ($child->xref() eq $me->xref()))) {
								if(my $first_name = given_names($child)) {
									$phrase->append($first_name);
								} else {
									$phrase->append('whose first name is unknown');
								}
							}
						} elsif($numberofchildrenwiththisspouse > 1) {
							# my $childnames = join(', ', map { $_->given_names() } @children);
							# substr($childnames, rindex($childnames, ', '), 2, ' and ');
							# print $childnames;
							# $phrase->append(conjunction(map { $_->given_names() } @childrenofthisspouse));
							my @childlist;
							my $alive_children = 0;
							foreach my $child(@childrenofthisspouse) {
								if($opts{'l'} || (!is_alive(person => $child)) || (defined($me) && ($child->xref() eq $me->xref()))) {
									my $cgiven = $child->given_names();
									# Remove the '.' from an initial
									$cgiven =~ s/[\.\s]+$//;
									push @childlist, $cgiven if(length($cgiven));
								} else {
									$alive_children++;
									# push @childlist, $child->given_names();
								}
							}
							if(scalar(@childlist)) {
								$phrase->append(conjunction(@childlist));
								if($alive_children == 1) {
									$phrase->append(', along with 1 surviving child');
								} elsif($alive_children > 1) {
									$phrase->append(", along with $alive_children surviving children");
								}
							}
						}
					}
				} else {
					my @spouse_occupations = get_all_occupations($spouses[0]);
					if($spouse_occupations[0]) {
						$phrase->append(' (' . Lingua::EN::Inflect::A(lc($spouse_occupations[0])));
						$parentheses = 1;
					}
				}
				if($parentheses) {
					$phrase->append(')');
				} elsif(($dateofmarriage || $placeofmarriage) && $numberofchildren) {
					$phrase->append(',');
				}
				if($placeofmarriage && $dateofmarriage &&
				   (($placeofbaptism and ($placeofmarriage eq $placeofbaptism)) ||
				    ($aod && $placeofbirth && ($placeofmarriage eq $placeofbirth)))) {
					if(($language eq 'English') && (defined($placeofbaptism) and ($placeofmarriage eq $placeofbaptism))) {
						$phrase->append(' there ');

						if(my $address = $marriage->address()) {
							if($address eq 'Parish Church') {
								$phrase->append('at the Parish Church ');
							} elsif($address eq 'Registry Office') {
								$phrase->append('at the Registry Office ');
							} else {
								$phrase->append("at $address ");
							}
						}
					} else {
						$phrase->append(place({ person => $person, record => $marriage }))->append(' ');
					}
					$phrase->append(year(person => $person, string => $dateofmarriage, must_postdate => $birth_dt, must_predate => $death_dt));
				} else {
					$phrase->append(' ' . year(person => $person, string => $dateofmarriage, must_postdate => $birth_dt, must_predate => $death_dt, circa => 'around')) if($dateofmarriage);
					if($placeofmarriage) {
						my $args = {
							place => $placeofmarriage,
							person => $person,
							places_printed => \%places_printed
						};
						if($marriage && (my $address = $marriage->address())) {
							$args->{'address'} = $address;
						}
						my $p = place($args);
						$phrase->append($p);
						$places_printed{$p} = 1;
					} elsif(!$haveprintedspousename) {
						if((scalar(@phrases) == 0) && ($phrase->length() == 0)) {
							$phrase->set("$pronoun ");
						}

						$spouse //= $spouses[0];
						if(my $s = $spouse->as_string({ middle_names => 1, title => 1 })) {
							if(is_alive(person => $person) && is_alive(person => $spouse)) {
								$phrase->append(i18n({ person => $person, format => 'is married to ' }));
							} else {
								$phrase->append(i18n({ person => $person, format => 'was married to ' }));
							}
							$phrase->append($s);
						} else {
							complain({ person => $spouse, warning => 'Seems to have no name' });
						}
						$haveprintedspousename = 1;
					}
				}
				$phrase->append("[$marriagecitation]") if($marriagecitation);
				if(defined($marriage)) {
					append_notes({ phrase => $phrase, record => $marriage });
				}
			} else {	# scalar(@spouses) > 1
				if(is_alive(person => $person)) {
					$phrase->append('has been married');
				} elsif($language eq 'French') {
					$phrase->append("a \N{U+00E9}t\N{U+00E9} mari\N{U+00E9}");
					if($sex eq 'F') {
						$phrase->append('e');
					}
				} else {
					$phrase->append('was married');
				}
				$phrase->append(' ');
				if(scalar(@spouses) == 2) {
					if($spouses[0]->xref() eq $spouses[1]->xref()) {
						complain({ person => $person, warning => [ 'Married twice to ', $spouses[0]->as_string() ] });
					} else {
						$phrase->append(i18n('twice'));
					}
				} else {
					$phrase->append(scalar(@spouses) . i18n(' times'));
				}

				# Sort the order of the marriages by date
				my $all_marriages_have_date = 1;
				foreach my $spouse(@spouses) {
					if(!date_to_datetime(dateofmarriage($spouse))) {
						$all_marriages_have_date = 0;
						last;
					}
				}

				if($all_marriages_have_date) {
					@spouses = Sort::Key::DateTime::dtkeysort {
						my $date = dateofmarriage($_);
						die "BUG: can't find all marriage dates" if(!defined($date));
						date_to_datetime(date => $date);
					} @spouses;
					# Already cached
					# @spouses = map { Class::Simple::Readonly::Cached->new({ object => $_, cache => {} }) } @spouses;
				} elsif(scalar(@spouses) == 2) {
					# Married twice, even if we only know the years we can still sort
					my $date1 = dateofmarriage($spouses[0]);
					if(!defined($date1)) {
						if(my $mar = $spouses[0]->get_record('fams marriage')) {
							$date1 = $mar->date();
							if(!defined($date1)) {
								if($mar = $spouses[0]->get_record('marriage')) {
									$date1 = $mar->date();
								}
							}
						}
					}
					my $date2 = dateofmarriage($spouses[1]);
					if(!defined($date2)) {
						if(my $mar = $spouses[1]->get_record('fams marriage')) {
							$date2 = $mar->date();
							if(!defined($date2)) {
								if($mar = $spouses[1]->get_record('marriage')) {
									$date2 = $mar->date();
								}
							}
						}
					}

					if($date1 && $date2) {
						if($date1 ne $date2) {
							if($date1 =~ /.+(\d{4})$/) {
								my $year1 = $1;
								if($date2 =~ /.+(\d{4})$/) {
									my $year2 = $1;
									if($year2 < $year1) {
										# swap the spouses into marriage date order
										my $tmp = $spouses[0];
										$spouses[0] = $spouses[1];
										$spouses[1] = $tmp;
									}
								}
							}
						} else {
							complain({ person => $person, message => "Two marriages with the same date: $date1" });
						}
					}
				}

				my @names;
				my $spouse_number = 0;
				my $previousplace;
				foreach my $spouse(@spouses) {
					my $dateofmarriage = dateofmarriage({ person => $spouse });
					my $placeofmarriage = get_value({ person => $spouse, value => 'marriage place' });
					if(!defined($placeofmarriage)) {
						if(my $marriage = $spouse->get_record('marriage') || $spouse->get_record('fams marriage')) {
							$placeofmarriage = $marriage->place();
						}
					}
					if($placeofmarriage) {
						$placeofmarriage = undef if(lc($placeofmarriage) eq 'unknown');
					}
					my $name = $spouse->as_string();
					if($placeofmarriage) {
						$placeofmarriage = place({ person => $spouse, place => $placeofmarriage, places_printed => \%places_printed });
						if($previousplace && ($placeofmarriage eq $previousplace)) {
							if($placeofmarriage =~ /^(.+?),/) {
								$placeofmarriage = i18n({ person => $person, format => ' also%s', args => $1 });
							}
						} else {
							$previousplace = $placeofmarriage;
						}
					} elsif(!$dateofmarriage) {
						# FIXME: possibly not married, so above it shouldn't have said "married x times"
						$name .= ' (possibly not married to ';
						if($spouse->sex() eq 'M') {
							$name .= 'him)';
						} else {
							$name .= 'her)';
						}
						push @names, $name;
						next;
					}

					my $printed_bracket = 0;
					if($dateofmarriage && $placeofmarriage) {
						$name .= ' (' . year({ string => $dateofmarriage }) .
							$placeofmarriage;
						$printed_bracket = 1;
					} elsif($placeofmarriage) {
						$placeofmarriage =~ s/^\s+//;
						$name .= " ($placeofmarriage";
						$printed_bracket = 1;
					} elsif($dateofmarriage) {
						$name .= ' (' . year({ string => $dateofmarriage });
						$printed_bracket = 1;
					}
					$spouse_number++;
					if(defined($dateofmarriage) && (scalar(@spouses) == 2) && ($spouse_number == 2)) {
						my $death_of_first_spouse = dateofdeath($spouses[0]);
						if($death_of_first_spouse &&
						   (datecmp($dateofmarriage, $death_of_first_spouse) > 0)) {
							if($printed_bracket) {
								$name .= ', ';
							} else {
								$name .= '(';
								$printed_bracket = 1;
							}
							if($death_of_first_spouse =~ /\s$/) {
								complain({ person => $person, warning => 'Removing trailing spaces from date' });
								$death_of_first_spouse =~ s/\s+$//;
							}
							$name .= i18n('following the death of ') .
								$spouses[0]->given_names() . ' ' .
								year({
									person => $spouses[0],
									record => $death_of_first_spouse,
								});
						}
					}
					$name .= ')' if($printed_bracket);
					push @names, $name;
				}
				if(scalar(@names)) {
					$phrase->append(' (' . i18n('to ') . conjunction(@names) . ')');
				}
				$phrase->append("[$marriagecitation]") if($marriagecitation);

				# Determine if all the children are from one marriage, since that's
				# easier to print.
				# FIXME:  handle where offspring are from more than one marriage
				if($numberofchildren) {
					my %childrenbyspouse;
					my $childrenseen = 0;
					my $unknown;
					foreach my $family ($person->fams()) {
						if($family->number_of_children() &&
						   ($spouse = ($sex eq 'M') ? $family->wife() : $family->husband())) {
							foreach my $child($person->children()) {
								$unknown = $child;
								my $xref = $child->xref();
								foreach my $spouseschild($spouse->children()) {
									if($spouseschild->xref() eq $xref) {
										$childrenbyspouse{$spouse->xref()}++;
										$childrenseen++;
										$unknown = undef;
										last;
									}
								}
							}
						}
					}
					my $parentofall;
					if($childrenseen < $numberofchildren) {
						# Unable to find the parent of all of the children.  This
						# may be the case where someone married more than once,
						# and has a child by a 3rd unknown (or unfound) person
						if($opts{'w'}) {
							if(($numberofchildren - $childrenseen) == 1) {
								if($unknown) {
									complain({ person => $person, warning => 'One of the parents of ' . $unknown->as_string() . ' is not known'});
								} else {
									complain({ person => $person, warning => 'One of the parents of 1 child is not known'});
								}
							} else {
								complain({ person => $person, warning => 'One of the parents of ' . ($numberofchildren - $childrenseen) . ' children is not known'});
							}
						}
					} else {
						foreach my $spouse(@spouses) {
							if($parentofall && $childrenbyspouse{$spouse->xref()}) {
								$parentofall = undef;
								last;
							}
							if($childrenbyspouse{$spouse->xref()}) {
								$parentofall = $spouse;
							}
						}
					}

					if($phrase->length() > 0) {
						push @phrases, $phrase;
						$phrase = Data::Text->new();
					}

					if($language eq 'French') {
						$phrase->set($all_children_are_alive ? 'a ' : 'a eu ');
					} else {
						$phrase->set($all_children_are_alive ? 'has ' : 'had ');
					}
					if($numberofchildren == 1) {
						if($all_children_are_alive) {
							if($language eq 'French') {
								$phrase->append('1 surviving enfant');
							} else {
								$phrase->append('1 surviving child');
							}
						} elsif($language eq 'French') {
							$phrase->append('1 enfant');
						} else {
							$phrase->append('1 child');
						}
						if($childrenseen >= $numberofchildren) {
							if($parentofall) {
								$phrase->append([i18n(' with '), $parentofall]);
							} else {
								complain({ person => $person, warning => 'BUG: parentofall not set when only one child' });
							}
						} else {
							$phrase->append([' with an unknown ', i18n(($sex eq 'M') ? 'mother' : 'father')]);
						}
						# TODO: make hyperlink to the person's record, unless surviving
						if(my $given = given_names($children[0])) {
							$phrase->append(", $given");
						}
					} else {
						if($all_children_are_alive) {
							$phrase->append("$numberofchildren surviving children");
						} elsif($language eq 'French') {
							$phrase->append("$numberofchildren enfants");
						} else {
							$phrase->append("$numberofchildren children");
						}
						if($parentofall) {
							my $format;
							if($numberofchildren == 2) {
								$phrase->append(', ');
								$format = 'both with %s';
							} else {
								$format = ' with %s';
							}
							$phrase->append(i18n(person => $person, format => $format, args => $parentofall->as_string()));
							my $decoded = conjunction(map { $_->given_names() } @children);
							# utf8::decode($decoded);
							$decoded =~ s/Ã«/\N{U+00EB}/;
							$phrase->append(": $decoded");
						} else {
							# List children by the same parent together
							my %childmap;
							my $surviving_children;
							if($sex eq 'M') {
								foreach my $child(@children) {
									if($opts{'l'} || (!is_alive(person => $child)) || (defined($me) && ($child->xref() eq $me->xref()))) {
										if(my $mother = $child->mother()) {
											push @{$childmap{$mother->given_names()}}, $child;
										} else {
											push @{$childmap{'unknown mother'}}, $child;
										}
									} else {
										$surviving_children++;
									}
								}
							} else {
								foreach my $child(@children) {
									if($opts{'l'} || (!is_alive(person => $child)) || (defined($me) && ($child->xref() eq $me->xref()))) {
										if(my $father = $child->father()) {
											push @{$childmap{$father->given_names()}}, $child;
										} else {
											push @{$childmap{'unknown father'}}, $child;
										}
									} else {
										$surviving_children++;
									}
								}
							}

							my @childnames;
							while(my ($key, $value) = each %childmap) {
								push @childnames,
									conjunction(map { $_->given_names() } @{$value}) .
									i18n(' with ') .
									$key
							}
							if(scalar(@childnames)) {
								Lingua::Conjunction->separator_phrase(';');
								Lingua::Conjunction->penultimate(1);
								$phrase->append(': ' . conjunction(@childnames));
								# TODO: restore old values
								Lingua::Conjunction->separator_phrase(',');
								Lingua::Conjunction->penultimate(0);
							}

							if(defined($surviving_children)) {
								push @phrases, $phrase;
								$phrase = Data::Text->new();

								if($surviving_children == 1) {
									$phrase->set('one surviving child');
								} elsif($surviving_children > 1) {
									$phrase->set("$surviving_children surviving children");
								}
							}
						}
					}
				}
			}
			if($phrase->length()) {
				push @phrases, $phrase;
				$phrase = Data::Text->new();
			}
		} elsif($numberofchildren) {
			# Neither date nor place of marriage is known
			if($phrase->length()) {
				push @phrases, $phrase;
				$phrase = Data::Text->new();
			} elsif(scalar(@phrases) == 0) {
				$phrase->set("$pronoun ");
			}
			if(is_alive(person => $person)) {
				$phrase->append('has ');
			}
			$phrase->append(i18n('had '));

			if($language eq 'French') {
				$phrase->append((($numberofchildren == 1) ? '1 enfant' : "$numberofchildren enfants"));
			} else {
				$phrase->append((($numberofchildren == 1) ? '1 child' : "$numberofchildren children"));
			}
			if($numberofchildren == 1) {
				if(my $first_name = $children[0]->given_names()) {
					$first_name =~ s/\.$//;
					$phrase->append(", $first_name");
				}
			} else {
				# my $childnames = join(', ', map { $_->given_names() } @children);
				# substr($childnames, rindex($childnames, ', '), 2, ' and ');
				# $phrase->append(", $childnames");
				my $all_children_have_names = 1;
				foreach my $child(@children) {
					if(length($child->given_names()) == 0) {
						$all_children_have_names = 0;
						last;
					}
				}
				if($all_children_have_names) {
					$phrase->append(', ' . conjunction(map { given_names($_) } @children));
				}
			}
			if($phrase->length()) {
				push @phrases, $phrase;
				$phrase = Data::Text->new();
			}
		}

		if(scalar(@childrenunknownparent)) {
			push @phrases, $phrase;
			$bio->append(conjunction(map { $_->as_string() } @phrases))->append('.  ');
			$phrase = Data::Text->new("$pronoun ");
			@phrases = ();

			if(scalar(@children) > scalar(@childrenunknownparent)) {
				$phrase->append(i18n('also '));
			}
			$phrase->append(i18n('had ') . scalar(@childrenunknownparent) . ' ');
			if(scalar(@childrenunknownparent) == 1) {
				$phrase->append(i18n('child, '));
			} else {
				$phrase->append(i18n('children, '));
			}
			$phrase->append(conjunction(map { $_->given_names() } @childrenunknownparent) .
				', whose ' .
				(($sex eq 'F') ? 'father' : 'mother') .
				' is unknown');
		}

		if($same_occupation_as_father) {
			if($phrase->length()) {
				push @phrases, $phrase;
				$phrase = Data::Text->new();
			}
			if(scalar(@phrases)) {
				$bio->append(conjunction(map { $_->as_string() } @phrases))->append('.  ');
				$phrase = Data::Text->new();
				@phrases = ();
			}

			if($language eq 'French') {
				$phrase->set("Comme son p\N{U+00E8}re, " . lcfirst($pronoun) .
					(is_alive(person => $person) ? ' est' : " \N{U+00E9}tait") . ' un');
				if($same_occupation_as_father =~ /^[AEIOU]/) {
					$phrase->append('e');
				}
				$phrase->append(' ' . lc($same_occupation_as_father));
			} else {
				$phrase->set('Like ' . lcfirst($person->possessive()) . ' father, ' . lcfirst($pronoun) .
					i18n((is_alive(person => $person) ? ' is' : ' was')));
				$phrase->append(' ' . Lingua::EN::Inflect::A(lc($same_occupation_as_father)));
			}
			push @phrases, $phrase;
			$bio->append(conjunction(map { $_->as_string() } @phrases))->append('.  ');
			$phrase = Data::Text->new();
			@phrases = ();
		}

		my $printed_residence = 0;
		my %citationnotes;

		if($opts{'w'}) {
			my $index = 0;
			foreach my $event(@events) {
				$index++;
				if(!ref($event)) {
					my $e = $person->tag_record('EVEN', $index);
					if(ref($e) eq 'Gedcom::Record') {
						$event = $e;
					} else {
						red_warning({ person => $person, warning => "Event record is just description ($event), information has been lost" });
					}
				}
				if($event->can('type') || $event->isa('Class::Simple::Readonly::Cached')) {
					my $type = $event->type();
					if(!defined($type)) {
						red_warning({ person => $person, warning => "Can't determine type of event, or the event type is empty" });
						next;
					}
					print "Event type: $type\n" if($opts{'v'});

					# if(($type =~ /^Census U[KS] \d{4}$/) || ($type eq 'Register UK 1939')) {
					if(($type =~ /Census/) || ($type eq 'Register UK 1939')) {
						if(!$dateofbirth) {
							complain({ person => $person, warning => 'Census information not used to approximate a date of birth' });
						}
					}
				}
			}
		}

		my $diedathome;
		my $military_location;
		my $living_alone = 1;

		my @residences = get_all_residences($person);
		print scalar(@residences), " residences found\n" if($opts{'v'});

		if(scalar(@residences)) {
			# FIXME: handle duplicate locations better
			my @residencelist;
			my %residencecitations;

			if((scalar(@residences) == 1) && (scalar(@events) == 1) &&
			   $residences[0]->date() && ref($events[0]) && $events[0]->date() &&
			   (year(string => $residences[0]->date()) eq year(string => $events[0]->date())) &&
			   (($events[0]->type() eq 'Military service') || ($events[0]->type() eq 'Military'))) {
				# There's just one residence and one event which is military, and they are at the same time
				# so put them together: "in 1970 he was living in London when he was serving in the military"
				$military_location = 1;
			}

			# This is an attempt to handle
			# https://github.com/pjcj/Gedcom.pm/issues/13
			my $index = 0;
			foreach my $residence(@residences) {
				$index++;
				if(!ref($residence)) {
					my $r = $person->tag_record('EVEN', $index);
					if(ref($r) eq 'Gedcom::Record') {
						$residence = $r;
					} else {
						$r = $person->record(['residence', $index]);
						if(ref($r) eq 'Gedcom::Record') {
							$residence = $r;
						} else {
							red_warning({ person => $person, warning => "Residence record is just description ($residence), information has been lost" });
						}
					}
				}
				if(ref($residence) eq 'Gedcom::Record') {
					my $place = $residence->place();
					if(my $address = $residence->address()) {
						if(ref($address) eq 'Gedcom::Record') {
							$place = getaddress($address);
						} elsif($place) {
							$place = "$address, $place";
						} else {
							complain({
								person => $person,
								warning => "address set to $address but place is empty"
							});
						}
					}
					if(defined($place)) {
						if(my $dor = $residence->date()) {
							if($placeofbirth && $dateofbirth && ($dor eq $dateofbirth)) {
								next;
							}
							if($placeofmarriage && $dateofmarriage && ($dor eq $dateofmarriage)) {
								next;
							}
						}
						push @residencelist, $residence;
						if($opts{'c'}) {
							if(my $src = $residence->source()) {
								$src = get_source({ gedcom => $ged, person => $person, source => $src}) unless ref($src);
								my $note = notes(record => $residence);
								foreach my $c(@birthcitations) {
									if($src eq $citations{$c}) {
										$residencecitations{$residence} = $c;
										if($note) {
											$citationnotes{$c} = $note;
										}
										last;
									}
								}
								unless($residencecitations{$residence}) {
									if($deathcitations[0] && ($src eq $citations{$deathcitations[0]})) {
										$residencecitations{$residence} = $deathcitations[0];
										if($note) {
											$citationnotes{$deathcitations[0]} = $note;
										}
									} else {
										$residencecitations{$residence} = ++$citationcount;
										$citations{$citationcount} = $src;
										if($note) {
											$citationnotes{$citationcount} = $note;
										}
									}
								}
							} elsif(my $dor = $residence->date()) {
								red_warning({ person => $person, warning => "Residence record for $dor contains no citation" });
							}
						}
					} elsif(my $dor = $residence->date()) {
						if(my $type = $residence->type()) {
							if(($type ne 'Military service') &&
							   ($type ne 'Story')) {
								red_warning({ person => $person, warning => "Residence record for $dor contains no location" });
							}
						} else {
							red_warning({ person => $person, warning => 'Residence record contains no type' });
						}
					} else {
						red_warning({ person => $person, warning => 'Residence record contains no date' });
					}
				}
			}

			if(scalar(@residencelist) == 2) {
				print "Check if the residences are the same\n" if($opts{'v'});
				my $date1 = $residencelist[0]->date();
				my $date2 = $residencelist[1]->date();

				if($date1 && $date2 && ($date1 eq $date2)) {
					if(places_are_the_same({ person => $person, first => $residencelist[0], second => $residencelist[1] })) {
						complain({ person => $person, warning => "Duplicate residence on $date1" });
						@residencelist = ($residencelist[0]);
					}
				}
			}
			# TODO: See RT110333

			# Sort residences chronologically
			# FIXME: This messes citations
			my $all_residences_have_date = 1;
			foreach my $residence(@residencelist) {
				my $date = $residence->date();
				if(!$date) {
					complain({ person => $person, warning => 'Contains a residence' . place(record => $residence) . ' without a date' });
					$all_residences_have_date = 0;
					last;
				}
				$date = $date_parser->parse(date => $date);
				if(!defined($date)) {
					complain({ person => $person, warning => "Can't parse date '$date'" });
					$all_residences_have_date = 0;
					last;
				}
				if(scalar(@{$date}) == 0) {
					# e.g. "Apr/May/Jun 2016"
					$all_residences_have_date = 0;
					last;
				}
			}
			if($all_residences_have_date && (scalar(@residencelist) > 1)) {
				print "Sort the residences\n" if($opts{'v'});
				@residencelist = Sort::Key::DateTime::dtkeysort { $dfn->parse_datetime(@{$date_parser->parse(date => $_->date())}[0]->{'canonical'}) } @residencelist;
			}
			my $count = 0;
			my $prev_residence;
			my $spdeath_dt;
			if($spouses[0] && ($spdeath_dt = dateofdeath($spouses[0]))) {
				$spdeath_dt = date_to_datetime(date => $spdeath_dt);
			}
			my $print_year_only;	# used when printing a range, e.g. 1871-1891
			my %printed_dates;

			print "Sanity checking the residences\n" if($opts{'v'});

			# Create a list of residence strings
			my @residencestringarray;
			my $printed_father_same_place;
			my $printed_mother_same_place;

			my $iterator = Array::Iterator::BiDirectional->new({ __array__ => \@residencelist });
			while(my $residence = $iterator->get_next()) {
				my $rdate = $residence->date();
				my $residencestring;
				my $latitude;
				my $longitude;
				my %living_with;

				print __LINE__, ": count = $count\n" if($opts{'v'});

				if(defined($rdate)) {
					if($rdate =~ /^0/) {
						complain({ person => $person, warning => "Removing leading 0 from residence date '$rdate'" });
						# FIXME: Don't do this - it won't print this residence if you do
						# $rdate =~ s/^0//;
					}
					if($rdate =~ /^\s*(.+\d\d)\s*\-\s*(.+\d\d)\s*$/) {
						my $start = $1;
						my $end = $2;
						if($end !~ /^\d\d\-\d\d$/) {
							complain({ person => $person, warning => "Changing date '$rdate' to 'bet $start and $end'" });
							$rdate = "bet $start and $end";
						}
					}
				}

				if(($count == 0) || !places_are_the_same({ person => $person, first => $residence, second => $residencelist[$count - 1] })) {
					if($birth && $dateofbirth && $rdate && ($rdate eq $dateofbirth) &&
					   places_are_the_same({ person => $person, first => $birth, second => $residence})) {
						# This residence record is for the place of birth, which is
						# printed elsewhere
						$count++;
						next;
					}
					if($birth && places_are_the_same({ person => $person, first => $birth, second => $residence })) {
						$residencestring = i18n(' at ');
						if($language eq 'French') {
							$residencestring .= 'sa';
						} else {
							$residencestring .= ($person->pronoun() eq 'She') ? 'her' : 'his';
						}
						$residencestring .= i18n(' birthplace');
					} elsif(my $p = place({ person => $person, record => $residence, places_printed => \%places_printed })) {
						if($residence->type() && ($residence->type() eq 'Hospitalisation')) {
							$residencestring = ' in hospital';
						}

						if((!defined($prev_residence)) ||
						   !places_are_the_same({ person => $person, first => $prev_residence, second => $residence })) {
							# Actually prints the place here
							$residencestring .= $p;
							$places_printed{$p} = 1;
							$p = place({
								person => $person,
								record => $residence,
								nopreposition => 1,
							});
							if(my $location = get_location($p)) {
								$latitude = $location->lat();
								$longitude = $location->long();
							}
						}
					}
					if($rdate && (my $rdate_dt = date_to_datetime($rdate))) {
						my $year = $rdate_dt->year();
						my $strftime = $rdate_dt->strftime('%x');
						if(my $place = place({ person => $person, record => $residence, nopreposition => 1 })) {
							if(my $location = get_location($place)) {
								push @{$all_locations{$year}}, {
									'residence' => $residence,
									'person' => $person,
									'date' => $strftime,
									'latitude' => $location->lat(),
									'longitude' => $location->long()
								};
							}
						}
						if($opts{'w'} && $marriage_dt && ($rdate_dt > $marriage_dt)) {
							if(!defined($spouses[0])) {
								complain({ person => $person, warning => 'Has a date of marriage but no spouse' });
							} else {
								# Check this person was living at the same place as their spouse.
								# TODO: Also check all children under 10
								foreach my $l(@{$all_locations{$year}}) {
									if(($l->{'person'}->xref() eq $spouses[0]->xref()) &&
									   ($l->{'date'} eq $strftime)) {
										my $r1 = place(record => $residence, nopreposition => 1);
										my $r2 = place(record => $l->{'residence'}, nopreposition => 1);
										if($r1 ne $r2) {
											$r1 =~ s/^\s+//;
											$r2 =~ s/^\s+//;
											complain({
												person => $person,
												warning => [
													"$strftime: not living at same address as spouse ",
													$spouses[0]->as_string(),
													" ('$r1'/'$r2')"
												]
											});
										}
									}
								}
							}
						}
					}
				}
				if($rdate) {
					next if($printed_dates{$rdate});
					$printed_dates{$rdate}++;
					if($rdate =~ /(\d{3,4})$/) {
						if($opts{'w'}) {
							my $yoe = $1;
							if($yod) {
								if($yoe > $yod) {
									complain({
										person => $person,
										warning => "Year of residence $yoe is after the year of death $yod"
									});
								} elsif($death_dt && (my $rdate_dt = date_to_datetime($rdate))) {
									# FIXME: If $rdate is a date range, should check both dates in the range
									if($rdate_dt > $death_dt) {
										complain({
											person => $person,
											warning => "Date of residence $rdate is after date of death " . $death_dt->strftime('%x')
										});
									}
								}
							}
							# Check if spouse listed at all residences when we only know the year
							if($spouses[0]) {
								my $spyod = dateofdeath($spouses[0]) || ($yoe + 1);
								if($spyod =~ /(\d{3,4})$/) {
									$spyod = $1;
								}
								if(defined($dateofmarriage) &&
								   ($dateofmarriage =~ /(\d{3,4})$/) &&
								   (my $spouse = $spouses[0]) &&
								   ($yoe < $spyod)) {
									my $yom = $1;
									if($yom < $yoe) {
										my $found_spouse;
										foreach my $residence(get_all_residences($spouse)) {
											my $date = $residence->date();
											if(defined($date) && ($date =~ /(\d{3,4})$/)) {
												if($1 == $yoe) {
													$found_spouse = $residence;
													last;
												}
											}
										}
										if(!$found_spouse) {
											complain({ person => $person, warning => ["Listed in the residence for $rdate, but spouse ", $spouse->as_string(), ' is not'] });
										}
									}
								}
							}
							if($yob && (($yoe - $yob) <= 12)) {
								my $found_parent = 0;
								if($mother) {
									foreach my $m_residence(get_all_residences($mother)) {
										my $date = $m_residence->date();
										if(defined($date) && ($date =~ /(\d{3,4})$/)) {
											if($1 == $yoe) {
												$found_parent = $m_residence;
												my $p1 = place({
														person => $mother,
														record => $m_residence,
														nopreposition => 1
													});
												my $p2 = place({
														person => $person,
														record => $residence,
														nopreposition => 1
													});
												if($p1 ne $p2) {
													$p1 =~ s/^\s+//;
													$p2 =~ s/^\s+//;
													complain({ person => $person, warning => "Location for $date ($p2) differs from mother's ($p1)" });
												}
												if($date ne $rdate) {
													complain({ person => $person, warning => "Date of residence ($rdate) differs from mother's in same year ($date)" });
												}
												last;
											}
										}
									}
								}
								if($father && !$found_parent) {
									foreach my $f_residence(get_all_residences($father)) {
										my $date = $f_residence->date();
										if(defined($date) && ($date =~ /(\d{3,4})$/)) {
											if($1 == $yoe) {
												$found_parent = $f_residence;
												my $p1 = place({
														person => $father,
														record => $f_residence,
														nopreposition => 1
													});
												my $p2 = place({
														person => $person,
														record => $residence,
														nopreposition => 1
													});
												if($p1 ne $p2) {
													$p1 =~ s/^\s+//;
													$p2 =~ s/^\s+//;
													complain({ person => $person, warning => "Location for $date ($p2) differs from father's ($p1)" });
												}
												if($date ne $rdate) {
													complain({ person => $person, warning => "Date of residence ($rdate) differs from father's in same year ($date)" });
												}
												last;
											}
										}
									}
								}
								if((!$mother) && !$father) {
									# People not related by blood tend not to have been researched
									if($relationship) {
										complain({ person => $person, warning => 'Census information not used to determine a parent' });
									}
								}	# TODO: else warn if both parents locations are different
							} elsif($numberofchildren && ($rdate !~ /^bet\s/i) && ($rdate !~ /\d{4}, \d{4}/)) {
								# Look if a young child isn't with this parent
								foreach my $child(@children) {
									my $cyob = dateofbirth($child);
									next if(!defined($cyob));
									next if($cyob !~ /\d$/);	# Probably missing year e.g. "14 Jul"
									if($cyob =~ /(\d{3,4})\s*$/) {
										$cyob = $1;
									} else {
										# Probably missing year e.g. "14 Jul"
										next;
									}
									if($rdate !~ /^Bef/i) {
										next if(datecmp($cyob, $rdate) >= 0);	# Child was not born yet
									}
									next if(($yoe - $cyob) > 10);	# Over 10 years old
									if(my $cyod = dateofdeath($child)) {
										next if(datecmp($cyod, $rdate) <= 0);	# Child was dead by this event
									}

									if(!person_in_residence_record({ person => $child, date => $rdate })) {
										if($firstname) {
											complain({ person => $child, warning => "Parent $firstname is listed in the residence for $rdate, but this child is not" });
										} else {
											complain({ person => $child, warning => "Parent is listed in the residence for $rdate, but this child is not" });
										}
									}
								}
							}
						}
					}
					if(scalar(@residencelist) > 1) {
						# Add the dates to this residence place, as in "lived in this place on these dates"
						if($rdate =~ /\s$/) {
							complain({ person => $person, warning => "Removing trailing spaces from '$rdate'" });
							$rdate =~ s/\s+$//;
						}
						my $this_date = year({ person => $person, date => $rdate });
						if($prev_residence && (year(record => $prev_residence) eq $this_date)) {
							if(!places_are_the_same({ person => $person, first => $prev_residence, second => $residence })) {
								complain({ person => $person, warning => "Two residence records for $rdate differ in location" });
							}
						} else {
							if($print_year_only) {
								if($count == (scalar(@residencelist) - 1)) {
									$residencestring .= $rdate;
									# $print_year_only = 0;
								}
							} elsif((!defined($residencestring)) && (my $p = pop(@residencestringarray))) {
								if($language eq 'French') {
									$p =~ s/ et /, /g;
								} else {
									$p =~ s/ and /, /g;
								}
								$residencestring = conjunction($p, $this_date);
								# We could just added a comma after a sibling's name
								$residencestring =~ s/,,/,/g;
							} else {
								$residencestring .= " $this_date";
							}
							$prev_residence = $residence;
						}
					}
				}
				if($opts{'c'}) {
					if($residencecitations{$residence}) {
						my $remove_comma = 0;
						if($residencestring =~ s/,$//) {
							$remove_comma = 1;
						}
						$residencestring .= '[' . $residencecitations{$residence} . ']';
						if($remove_comma) {
							$residencestring .= ',';
						}
					}
					if($residence->place() &&
					  (!$rdate) &&
					  ($count <= (scalar(@residencelist) - 1)) &&
					  ($residencecitations{$residence})) {
						my $peek = $iterator->peek();
						if($peek && places_are_the_same({ person => $person, first => $residence, second => $peek })) {
							if($residencecitations{$peek}) {
								$residencestring .= '[' . $residencecitations{$peek} . ']';
							}
						}
					}
				} elsif($residence->source() && (my $notes = notes({ record => $residence }))) {
					$notes =~ s/\.$//;
					$notes =~ s/\xc3\xa9/\N{U+00E9}/g;
					$notes = lcfirst($notes);
					$residencestring .= " ($notes)";
				}
				$count++;
				if(($count == 1) && (scalar(@residencelist) == 2)) {
					if($print_year_only) {
						$residencestring .= $rdate;
						$print_year_only = 0;
					}
				} else {
					my $peek = $iterator->peek();
					if($peek && places_are_the_same({ person => $person, first => $residence, second => $peek })) {
						my $nextnotes = notes(record => $peek);
						$peek = $iterator->peek(2);
						if($peek && places_are_the_same({ person => $person, first => $residence, second => $peek })) {
							# FIXME: work with citations by printing them all
							if((!$opts{'c'}) && $rdate && ($rdate =~ /^\d{4}$/) && $peek->date() && ($peek->date() =~ /^\d{4}$/)) {
								if((!$print_year_only) && (!defined($nextnotes)) && !notes(record => $peek)) {
									$residencestring .= '-';
									$print_year_only = 1;
								}
							} elsif($print_year_only && $rdate) {
								$residencestring .= $rdate;
								$print_year_only = 0;
							}
						}
					} elsif($print_year_only) {
						$residencestring .= $rdate if((!defined($residencestring)) || ($rdate ne $residencestring));
						$print_year_only = 0;
					}
				}
				if($rdate) {	# residence has a date?
					my $bdiff;
					if($birth_dt) {
						$bdiff = $dfn->parse_datetime($rdate) - $birth_dt;
					}
					# Find if they are an adult living with an adult sibling or in-law
					if($all_residences_have_date && $birth_dt) {
						my $printed_sibling = 0;
						my $r = $residence;
						next if($r->date() ne $rdate);
						my $place = place({ person => $person, record => $r, nopreposition => 1 });
						next if(!defined($place));
						my $first = 1;
						my @siblings_living_with;

						foreach my $sibling(@siblings) {
							if(my $ss = $sibling->spouse()) {
								next if($bdiff->in_units('years') < 20);
								# If they are living with an in-law, assume both are adults
								$ss = Class::Simple::Readonly::Cached->new({ object => $ss, cache => {}, quiet => 1 });
								my @ssr = get_all_residences(person => $ss);
								foreach my $ssr(@ssr) {
									if(my $d = $ssr->date()) {
										next if($d ne $rdate);

										# Compare only if full addresses to prevent
										# false positives when only a city is known
										if(($place =~ /^\s\d/ && (my $ssp = place({ person => $ss, record => $ssr, nopreposition => 1 })))) {
											if($ssp eq $place) {
												if($ss->sex() eq 'F') {
													$living_with{'sister-in-law'} = $ss
												} else {
													$living_with{'brother-in-law'} = $ss
												}
												$printed_sibling = 1;
												last;
											}
										}
									}
								}
							}
							next if($bdiff->in_units('years') < 40);
							# Safe to assume both are adults at this time
							my @sr = get_all_residences(person => $sibling);
							foreach my $sr(@sr) {
								my $sdate = $sr->date();
								next if(!defined($sdate));
								next if($sdate ne $rdate);
								if(($place =~ /^\s\d/) && (place({ person => $sibling, record => $sr, nopreposition => 1 }) eq $place)) {
									push @siblings_living_with, $sibling;
									last;
								}
							}
						}
						if(scalar(@siblings_living_with)) {
							# Print out all the siblings this person was living with
							# as an adult
							$living_with{'siblings'} = \@siblings_living_with;
							if($first) {
								$residencestring .= ' (' .
									i18n('when ') .
									i18n(($sex eq 'M') ? 'he' : 'she') .
									i18n(' was living') .
									i18n(' with ') .
									($sex eq 'M' ? 'his' : 'her');
								$first = 0;
							} else {
								$residencestring =~ s/^\s//;
							}
							if(scalar(@siblings_living_with) == 1) {
								$residencestring .=
									i18n(($sex eq 'F') ? ' sister, ' : ' brother, ') .
									$siblings_living_with[0]->given_names() . ',';
							} else {
								my $sex = $siblings_living_with[0]->sex();
								foreach my $sibling(@siblings_living_with) {
									if($sibling->sex() ne $sex) {
										undef $sex;
										last;
									}
								}
								if($sex) {
									# living with more than one sibling all of the same gender
									$residencestring .= i18n(($sex eq 'F') ? ' sisters, ' : ' brothers, ') .
										conjunction(map { $_->given_names() } @siblings_living_with);
								} elsif(scalar(@siblings_living_with) == 2) {
									# Living with one brother and one sister
									my $brother;
									my $sister;
									if($siblings_living_with[0]->sex() eq 'M') {
										$brother = $siblings_living_with[0];
										$sister = $siblings_living_with[1];
									} else {
										$sister = $siblings_living_with[0];
										$brother = $siblings_living_with[1];
									}
									$residencestring .= i18n(' brother ') .
										$brother->given_names() .
										i18n(' and ') .
										i18n('sister ') .
										$sister->given_names();
								} else {
									die 'TODO: ', $person->as_string(include_years => 1), ' living with ', scalar(@siblings_living_with), ' siblings of differing genders';
								}
							}
							if($first) {
								$residencestring .= ')';
								$first = 0;
							}
							$printed_sibling = 1;
						}
						# if(($bdiff->in_units('years') >= 30) || ($bdiff->in_units('years') < 16)) {
						if(1) {
							my $with_mother;
							my $same_road_as_mother = 0;
							my $address = $residence->address();
							my $road = $address;

							if($road) {
								if($road =~ /,\s*(.+)/) {
									$road = $1;
								}
								if($road =~ /^\d*\s(.+)/) {
									$road = $1;
								}
							}
							my $mother_date;
							if($mother) {
								my @mr = get_all_residences(person => $mother);
								foreach my $mr(@mr) {
									my $mdate = $mr->date();
									next if(!defined($mdate));

									my $p = place({ person => $mother, record => $mr, nopreposition => 1 });
									next unless($p);

									if(($rdate eq $mdate) && $road && ($mr->place() eq $residence->place())) {
										if($p eq $place) {
											$living_with{'mother'} = $mother;
											last;
										} elsif(my $mroad = $mr->address()) {
											if($mroad eq $address) {
												$living_with{'mother'} = $mother;
											}
											if($mroad =~ /,\s*(.+)/) {
												$mroad = $1;
											}
											if($mroad =~ /^\d*\s(.+)/) {
												$mroad = $1;
											}
											if($mroad eq $road) {
												$same_road_as_mother = $rdate;
											}
										}
									} elsif($p eq $place) {
										# if(($p =~ /^\s\d/) && ($p eq $place)) {
										if($mdate eq $rdate) {
											$with_mother++;
											$living_alone = 0;
											last;
										} elsif(!$printed_mother_same_place) {
											$mother_date = $mdate;
										}
									}
								}
								if($with_mother && !$living_with{'mother'}) {
									complain({ person => $person, warning => "May have been living with mother on $rdate, but the addresses don't match or aren't detailed enough to be sure" });
								}
							}
							my $with_father;
							my $same_road_as_father = 0;
							my $father_date;
							if($father) {
								my @fr = get_all_residences(person => $father);
								foreach my $fr(@fr) {
									my $fdate = $fr->date();
									next if(!defined($fdate));

									my $p = place({ person => $father, record => $fr, nopreposition => 1 });
									next unless($p);

									if(($rdate eq $fdate) && $road && ($fr->place() eq $residence->place())) {
										if($p eq $place) {
											$living_with{'father'} = $father;
											last;
										} elsif(my $froad = $fr->address()) {
											if($froad eq $address) {
												$living_with{'father'} = $father;
											}
											if($froad =~ /,\s*(.+)/) {
												$froad = $1;
											}
											if($froad =~ /^\d*\s(.+)/) {
												$froad = $1;
											}
											if($froad eq $road) {
												$same_road_as_father = $rdate;
											}
										}
									} elsif($p eq $place) {
										# if(($p =~ /^\s\d/) && ($p eq $place)) {
										if($fdate eq $rdate) {
											$with_father++;
											$living_alone = 0;
											last;
										} elsif(!$printed_father_same_place) {
											$father_date = $fdate;
										}
									}
								}
								if($with_father && !$living_with{'father'}) {
									complain({ person => $person, warning => "May have been living with father on $rdate, but the addresses don't match or aren't detailed enough to be sure" });
								}
							}
							if($living_with{'mother'} || $living_with{'father'}) {
								if($bdiff->in_units('years') >= 30) {
									$residencestring .= ' ';
									if($first) {
										$residencestring .= '(' .
											i18n('when ') .
											i18n(($sex eq 'M') ? 'he' : 'she') . i18n(' was living');
									}
									if($language eq 'French') {
										$residencestring =~ s/lorsque elle/lorsqu'elle/;
									}
									if($first) {
										if($language eq 'French') {
											$residencestring .= ($printed_sibling ? ' et ' : ' avec ');
											if($with_mother && $with_father) {
												$residencestring .= 'ses';
											} elsif($with_mother) {
												$residencestring .= 'sa';
											} else {
												$residencestring .= 'son';
											}
										} else {
											$residencestring .= i18n($printed_sibling ? ' and ' : ' with ') .
												($sex eq 'M' ? 'his' : 'her');
										}
									} else {
										$residencestring =~ s/,$//;
										$residencestring .= i18n(' and');
									}
									$printed_sibling = 1;

									if($with_mother && $with_father) {
										$residencestring .= i18n(' parents');
									} elsif($with_mother) {
										$residencestring .= i18n(' mother, ') . $mother->given_names();
									} elsif($with_father) {
										$residencestring .= i18n(' father, ') . $father->given_names();
									}
									if($first) {
										$residencestring .= ')';
										$first = 0;
									} else {
										$residencestring .= ' ';
									}
								}
							} elsif(($same_road_as_mother || $same_road_as_father) && !$printed_sibling) {
								if($bdiff->in_units('years') >= 30) {
									$residencestring .= ' on the same road as ' .
												($person->pronoun() eq 'She' ? 'her' : 'his');
									$printed_sibling = 1;
									$first = 0;

									my @r;
									if($same_road_as_mother && $same_road_as_father) {
										$residencestring .= i18n(' parents');
										@r = get_all_residences(person => $father);
									} elsif($same_road_as_mother) {
										$residencestring .= i18n(' mother');
										@r = get_all_residences(person => $mother);
									} else {
										$residencestring .= i18n(' father');
										@r = get_all_residences(person => $father);
									}
									foreach my $r(@r) {
										if(($r->date() eq $rdate) && $r->address()) {
											if($same_road_as_mother && $same_road_as_father) {
												$residencestring .= ' who were';
											} else {
												$residencestring .= ' who was';
											}
											$residencestring .= ' living at ' . $r->address();
											last;
										}
									}
								}
							} elsif(($mother || $father) && ($bdiff->in_units('years') < 16)) {
								if(!($with_mother || $with_father)) {
									complain({ person => $person, warning => [ "$rdate: Not living with either parent in childhood when aged ", $bdiff->in_units('years') ] });
								}
								$living_alone = 0;
							} elsif($father_date && (datecmp($rdate, $father_date) >= 0)) {
								# FIXME: This test never succeeds,
								#	perhaps Array:Iterator:BiDirectional doesn't work as I expect?
								#	https://rt.cpan.org/Ticket/Display.html?id=143344&results=af04c74d05626a62cf0c32f2953f3e4f
								# if(my $prev_residence = $iterator->look_back()) {
									# my $pdate = $prev_residence->date();
									# if(datecmp($pdate, $father_date) == 0) {
										# die 'TODO: ', $person->as_string(include_years => 1), " change text to 'the same place as $pronoun was living with $pronoun father in $pdate'\n\t$residencestring";
									# }
									# die 'Unexpected test pass: ', $person->as_string, " $pdate/$father_date";
								# } else {
									$residencestring .= ' (the same place as ' .
										($person->pronoun() eq 'She' ? 'her' : 'his');
									if($mother_date && (datecmp($father_date, $mother_date) == 0)) {
										$residencestring .= i18n(' parents ');
										$printed_mother_same_place = 1;
									} else {
										$residencestring .= i18n(' father ');
									}
									if(datecmp($rdate, $father_date) > 0) {
										$residencestring .= 'had been';
									} elsif($printed_mother_same_place) {
										$residencestring .= 'were';
									} else {
										$residencestring .= 'was';
									}
									$residencestring .= ' living ' .
										year({ person => $person, string => $father_date }) .
										')';
								# }
								$printed_father_same_place = 1;
							} elsif($mother_date && (datecmp($rdate, $mother_date) >= 0)) {
								$residencestring .= ' (the same place as ' .
									($person->pronoun() eq 'She' ? 'her' : 'his') . i18n(' mother ');
								if(datecmp($rdate, $mother_date) > 0) {
									$residencestring .= 'had been';
								} else {
									$residencestring .= 'was';
								}
								$residencestring .= ' living ' .
									year({ person => $person, string => $mother_date }) .
									')';
								$printed_mother_same_place = 1;
							}
						}
						if($spouse && $marriage_dt && (my $rdate_dt = date_to_datetime($rdate))) {
							if($marriage_dt > $rdate_dt) {
								my @sr = get_all_residences(person => $spouse);
								foreach my $sr(@sr) {
									my $sdate = $sr->date();
									next if(!defined($sdate));
									next if($sdate ne $rdate);
									if(place({ person => $spouse, record => $sr, nopreposition => 1 }) eq $place) {
										if($language eq 'French') {
											$residencestring .= ($printed_sibling ? ' et ' : ' avec ') .
												($person->pronoun() eq 'She' ? 'son futur mari, ' : 'sa futur femme, ') .
												$spouse->given_names();
										} else {
											$residencestring .= i18n($printed_sibling ? ' and ' : ' with ') .
												($person->pronoun() eq 'She' ? 'her future husband, ' : 'his future wife, ') .
												$spouse->given_names();
										}
										last;
									}
								}
							}
						}
					}
					if(defined($latitude) && defined($bdiff) &&
					  (my $dt = date_to_datetime($rdate))) {
						# Print close relatives living close by
						# This really only works when printing a lot of people, for example with the -a
						#	flag, or when producing a PDF book, since it relies on having found data
						#	on people beforehand
						my $year = $dt->year();
						my $printed_person = 0;
						my $gis = GIS::Distance->new('MathTrig');
						my $p2 = place({ record => $residence, nopreposition => 1 });
						my @people_near_p2;
						my $p3;	# previous place

						my @sorted_locations = sort { $a->{'latitude'} <=> $b->{'latitude'} } @{$all_locations{$year}};

						# $Data::Dumper::Maxdepth = 2;
						# print Data::Dumper->new([\@sorted_locations])->Dump();

						my $iterator = Array::Iterator->new({ __array__ => \@sorted_locations });
						while(my $l = $iterator->get_next()) {
							# print Data::Dumper->new([$l])->Dump();
							if(($l->{'person'}->xref() ne $person->xref()) &&
							   (($spouses[0] && ($l->{'person'}->xref() eq $spouses[0]->xref())) ||
							   (my $relationship = $person->relationship($l->{'person'})) &&
							    ((stepsabove($l->{'person'}, $person, 0) <= 3) &&
							     (stepsabove($person, $l->{'person'}, 0) <= 3)))) {
								my $p1 = place({ record => $l->{'residence'}, nopreposition => 1 });
								# This stops verbosity when the list is:
								#	high street, 33 high street, high street
								next unless($p1 =~ /^\s?\d/);

								my $peek = $iterator->peek();
								next if($peek && ($peek->{'person'}->xref() eq $l->{'person'}->xref()));

								my $close_relative;
								my $distance = $gis->distance($l->{'latitude'}, $l->{'longitude'}, $latitude, $longitude);
								# print "p1: $p1\n\tp2 $p2\n";
								# print "\t", $distance->yards(), '/', $distance->miles(), "\n";

								if($p1 eq $p2) {
									$close_relative = 1;
								} elsif(($l->{'latitude'} == $latitude) && ($l->{'longitude'} == $longitude)) {
									complain({
										person => $person,
										warning => [ $l->{'person'}->as_string(nee => 1), " residence is same location probably should be recorded as the same address ('$p1'/'$p2') in $year" ]
									});
									$close_relative = 1;
								} elsif($distance->miles() < 1) {
									if($distance->yards() < 20) {
										complain({
											person => $person,
											warning => [ $l->{'person'}->as_string(nee => 1), " residence is very close probably should be recorded as the same address ('$p1'/'$p2') in $year" ]
										});
									}
									$close_relative = 1;
								}
								if($close_relative) {
									# Add this relative to the list of close people, unless they are
									#	already in the list
									# p1 is the place of the relative we're considering ($l)
									# p2 is the place of the current person
									# p3 is the place of the previous relative we're considering
									if($p3 && $peek && (place({ record => $peek->{'residence'}, nopreposition => 1 }) eq $p3)) {
										if((!defined($people_near_p2[0])) || ($people_near_p2[0]->{'person'}->xref() ne $l->{'person'}->xref())) {
											push @people_near_p2, $l;
										}
										next;
									}
									$p3 = $p1;
									my $first_string;
									my $future_spouse;
									if($spouses[0] && ($l->{'person'}->xref() eq $spouses[0]->xref())) {
										if(defined($dateofmarriage) && ($dateofmarriage =~ /(\d{3,4})$/)) {
											if($year < $1) {
												$future_spouse = 1;
											}
										} elsif($bdiff->in_units('years') < 16) {
											$future_spouse = 1;
										}
									}
									if($future_spouse) {
										# FIXME: Only when before they married, though when
										#	they are married it should be the same place, right?
										if($language eq 'French') {
											$first_string = (($sex eq 'M') ? 'sa futur femme ' : 'son futur mari ');
										} else {
											$first_string = (($sex eq 'M') ? 'his future wife ' : 'her future husband ');
										}
									} else {
										next unless($relationship);
										if($bdiff->in_units('years') < 21) {
											if(my $mother = $person->mother()) {
												if($l->{'person'}->xref() eq $mother->xref()) {
													next;
												}
											}
											if(my $father = $person->father()) {
												if($l->{'person'}->xref() eq $father->xref()) {
													next;
												}
											}
										}
										$first_string = ($sex eq 'M' ? 'his' : 'her') .
											" $relationship ";
									}
									if($l->{'person'}->surname() eq $lastname) {
										$first_string .= $l->{'person'}->given_names();
									} else {
										$first_string .= $l->{'person'}->as_string();
									}
									my @people_living_together = ($first_string);
									if(scalar(@people_near_p2)) {
										while(my $p = pop(@people_near_p2)) {
											if(my $r = $person->relationship($p->{'person'})) {
												push @people_living_together, "$r " .
													$p->{'person'}->as_string();
											}
										}
									}
									if($printed_person) {
										$residencestring .= ', ';
									} else {
										$residencestring .= ' - less than a mile from ';
									}
									$residencestring .= conjunction(@people_living_together);

									if(scalar(@people_living_together) > 1) {
										if($language eq 'French') {
											$residencestring .= ' qui habitaient';
										} else {
											$residencestring .= ' who were living';
										}
									} else {
										if($language eq 'French') {
											$residencestring .= ' qui habitait';
										} else {
											$residencestring .= ' who was living';
										}
									}

									$Data::Dumper::Maxdepth = 2;
									print STDERR Data::Dumper->new([$l])->Dump() if($opts{'v'});
									$residencestring .= place({ record => $l->{'residence'}, there => $p2, places_printed => \%places_printed });
									$residencestring .= ' -' if($printed_person);
									$printed_person = 1;
								}
							}
						}
					}
					if($spdeath_dt && (my $rdate_dt = date_to_datetime($rdate))) {
						if($rdate_dt > $spdeath_dt) {
							# Living with a child following death of spouse?
							CHILD: foreach my $child(@children) {
								my @cevents = $child->event();
								my $index = 0;
								EVENT: foreach my $event(@cevents) {
									$index++;
									if(!ref($event)) {
										my $e = $child->tag_record('EVEN', $index);
										if(ref($e) eq 'Gedcom::Record') {
											$event = $e;
										} else {
											# red_warning({ person => $child, warning => "Event record is just description ($event), information has been lost" });
											next EVENT;
										}
									}
									my $type = $event->type();

									# if(($type !~ /^Census U[KS] \d{4}$/) && ($type ne 'Register UK 1939')) {
									if(($type !~ /Census/) && ($type ne 'Register UK 1939')) {
										next EVENT;
									}
									if($opts{'v'} && $event->date() && ($event->date() eq $rdate)) {
										print __LINE__, ">> check if living with children\n",
										print "\t$type, ", ref($event), "\n",
										"\t", $event->date(), " $rdate ", $residence->address(), "\n";
									}
									if((ref($event) eq 'Gedcom::Record') &&
									   $event->date() && ($event->date() eq $rdate) &&
									   $residence->address() &&
									   places_are_the_same({ person => $child, first => $residence, second => $event, exact => 1 })) {
										if($child->sex() eq 'F') {
											push @{$living_with{'daughters'}}, $child;
											$spdeath_dt = undef;
										} else {
											push @{$living_with{'sons'}}, $child;
											$spdeath_dt = undef;
										}
										last CHILD;
									}
								}
							}
							if($spdeath_dt) {
								# Outlived spouse, but not living with a child
								my $date = dateofdeath($spouses[0]);
								if($date =~ /\s$/) {
									complain({ person => $person, warning => 'Removing trailing spaces from date of marriage' });
									$date =~ s/\s+$//;
								}
								$residencestring .= i18n(' following the death of ') .
									($person->pronoun() eq 'She' ? 'her' : 'his') .
									(($sex eq 'M') ? ' wife ' : ' husband ') .
									year(date => $date);
								$spdeath_dt = undef;
							}
						}
					}
				}
				if($residencestring) {
					$residencestring =~ s/^\s//;
					if($language eq 'French') {
						$residencestring =~ s/(.+), (his|her) /$1 et $2 /;
					} else {
						$residencestring =~ s/(.+), (his|her) /$1 and $2 /;
					}
					if(scalar(keys %living_with)) {
						if($opts{'w'}) {
							$Data::Dumper::Maxdepth = 2;
							print STDERR __LINE__, ": TODO ($rdate): ", Data::Dumper->new([\%living_with])->Dump();
						}
						if($living_with{'daughters'}) {
							# TODO: more than one daughter
							my @daughters = @{$living_with{'daughters'}};
							$residencestring .= i18n('when ') .
								lcfirst(i18n($person->pronoun())) .
								' was living with ' .
								lcfirst($person->possessive()) .
								i18n((scalar(@daughters) > 1) ? ' daughters, ' : ' daughter ') .
								conjunction(map { $_->given_names() } @daughters) . ',' .
								i18n(' following the death of ') .
								(($sex eq 'M') ? 'his wife ' : 'her husband ') .
								year(date => dateofdeath($spouses[0]));
							delete $living_with{'daughters'};
						}
						if(my $in_law = $living_with{'brother-in-law'}) {
							# TODO: brothers-in-law
							$residencestring .= i18n(' when ') .
								lcfirst(i18n($person->pronoun())) .
								' was living with ' .
								lcfirst($person->possessive()) .
								i18n(' brother-in-law, ') .
								$in_law->as_string();
							delete $living_with{'brother-in-law'};
						}
						$living_alone = 0;
					}
					$residencestring =~ s/\sand$//;
					$residencestring =~ s/,$//;
					print __LINE__, ": adding '$residencestring' to residencestringarray\n" if($opts{'v'});
					push @residencestringarray, $residencestring;
					$printed_residence = 1;
				}
			}

			# Print out the residence strings with semi-colons between each residence
			if(scalar(@residencestringarray)) {
				push @phrases, $phrase if($phrase->rtrim()->length());
				if(scalar(@phrases)) {
					my $text = conjunction(map { $_->as_string() } @phrases);
					if(!defined($text)) {
						die $person->as_string({ include_years => 1 }), ': BUG: residencestring array is unexpectedly empty';
					}
					$text =~ s/[\,;]\s*$//;
					$text =~ s/\s\-;/;/g;
					$bio->append("$text.  ");
					$phrase = Data::Text->new();
					@phrases = ();
				}

				my $first = $residencelist[0];
				if((scalar(@residencelist) == 1) && (my $rdate = $first->date())) {
					$phrase->set(ucfirst(year({ person => $person, date => $rdate, circa => 'About' })));
				} else {
					if($opts{'B'}) {
						if($bio->length() &&
						  (!pdfprint(string => $bio, text => $text, pdfpage => $pdfpage))) {
							$text->textend();

							$pdfpage = NJH::PDFPage->new($pdf);

							$text = $pdfpage->text();
							$text->font($params{'font'}, 12);
							pdfprint(string => $bio, text => $text, pdfpage => $pdfpage);
						}
						$bio = Data::Text->new(' ');
					} else {
						$bio->rtrim()->append("\n\t");
					}
					$phrase->set(ucfirst(i18n('during %s life', lc($person->possessive()))));
				}

				print __LINE__, ': residencestringarray: ', Data::Dumper->new([\@residencestringarray])->Dump() if($opts{'v'});

				# Because peek above only looks ahead one element:
				# [
					  # 'at Shuart Cottage, Podden Street, St Nicholas-at-Wade on Apr 5, 1891 (was age 0 and the son of the head of the household; was age 0 and the son of the head of the household)',
					  # 'at Cottage, Nash Court, Garlinge, Kent on Mar 31, 1901 (was age 10, the son of the head of the household) and on Apr 2, 1911 (was age 20 and the son of the head of the household)',
					  # 'at 1 Hill View Cottages, Twenties, Shottendane Road, Margate, Kent in 1915-',
					  # '1923, in 1929 and on Sep 29, 1939 (was the head of the household)'
				# ];
				foreach my $i(0..(scalar(@residencestringarray) - 2)) {
					if($residencestringarray[$i+1] =~ /^\d/) {
						$residencestringarray[$i+1] =~ s/^\d{4}, in //g;
						$residencestringarray[$i] .= $residencestringarray[$i+1];
						$residencestringarray[$i+1] = undef;
					}
				}
				while(!defined($residencestringarray[scalar(@residencestringarray) - 1])) {
					pop @residencestringarray;
				}
				# $phrase->append(', ' . lcfirst($pronoun) . i18n(' was living ') .
					# Lingua::EN::Inflect::WORDLIST(@residencestringarray, {sep => '; ', conj => i18n('and')});
				my $s;
				if(is_alive($person) && !$first->date()) {
					$s = 'has lived';
				} else {
					$s = 'was living';
				}

				print Data::Dumper->new([\@residencestringarray])->Dump() if($opts{'v'});
				Lingua::Conjunction->separator_phrase(';');
				Lingua::Conjunction->penultimate(1);
				$phrase->append(', ' . lcfirst($pronoun) . i18n(" $s ") . conjunction(@residencestringarray));
				Lingua::Conjunction->separator_phrase(',');
				Lingua::Conjunction->penultimate(0);

				if($placeofdeath && !$aod) {
					my $lastresidence = $residencelist[scalar(@residencelist) - 1];
					my $deathplace = place({ person => $person, record => $death });
					my $lastdate = $lastresidence->date();
					$lastresidence = place({ person => $person, record => $lastresidence });
					if(defined($lastdate) && defined($lastresidence) && ($deathplace eq $lastresidence)) {
						my $p = lcfirst($pronoun);
						if($language eq 'French') {
							$phrase->append(" c'est o\N{U+00F9} $p est mort");
							if($sex eq 'F') {
								$phrase->append('e');
							}
						} else {
							$phrase->append(" which is where $p died");
						}
						if($dateofdeath) {
							my $date = year({ person => $person, date => $dateofdeath, must_postdate => $birth_dt });
							$lastdate =~ s/^.*(\d{4})$/$1/;
							$date =~ /, (\d{3,4})$/;
							if($lastdate == $yod) {
								$date =~ s/, (\d{3,4})$//;
							}
							$phrase->append(" $date");
						}
						$phrase->append("[$_]") foreach(List::Util::uniq(sort @deathcitations));
						add_death_notes({ person => $person, record => $death, phrase => $phrase });
						$diedathome = 1;
					}
				}
				if(!$military_location) {
					if($phrase->length()) {
						push @phrases, $phrase;
					}
					$bio->append(conjunction(map { $_->as_string() } @phrases))->append('.  ');
					@phrases = ();
					$phrase = Data::Text->new();
				}
			}
		} else {	# scalar(@residences) == 0
			if(scalar(@phrases)) {
				if($phrase->length()) {
					push @phrases, $phrase;
					$phrase = Data::Text->new();
				}
				# No residences - remove any trailing commas
				my $text = conjunction(map { $_->as_string() } @phrases);
				$text =~ s/[\,;]\s*$//;
				$bio->append("$text.  ");
				@phrases = ();
			}
		}
		# FIXME - these start and end dates for censuses should depend on countries
		if($living_alone && $yob && $yod && (($yod - $yob) > 10) && ($yob >= 1842) && ($yob <= 1920)) {
			# Age at death > 10 years - should have at least appeared on one census
			complain({ person => $person, warning => 'No records of living with anyone' });
		}
		# $phrase =~ s/,;/;/g;
		# $phrase =~ s/;$//;
		# $phrase =~ s/,.$/./;

		# Sort the events by date
		if(all_records_have_date({ person => $person, records => \@events }) && (scalar(@events) > 0)) {
			@events = Sort::Key::DateTime::dtkeysort { $dfn->parse_datetime(@{$date_parser->parse(date => $_->date())}[0]->{'canonical'}) } @events;
		}

		# Let's remove things that aren't relevant that may
		# allow optimisations in the English
		# while(scalar(@events) > 2) {
			# my $e = $events[scalar(@events) - 1];
			# # TODO: add more
			# if(ref($e) && ($e->type() eq 'Register UK 1939')) {
				# pop @events;
			# } else {
				# last;
			# }
		# }

		my $funeral;

		if((scalar(@events) == 2) &&
		   (ref($events[0]) eq 'Gedcom::Record') &&
		   (ref($events[1]) eq 'Gedcom::Record') &&
		   ((($events[0]->type() eq 'Arrival') && ($events[1]->type() eq 'Departure')) ||
		    (($events[1]->type() eq 'Arrival') && ($events[0]->type() eq 'Departure')))) {
			if($phrase->rtrim()->length() > 0) {
				push @phrases, $phrase;
			}
			if(scalar(@phrases)) {
				$bio->append(conjunction(map { $_->as_string() } @phrases))->append('.  ');
				$phrase = Data::Text->new();
				@phrases = ();
			}

			my $arrival = ($events[0]->type() eq 'Arrival') ? $events[0] : $events[1];
			my $departure = ($events[0]->type() eq 'Departure') ? $events[0] : $events[1];
			if($events[0]->type() ne $events[1]->type()) {
				# Simple case - one journey made
				$bio->append(journey({ person => $person, arrival => $arrival, departure => $departure, spouses => \@spouses, children => \@children }))
					->append('.  ');
			} else {
				my $date1 = year(record => $events[0]);
				my $date2 = year(record => $events[1]);
				my $year1;
				my $year2;
				if($date1 =~ /(.*)\s?(\d{4})$/) {
					$date1 = $1;
					$year1 = $2;
					$date1 =~ s/,\s//;
				}
				if($date2 =~ /(.*)\s?(\d{4})$/) {
					$date2 = $1;
					$year2 = $2;
					$date2 =~ s/,\s//;
				}
				if($year1 == $year2) {
					my $motion;
					if($events[0]->type() eq 'Arrival') {
						$motion = 'arrived';
					} else {
						$motion = 'departed';
					}
					$phrase->set("During $year1 " . lcfirst($pronoun) . i18n(" $motion") .
						place({ person => $person, record => $events[0] }) .
						"$date1 and" .
						place({ person => $person, record => $events[1], nopreposition => 1 }) .
						" $date2. ");
				} else {
					die 'TODO';
				}
				if($phrase->length()) {
					push @phrases, $phrase;
					$phrase = Data::Text->new();
				}
			}
		} elsif(scalar(@events) == 1) {
			if($phrase->length() && !$military_location) {
				push @phrases, $phrase;
				$phrase = Data::Text->new();
			}

			my $event = $person->event();
			if(!ref($event)) {
				my $e = $person->tag_record('EVEN');
				if(ref($e) eq 'Gedcom::Record') {
					$event = $e;
				} else {
					red_warning({ person => $person, warning => "Event record is just description ($event), information has been lost" });
					$phrase->append(' ' . ucfirst($event));
					push @phrases, $phrase;
					$bio->append(conjunction(map { $_->as_string() } @phrases))->append('.  ');
					$phrase = Data::Text->new();
					@phrases = ();
				}
			}
			if($event->can('type') || $event->isa('Class::Simple::Readonly::Cached')) {
				my $type = $event->type();
				if(!defined($type)) {
					red_warning({ person => $person, warning => "Can't determine type of event, or the event type is empty" });
				} elsif($type eq 'Arrival') {
					if((scalar(@phrases) == 0) && ($phrase->length() == 0)) {
						$phrase->set($pronoun);
					} else {
						$phrase->append(lcfirst($pronoun));
					}
					$phrase->append(i18n({ person => $person, format => ' arrived' }));
					if(my $p = place({ person => $person, record => $events[0] })) {
						$phrase->append($p);
					} else {
						complain({ person => $person, warning => 'Arrival record has no place' });
					}
					if(my $y = year({ person => $person, record => $events[0] })) {
						$phrase->append(" $y");
					} else {
						complain({ person => $person, warning => 'Arrival record has no date' });
					}
					if(my $spouse = $spouses[0]) {
						foreach my $sevent($spouse->event()) {
							if(ref($sevent) eq 'Gedcom::Record') {
								my $stype = $sevent->type();
								if(!defined($stype)) {
									red_warning({ person => $spouse, warning => "Can't determine type of event, or the event type is empty" });
								} elsif($sevent->place() && ($stype eq 'Arrival') &&
								   $event->date() && $sevent->date() &&
								   ($event->date() eq $sevent->date()) &&
								   ($event->place() eq $sevent->place())) {
									$phrase->append(i18n(' with ') .
										lcfirst($person->possessive()) . ' ' .
										(($sex eq 'M') ? 'wife' : 'husband') .
										' ' . $spouse->given_names());
								}
							}
						}
					}
					append_notes({ phrase => $phrase, record => $event });

					push @phrases, $phrase;
					$bio->append(conjunction(map { $_->as_string() } @phrases))->append('.  ');
					$phrase = Data::Text->new();
					@phrases = ();
					if(!defined($event->address())) {
						complain({ person => $person, warning => 'Date is known but not location in arrival record' });
					}
				} elsif($type eq 'Departure') {
					$phrase->append(" $pronoun");
					if($ENV{'LANG'} =~ /^en_US/) {
						$phrase->append(' traveled');
					} else {
						$phrase->append(' travelled');
					}
					my $place = place({ person => $person, record => $events[0] });
					if($language eq 'German') {
						$place =~ s/^\sin/ von/;
					} else {
						$place =~ s/^\sin/ from/;
					}
					$phrase->append("$place " .
						year({ person => $person, record => $events[0] }));
					append_notes({ phrase => $phrase, record => $event });
					push @phrases, $phrase;
					$bio->append(conjunction(map { $_->as_string() } @phrases))->append('.  ');
					$phrase = Data::Text->new();
					@phrases = ();
				} elsif(($type eq 'Military service') || ($type eq 'Military')) {
					my $date = year(record => $event);
					if($military_location) {
						$phrase->append(' when ')->append(lcfirst($pronoun))->append(' was serving in the military');
					} elsif($date) {
						if($date =~ /^from /i) {
							$phrase->append("$pronoun was serving in the military");
						} else {
							$phrase->append(ucfirst($date) . ' ' . lcfirst($pronoun) . ' was serving in the military');
						}
					} else {
						$phrase->append("$pronoun served in the military");
					}
					if(my $place = place({ person => $person, record => $event })) {
						$phrase->append($place);
					}
					if($date && ($date =~ /^from /i)) {
						$phrase->append(" $date");
					}

					if(append_notes({ phrase => $phrase, record => $event })) {
						push @phrases, $phrase;
						$bio->append(conjunction(map { $_->as_string() } @phrases))->append('.  ');
						$phrase = Data::Text->new();
						@phrases = ();
					}
				} elsif($type eq 'Newspaper') {
					if($phrase->length()) {
						push @phrases, $phrase;
						$phrase = Data::Text->new();
					}
					if(scalar(@phrases) == 0) {
						$phrase->set($firstname // $pronoun)->append(' ');
					}
					my $newspaper = newspaper({ gedcom => $ged, person => $person, event => $event });
					$phrase->append('appeared in a newspaper');
					if(my $date = $newspaper->date()) {
						$phrase->append(" on $date");
					}
					my $url = $newspaper->url();
					$phrase->append(" ($url)");

					# die $i->page();
				} elsif($type eq 'Funeral') {
					$funeral = $event;
				# } elsif(($type !~ /^Census U[KS] \d{4}$/) &&
				} elsif(($type !~ /Census/) &&
					($type ne 'Race') &&
					($type ne 'Custom Marriage') &&
					($type ne 'Email') &&
					($type ne 'Register UK 1939')) {

					red_warning({ person => $person, warning => "Unhandled event type: $type" });
					append_notes({ phrase => $phrase, record => $event });
				# } elsif($end_of_sentence) {
					# $phrase->append(' ');
				}
			}
		} elsif(scalar(@events) > 0) {
			my $mentioned_military;
			my $index = 0;
			my $previous;
			my $prev_type;
			foreach my $event(@events) {
				$index++;
				if(!ref($event)) {
					my $e = $person->tag_record('EVEN', $index);
					if(ref($e) eq 'Gedcom::Record') {
						$event = $e;
					} else {
						red_warning({ person => $person, warning => "Event record is just description ($event), information has been lost" });
						$phrase->append(' ' . ucfirst($event) . '. ');
					}
				}
				if(ref($event) eq 'Gedcom::Record') {
					my $type = $event->type();
					print "Event type: $type\n" if($opts{'v'});
					if($type eq 'Military service') {
						if(!$mentioned_military) {
							my $service = 'military';
							if(my $notes = notes(record => $event)) {
								if($notes =~ /Navy/i) {
									$service = 'navy';
								} elsif(($notes =~ /^army\.?$/i) || ($notes =~ /\sarmy\s/i) || ($notes =~ /\sregiment/i) || ($notes =~ /soldier/i)) {
									$service = 'army';
								}
							}
							if(defined(my $date = year(record => $event))) {
								if($date =~ /^from /) {
									if($firstname) {
										$phrase->set("\n\t$firstname served in the $service $date");
									} else {
										$phrase->set("\n\t$pronoun served in the $service $date");
									}
								} else {
									if($date =~ /^on /) {
										$phrase->set(ucfirst($date));
									} elsif($date =~ /^in (\d{4})/) {
										$phrase->set("During $1,");
									} elsif($date =~ /(.+)\-(.+)/) {
										$phrase->set("Between $1 and $2");
									} else {
										$phrase->set(ucfirst($date));
									}
									$phrase->append(' ' . lcfirst($pronoun) . " was serving in the $service");
								}
							} else {
								$phrase->set("$pronoun served in the $service");
							}

							if(my $place = place({ person => $person, record => $event, allow_empty => 1 })) {
								$phrase->append($place);
							}
							$mentioned_military = 1;
						}

						append_notes({ phrase => $phrase, record => $event });
						push @phrases, $phrase;
						$phrase = Data::Text->new();
					} elsif($type eq 'Arrival') {
						if(!defined($event->place())) {
							complain({ person => $person, warning => 'Arrival record without destination' });
							next;
						}
						if(my $e = $events[$index]) {
							if(ref($e) && ($e->type() eq 'Departure') && $event->date() && $e->date()) {
								$previous = $event;
								$prev_type = $event->type();
								# FIXME: not all locations will be noted or notes printed
								next;
							}
						}
						if($previous) {
							if($prev_type eq 'Departure') {
								if($phrase->length()) {
									push @phrases, $phrase;
									$phrase = Data::Text->new();
								}
								$phrase->set(journey({ person => $person, arrival => $event, departure => $previous }));
							} else {
								# Two arrival records, put into one sentence for improved readability
								my $date1 = year({ record => $previous });
								my $date2 = year({ record => $event });
								my $year1;
								my $year2;
								if($date1 =~ /(.*)\s?(\d{4})$/) {
									$date1 = $1;
									$year1 = $2;
									$date1 =~ s/,\s//;
								}
								if($date2 =~ /(.*)\s?(\d{4})$/) {
									$date2 = $1;
									$year2 = $2;
									$date2 =~ s/,\s//;
								}
								push @phrases, $phrase;
								$bio->append(conjunction(map { $_->as_string() } @phrases))->append('.  ');
								$phrase = Data::Text->new();
								@phrases = ();
								if(defined($year1) && defined($year2) && ($year1 == $year2)) {
									if($date1 eq 'in ') {
										$date1 = '';
									} else {
										$date1 = " $date1";
									}
									$phrase->set("During $year1 " . lcfirst($pronoun) . ' arrived' .
										place({ person => $person, record => $previous }) .
										"$date1 and" .
										place({ person => $person, record => $event, nopreposition => 1 }) .
										" $date2");
								} else {
									$phrase->set(ucfirst(year({ person => $person, record => $previous })) .
										' ' . lcfirst($person->pronoun()) .
										' arrived' .
										place({ person => $person, record => $previous }) .
										' and ' .
										year({ person => $person, record => $event }) .
										' ' . lcfirst($pronoun) .
										' arrived' .
										place({ person => $person, record => $event }));
								}
							}
							$previous = undef;
						} elsif(my $place = place({ person => $person, record => $event })) {
							if(my $year = year({ person => $person, record => $event })) {
								if($place =~ /,/) {
									if($phrase->length()) {
										push @phrases, $phrase;
										$phrase = Data::Text->new();
									} elsif(scalar(@phrases) == 0) {
										$year = ucfirst($year);
									}
									$phrase->set($year);
									append_notes({ phrase => $phrase, record => $event });
									$phrase->append(' ' . lcfirst($pronoun) . ' ');
									if($language eq 'French') {
										$phrase->append("est arriv\N{U+00E9}");
										if($sex eq 'F') {
											$phrase->append('e');
										}
										$place =~ s/^ in//;
										$phrase->append($place);
									} else {
										$phrase->append("arrived$place");
									}
								} else {	# Arriving in a country
									$phrase->append("$pronoun ");
									if($language eq 'French') {
										$phrase->append("est arriv\N{U+00E9}");
										if($sex eq 'F') {
											$phrase->append('e');
										}
										$phrase->append(" \N{U+00E0}");
										$place =~ s/^ in//;
										$phrase->append($place);
									} else {
										$phrase->append("arrived$place");
									}
									$phrase->append(" $year");
									append_notes({ phrase => $phrase, record => $event });
								}
							} else {
								complain({ person => $person, warning => "Can't determine $type date" });

								$phrase->append("arrived$place");
							}
						} else {
							complain({ person => $person, warning => "Can't determine $type location" });
						}
						if(defined($phrase) && ($phrase->length() > 0)) {
							push @phrases, $phrase;
							$bio->append(conjunction(map { $_->as_string() } @phrases))->append('.  ');
							$phrase = Data::Text->new();
							@phrases = ();
						}
					} elsif($type eq 'Departure') {
						if(!defined($event->place())) {
							complain({ person => $person, warning => 'Departure record without destination' });
							next;
						}
						if(my $e = $events[$index]) {
							if(ref($e) && ($e->type() eq 'Arrival') && $event->date() && $e->date()) {
								$previous = $event;
								$prev_type = $event->type();
								# FIXME: not all locations will be noted or notes printed
								next;
							}
						}
						if($previous) {
							if($prev_type eq 'Arrival') {
								$phrase->append(journey({ person => $person, arrival => $previous, departure => $event }));
							}
							$previous = undef;
						} else {
							$phrase->append(ucfirst(i18n($person->pronoun())));
							if($ENV{'LANG'} =~ /^en_US/) {
								$phrase->append(' traveled');
							} elsif($language eq 'French') {
								$phrase->append(" a voyag\N{U+00E9}");
							} else {
								$phrase->append(' travelled');
							}
							my $place = place({ person => $person, record => $event });
							if($language eq 'German') {
								$place =~ s/^\sin/ von/;
							} else {
								$place =~ s/^\sin/ from/;
							}
							if($event->date()) {
								$phrase->append("$place " .
									year({ person => $person, record => $event }));
							} else {
								$phrase->append($place);
							}
							append_notes({ phrase => $phrase, record => $event });
						}
						push @phrases, $phrase;
						$bio->append(conjunction(map { $_->as_string() } @phrases))->append('.  ');
						$phrase = Data::Text->new();
						@phrases = ();
					} elsif($type eq 'Story') {
						if(my $notes = notes(record => $event)) {
							if($phrase->length() > 0) {
								push @phrases, $phrase;
								$bio->append(conjunction(map { $_->as_string() } @phrases))->append('.  ');
								$phrase = Data::Text->new();
								@phrases = ();
							}

							$notes =~ s/\.$//;
							# TODO:  Do this if the notes doesn't include a date
							# if(my $date = year(record => $event)) {
								# $phrase->set(ucfirst($notes) . " $date. ");
							# } else {
								$phrase->set(ucfirst($notes));
							# }
						}
					} elsif($type eq 'Court') {
						if($phrase->length() > 0) {
							push @phrases, $phrase;
							$phrase = Data::Text->new();
						} else {
							$phrase->set("$pronoun ");
						}
						if($language eq 'French') {
							$phrase->append("a \N{U+00E9}t\N{U+00E9} au tribunal");
						} else {
							$phrase->append('appeared in court');
						}
						if(my $place = place({ person => $person, record => $event, allow_empty => 1 })) {
							$phrase->append($place);
						}
						if(my $date = year(record => $event)) {
							$phrase->append(" $date");
						}
						if(my $notes = notes(record => $event)) {
							$notes = lcfirst($notes);
							$notes =~ s/\.$//;
							$phrase->append(" ($notes)");

							push @phrases, $phrase;
							$phrase = Data::Text->new();
						}
					} elsif($type eq 'Employment') {
						if(my $notes = notes(record => $event)) {
							if($phrase->length()) {
								push @phrases, $phrase;
								$phrase = Data::Text->new();
							}
							$notes =~ s/\.$//;
							if(my $date = year(record => $event)) {
								if(scalar(@phrases) == 0) {
									$date = ucfirst($date);
								}
								$phrase->append("$date " . lcfirst($pronoun) . ' was working');
							} else {
								$phrase->set("$pronoun worked");
							}
							$phrase->append(" at $notes");
							if(my $place = place(person => $person, record => $event)) {
								$phrase->append($place);
							}
							push @phrases, $phrase;
							$phrase = Data::Text->new();
						}
					} elsif($type eq 'Newspaper') {
						# FIMXE: duplicate code with one event
						# This is a non-standard thing that FMP has evented.
						if($phrase->length()) {
							push @phrases, $phrase;
							$phrase = Data::Text->new();
						}
						if(scalar(@phrases) == 0) {
							$phrase->set($firstname // $pronoun)->append(' ');
						}
						if((!defined($prev_type)) || ($prev_type ne 'Newspaper')) {
							$phrase->append('appeared ');
						}
						my $newspaper = newspaper({ gedcom => $ged, person => $person, event => $event });
						$phrase->append('in ' . $newspaper->title());
						if(my $date = $newspaper->date()) {
							$phrase->append(" on $date");
						}
						if(my $page = $newspaper->page()) {
							$phrase->append(" on page $page");
						}
						if(my $url = $newspaper->url()) {
							$phrase->append(" ($url)");
						}
						push @phrases, $phrase;
						$phrase = Data::Text->new();

						$previous = $event;
						$prev_type = 'Newspaper';
					# } elsif(($type !~ /^Census U[KS] \d{4}$/) &&
					} elsif($type eq 'Funeral') {
						$funeral = $event;
					} elsif(($type !~ /Census/) &&
						($type ne 'Register UK 1939') &&
						($type ne 'Race') &&
						($type ne 'Race') &&
						($type ne 'Hospitalisation')) {
						red_warning({ person => $person, warning => "Unknown event type: $type" });
						if(my $notes = notes(record => $event)) {
							$notes =~ s/\.$//;
							my $date = year(record => $event);
							if($phrase->length()) {
								$notes = lcfirst($notes);
								if($date) {
									$phrase->append(" ($date, $notes)");
								} else {
									$phrase->append(" ($notes)");
								}
							} else {
								if($date) {
									$phrase->append(ucfirst($notes) . " $date");
								} else {
									$phrase->append(ucfirst($notes));
								}
							}
						}
					}
				}
			}

			# End of events, put them all into one sentence
			if(scalar(@phrases) > 0) {
				if($phrase->rtrim()->length() > 0) {
					push @phrases, $phrase;
				}
				$bio->append(conjunction(map { $_->as_string() } @phrases))->append('.  ');
				$phrase = Data::Text->new();
				@phrases = ();
			}
		}

		if(my $profile_object = $person->tag_record('_MILT')) {
			# Ancestry does this, FMP stores military records as events
			# $person->resolve_xref($profile_object->value());
			if(my $value = $profile_object->get_value()) {
				$value =~ s/[\s\.]+$//;
				if($phrase->length()) {
					push @phrases, $phrase;
					$phrase = Data::Text->new();
				}
				if(scalar(@phrases)) {
					$bio->append(conjunction(map { $_->as_string() } @phrases))->append('.  ');
					@phrases = ();
				}
				$bio->append("$pronoun served in the military ($value).  ");
			}
		}

		if($funeral && (!defined($dateofburial)) && (!defined($dateofcremation))) {
			complain({ person => $person, warning => 'Taking details of burial from funeral record' });
			$dateofburial = $funeral->date();
			$placeofburial = $funeral->place();
		}

		if($placeofburial || $dateofburial || $placeofcremation || $dateofcremation) {
			if(defined($dateofdeath) && (!defined($dateofburial)) && (!defined($dateofcremation))) {
				complain({ person => $person, warning => "Adding date of burial as 'aft $dateofdeath'" });
				if($placeofburial) {
					$dateofburial = "aft $dateofdeath";
				} else {
					$dateofcremation = "aft $dateofdeath";
				}
			}
			my $type = 'burial';
			if($placeofcremation || $dateofcremation) {
				$type = 'cremation';
			}
			if($aod || ((!$dateofdeath) && !$placeofdeath)) {
				if($phrase->length() > 0) {
					push @phrases, $phrase;
					$phrase = Data::Text->new();
				}

				my $record;
				if($dateofburial || $dateofcremation) {
					if((scalar(@phrases) == 0) && ($phrase->length() == 0)) {
						$phrase->set(text => [ "\n\t", $firstname // $pronoun ]);
					}
					$phrase->append(($type eq 'burial') ? i18n({ person => $person, format => ' was buried' }) : ' was cremated');
					# Neither burial nor cremation could be set if we guessed information from the funeral
					if(($burial || $cremation) && (my $city = ($placeofburial // $placeofcremation))) {
						if($placeofbirth && places_are_the_same(first => $city, second => $placeofbirth)) {
							if($burial) {
								if(my $address = $burial->address()) {
									$phrase->append(" at $address");
								}
							} elsif(my $address = $cremation->address()) {
								$phrase->append(" at $address");
							}
							$phrase->append(' in ' .
								lcfirst($person->possessive()) .
								' home town of ');
							if($city =~ /^(.+?),/) {
								$phrase->append($1);
							} else {
								$phrase->append(place({
									person => $person,
									place => $city
								}));
							}
						} else {
							my $opts = {
								person => $person,
								there => $placeofdeath,
								places_printed => \%places_printed,
								must_postdate => $birth_dt
							};
							if($type eq 'burial') {
								# Funeral record, but no burial or cremation
								$record = $burial;
								$opts->{'place'} = $placeofburial;
							} else {
								$opts->{'place'} = $placeofcremation;
								$record = $cremation;
							}
							if($record && (my $address = $record->address())) {
								$opts->{'address'} = $address;
							}
							$phrase->append(place($opts));
						}
					}
					if($type eq 'burial') {
						$phrase->append(' ' . year({ person => $person, date => $dateofburial }));
						$record = $burial;
					} else {
						$phrase->append(' ' . year({ person => $person, date => $dateofcremation }));
						$record = $cremation;
					}
					if(defined($record)) {
						if($funeral && (datecmp($funeral->date(), $record->date()) == 0) && (my $place = place({ person => $person, record => $funeral }))) {
							if(my $weather = weather({ person => $person, record => $funeral, meteo => $meteo })) {
								$phrase->append(" ($weather)");
							}
							$phrase->append(' following ' .
								($person->pronoun() eq 'She' ? 'her' : 'his') .
								i18n(' funeral') .
								$place);
						} elsif($place = place({ person => $person, record => $record, nopreposition => 1 })) {
							if(my $weather = weather({ person => $person, record => $record, meteo => $meteo })) {
								$phrase->append(" ($weather)");
							}
						}
					} elsif(my $weather = weather({ person => $person, record => $funeral, meteo => $meteo })) {
						# Funeral record, but no burial or cremation
						$phrase->append(" ($weather)");
					}
					if($record && (my $n = notes({ record => $record, paragraph => 0 }))) {
						$n =~ s/\.$//;
						$n =~ tr/\r//;
						$phrase->append(" ($n)");

						push @phrases, $phrase;
						$bio->append(conjunction(map { $_->as_string() } @phrases))->append('. ');
						$phrase = Data::Text->new();
						@phrases = ();
					}
				} elsif($placeofbirth && places_are_the_same(first => $placeofburial, second => $placeofbirth)) {
					$phrase->append($pronoun)->append(i18n({ person => $person, format => ' was buried' }));
					if(my $address = $burial->address()) {
						if($language eq 'French') {
							$phrase->append(" \N{U+00E0} $address");
						} else {
							$phrase->append(" at $address");
						}
					}
					$phrase->append(' in ' . lcfirst($person->possessive()) .
						' home town of ');
					my $city = $placeofburial;
					if($city =~ /^(.+?),/) {
						$phrase->append($1);
					} else {
						$phrase->append(place({ person => $person, place => $placeofburial }));
					}
				} else {
					if($phrase->length() > 0) {
						push @phrases, $phrase;
						$phrase = Data::Text->new();
					} elsif(scalar(@phrases) == 0) {
						$phrase->set("$pronoun ");
					}

					$phrase->append(
						i18n({ person => $person, format => 'is buried' }) .
						place({ person => $person, record => $burial, places_printed => \%places_printed, there => $placeofmarriage })
					);
				}
			} elsif($dateofdeath || $placeofdeath) {
				if(!$diedathome) {
					if(!$placeofburial) {
						if($phrase->length() && scalar(@phrases)) {
							$bio->append(conjunction(map { $_->as_string() } @phrases))->append('.  ');
							$phrase = Data::Text->new();
							@phrases = ();
						}
						if($opts{'B'}) {
							if($bio->length()) {
								if(!pdfprint(string => $bio, text => $text, pdfpage => $pdfpage)) {
									$text->textend();

									$pdfpage = NJH::PDFPage->new($pdf);

									$text = $pdfpage->text();
									$text->font($params{'font'}, 12);
									pdfprint(string => $bio, text => $text, pdfpage => $pdfpage);
								}
								$bio = Data::Text->new();
							}
						} else {
							$phrase->append("\n\t");
						}
					} elsif($phrase->length() > 0) {
						push @phrases, $phrase;
						$phrase = Data::Text->new();
					}

					if(scalar(@phrases) == 0) {
						$phrase->append("$pronoun ");
					}

					$phrase->append(i18n({ person => $person, format => 'died' }));

					if($dateofdeath) {
						if($dateofdeath =~ /\s$/) {
							complain({ person => $person, warning => 'Removing trailing spaces from date of death' });
							$dateofdeath =~ s/\s+$//;
						}
						$phrase->append([
							' ',
							between(year({ person => $person, date => $dateofdeath, must_postdate => $birth_dt }))
						]);
					}
					if($placeofdeath && (my $p = place({ person => $person, record => $death, places_printed => \%places_printed }))) {
						$phrase->append($p);
						$places_printed{$p} = 1;
						if($dateofdeath && ($p =~ /\s\d+\s/)) {
							foreach my $child(@children) {
								my @cr = get_all_residences(person => $child);
								foreach my $cr(@cr) {
									if(my $d = $cr->date()) {
										next if($d ne $dateofdeath);

										# Compare only if full addresses to prevent
										# false positives when only a city is known
										if(($p =~ /^\s\d/) && (my $cp = place({ person => $child, record => $cr }))) {
											if($cp eq $p) {
												$phrase->append(i18n(' when ') . ($person->pronoun() eq 'She' ? 'her' : 'his') .
													' was living with ' . ($person->pronoun() eq 'She' ? 'her ' : 'his ') .
													i18n('child ') . $child->as_string());
												last;
											}
										}
									}
								}
							}
							# FIXME: handle when living with both parents
							if($father) {
								my @fr = get_all_residences(person => $father);
								foreach my $fr(@fr) {
									if(my $d = $fr->date()) {
										next if($d ne $dateofdeath);

										# Compare only if full addresses to prevent
										# false positives when only a city is known
										if(($p =~ /^\s\d/) && (my $fp = place({ person => $father, record => $fr }))) {
											if($fp eq $p) {
												$phrase->append(i18n(' when ') . ($person->pronoun() eq 'She' ? 'her' : 'his') .
													' was living with ' . ($person->pronoun() eq 'She' ? 'her ' : 'his ') .
													i18n('father ') . $father->as_string());
												last;
											}
										}
									}
								}
							}
							if($mother) {
								my @mr = get_all_residences(person => $mother);
								foreach my $mr(@mr) {
									if(my $d = $mr->date()) {
										next if($d ne $dateofdeath);

										# Compare only if full addresses to prevent
										# false positives when only a city is known
										if(($p =~ /^\s\d/) && (my $mp = place({ person => $mother, record => $mr }))) {
											if($mp eq $p) {
												$phrase->append(i18n(' when ') . ($person->pronoun() eq 'She' ? 'her' : 'his') .
													' was living with ' . ($person->pronoun() eq 'She' ? 'her ' : 'his ') .
													i18n('mother ') . $mother->as_string());
												last;
											}
										}
									}
								}
							}
							foreach my $sibling(@siblings) {
								my @sr = get_all_residences(person => $sibling);
								foreach my $sr(@sr) {
									if(my $d = $sr->date()) {
										next if($d ne $dateofdeath);

										# Compare only if full addresses to prevent
										# false positives when only a city is known
										if(($p =~ /^\s\d/) && (my $sp = place({ person => $sibling, record => $sr }))) {
											if($sp eq $p) {
												$phrase->append(i18n(' when ') . ($person->pronoun() eq 'She' ? 'her' : 'his') .
													' was living with ' . ($person->pronoun() eq 'She' ? 'her ' : 'his ') .
													i18n(($sibling->sex() eq 'F') ? 'sister, ' : 'brother, ') .
													$sibling->as_string());
												last;
											}
										}
									}
								}
							}
						}
					}
					$phrase->append("[$_]") foreach(List::Util::uniq(sort @deathcitations));

					add_death_notes({ person => $person, record => $death, phrase => $phrase });
				}
				my $opts = {
					person => $person,
					place => $placeofburial // $placeofcremation,
					there => $placeofdeath,
					places_printed => \%places_printed,
					must_postdate => $birth_dt
				};
				my $address;
				if($address = get_value({ person => $person, value => 'burial address' })) {
					$opts->{'address'} = $address;
				}
				if($dateofburial) {
					if($phrase->length() > 0) {
						push @phrases, $phrase;
						$phrase = Data::Text->new();
					}
					if(scalar(@phrases) == 0) {
						$phrase->set(text => [$firstname // $pronoun, ' ']);
					}

					if(($language eq 'French') && $placeofburial &&
					  defined($placeofdeath) && ($placeofburial eq $placeofdeath) && (!$address) && !$death->address()) {
						$phrase->append('y ');
					}
					$phrase->append(i18n({ person => $person, format => 'was buried' }));
					if($placeofburial) {
						if(defined($placeofdeath) && ($placeofburial eq $placeofdeath) && !$death->address()) {
							$phrase->append(' there') if($language ne 'French');
							if($address) {
								if($language eq 'French') {
									$phrase->append(" \N{U+00E0} $address");
								} else {
									$phrase->append(" at $address");
								}
							}
						} else {
							$phrase->append(place($opts));
						}
					}
					my $must_postdate;
					if($death_dt) {
						$must_postdate = $death_dt;
					} elsif(!defined($dateofdeath)) {
						complain({
							person => $person,
							warning => 'Date of burial is known but not of death, suggest adding "Abt. YEAR"'
						});
					} elsif($dateofdeath =~ /^(Abt|ca?)\.?\s*(.+)/i) {
						my $d = $2;
						if($d !~ /^\d/) {
							$must_postdate = date_to_datetime("1 $d");
						} else {
							$must_postdate = date_to_datetime($d);
						}
					}
					if($dateofburial =~ /\s$/) {
						complain({ person => $person, warning => "Removing trailing spaces from date of burial '$dateofburial'" });
						$dateofburial =~ s/\s+$//;
					}
					if($dateofburial =~ /\.$/) {
						complain({ person => $person, warning => "Removing trailing fullstop from date of burial '$dateofburial'" });
						$dateofburial =~ s/\.+$//;
					}
					$phrase->append(' ' . year({ person => $person, date => $dateofburial, must_postdate => $must_postdate }));
					if($burial && $placeofburial && (my $weather = weather({ person => $person, record => $burial, meteo => $meteo }))) {
						$phrase->append(" ($weather)");
					}
					if($funeral && (datecmp($dateofburial, $funeral->date()) == 0) && (my $place = place({ person => $person, record => $funeral }))) {
						$phrase->append(' following ' .
							($person->pronoun() eq 'She' ? 'her' : 'his') .
							i18n(' funeral') .
							$place);
					}
				} elsif($placeofdeath && $placeofburial && ($placeofburial eq $placeofdeath) &&
				   $burial->address() && !$death->address()) {
					push @phrases, $phrase;
					$phrase = Data::Text->new();
					if($language eq 'French') {
						$phrase->set("y enterr\N{U+00E9}");
						if($sex eq 'F') {
							$phrase->append('e');
						}
						$phrase->append("\N{U+00E0} " . $burial->address());
					} else {
						$phrase->set('is buried there at ' . $burial->address());
					}
				} elsif(my $b = place($opts)) {
					if($diedathome) {
						$phrase->append("$pronoun ");
					} else {
						push @phrases, $phrase;
						$phrase = Data::Text->new();
					}
					my $weather;
					if($type eq 'burial') {
						if($dateofburial) {
							$phrase->append(i18n({ person => $person, format => 'was buried' }));
						} else {
							$phrase->append(i18n({ person => $person, format => 'is buried' }));
						}
						if($b eq ' there') {
							if($b = $burial->address()) {
								$phrase->append(i18n(' at '))->append($b);
							}
							$phrase->append(' ');
						} else {
							$phrase->append("$b ");
						}
						if($dateofburial) {
							$phrase->append(year({ person => $person, date => $dateofburial }));
						}
						$weather = weather({ person => $person, record => $burial, meteo => $meteo });
					} else {
						$phrase->append('was cremated');
						if($b eq ' there') {
							if($b = $cremation->address()) {
								$phrase->append(i18n(' at '))->append($b);
							}
							$phrase->append(' ');
						} else {
							$phrase->append("$b ");
						}
						if($dateofcremation) {
							$phrase->append(year({ person => $person, date => $dateofcremation }));
						}
						$weather = weather({ person => $person, record => $cremation, meteo => $meteo });
					}
					if(defined($weather)) {
						$phrase->append(" ($weather)");
					}
				}
				append_notes({ phrase => $phrase, record => ($burial // $cremation // $funeral), paragraph => 0 });
			}
			$phrase->append("[$_]") foreach(sort @burialcitations);
		} elsif((!$aod) && ($placeofdeath || $dateofdeath) && !$diedathome) {
			# TODO - extract marriage banns information
			# if($person->marriage_bann()) {
				# die 'foo';
			# }
			if($placeofdeath && (scalar(@spouses) <= 1) && $placeofmarriage && ($placeofdeath eq $placeofmarriage) && (scalar(@events) == 0)) {
				if($language eq 'French') {
					if($phrase->length() == 0) {
						$phrase->set("C'est");
					} else {
						$phrase->append(', qui est');
					}
					$phrase->append(" aussi o\N{U+00F9} " . lcfirst($pronoun));
				} else {
					if($phrase->length() == 0) {
						$phrase->set('That');
					} else {
						$phrase->append(', which');
					}
					$phrase->append(' is also where ' . lcfirst($pronoun));
				}
			} elsif($aob && scalar(@spouses) && ($numberofchildren == 0)) {
				push @phrases, $phrase;
				$phrase = Data::Text->new($firstname // $pronoun);
			} else {
				if($phrase->length()) {
					push @phrases, $phrase;
					$phrase = Data::Text->new();
				}
				if($opts{'B'}) {
					if(scalar(@phrases)) {
						$bio->append(conjunction(map { $_->as_string() } @phrases));
						@phrases = ();
					}
					$phrase = Data::Text->new();

					if($bio->length()) {
						if(!pdfprint(string => $bio, text => $text, pdfpage => $pdfpage)) {
							$text->textend();

							$pdfpage = NJH::PDFPage->new($pdf);

							$text = $pdfpage->text();
							$text->font($params{'font'}, 12);
							pdfprint(string => $bio, text => $text, pdfpage => $pdfpage);
						}
						$bio = Data::Text->new(' ');
					}
				} else {
					$phrase->append("\n\t");
				}
				$phrase->append($firstname // $pronoun);
			}
			$phrase->append(i18n({ person => $person, format => ' died' }));

			if($dateofdeath) {
				if($dateofbirth && ($dateofdeath eq $dateofbirth)) {
					$phrase->append(i18n(' on the same day'));
				} elsif($placeofdeath && $placeofmarriage && ($placeofdeath eq $placeofmarriage) && !$printed_residence) {
					$phrase->append([
						' ',
						between(year({ person => $person, date => $dateofdeath, must_postdate => $birth_dt }))
					]);
					if((scalar(@events) > 0) && (my $place = place({ person => $person, record => $death, places_printed => \%places_printed }))) {
						# Place hasn't already been printed with "that is also where she died"
						$phrase->append($place);
					}
				} elsif($placeofbirth && $placeofdeath && ($placeofdeath eq $placeofbirth) && (scalar(@spouses) <= 1) && ($placeofdeath =~ /^(.+?),.*/) && !$printed_residence) {
					my $p = $1;
					if($dateofdeath =~ /\s$/) {
						complain({ person => $person, warning => 'Removing trailing spaces from date of death' });
						$dateofdeath =~ s/\s+$//;
					}
					$phrase->append(" in $p " .
						year({ person => $person, date => $dateofdeath, must_postdate => $birth_dt }));
				} else {
					if($dateofdeath =~ /\s$/) {
						complain({ person => $person, warning => "Removing trailing spaces from date of death '$death'" });
						$dateofdeath =~ s/\s+$//;
					}
					$phrase->append([
						' ',
						between(year({ person => $person, date => $dateofdeath, must_postdate => $birth_dt }))
					]);
					if($placeofdeath && ((!$placeofmarriage) || ($placeofdeath ne $placeofmarriage) || $printed_residence)) {
						my $place = place({ person => $person, record => $death, places_printed => \%places_printed });
						if(!defined($place)) {
							$place = place({ person => $person, place => $placeofdeath, places_printed => \%places_printed });
						}
						if(defined($place)) {
							if($place eq ' in , , ') {
								complain({ person => $person, warning => 'Assuming place of death is unknown' });
								$place = undef;
							} elsif($place =~ /[\,;]\s*$/) {
								complain({ person => $person, warning => "Removing trailing spaces from '$place'" });
								$place =~ s/[\,;]\s*//g;
							}
						}
						if(defined($place)) {
							$phrase->append($place);
						} else {
							complain({
								person => $person,
								warning => "Place of death ($placeofdeath) can't be parsed"
							});
						}
					}
				}
			} elsif((!$placeofmarriage) || ($placeofdeath ne $placeofmarriage)) {
				my $place = place({ person => $person, place => $placeofdeath });
				if($place =~ /[\,;]\s*$/) {
					complain({ person => $person, warning => "Removing trailing spaces from '$place'" });
					$place =~ s/[\,;]\s*//g;
				}
				$phrase->append($place);
			}
			$phrase->append("[$_]") foreach(List::Util::uniq(sort @deathcitations));

			add_death_notes({ person => $person, record => $death, phrase => $phrase });
		}

# die $phrase->as_string() if((!$end_of_sentence) && ($phrase->as_string() =~ /[\.\,]\s*$/));
		# push @phrases, $phrase;

		# if($death && (my $notes = notes({ person => $person, record => $death, paragraph => 1 }))) {
			# print "\n$notes";
		# }

		if(my $notes = notes({ person => $person, record => $person, paragraph => 1 })) {
			# TODO: add data from dbpedia to the notes
			#	https://lookup.dbpedia.org/api/search?query=Francis%20Eric%20Irvine%20Bloy&format=JSON
			#	with citation to https://dbpedia.org/page/Francis_Eric_Bloy
			# if(LWP::Simple::WithCache::is_success($rc = LWP::Simple::WithCache::getstore($file, $filename))) {
			if($opts{'B'}) {
				if(scalar(@phrases)) {
					$bio->append(conjunction(map { $_->as_string() } @phrases))->append('.  ');
					@phrases = ();
				}
				$phrase = Data::Text->new();

				if($bio->length()) {
					if(!pdfprint(string => $bio, text => $text, pdfpage => $pdfpage)) {
						$text->textend();

						$pdfpage = NJH::PDFPage->new($pdf);

						$text = $pdfpage->text();
						$text->font($params{'font'}, 12);
						pdfprint(string => $bio, text => $text, pdfpage => $pdfpage);
					}
					$bio = Data::Text->new(' ');
				}
			} else {
				if($phrase->length() > 0) {
					push @phrases, $phrase;
					$phrase = Data::Text->new();
				}
				if(scalar(@phrases)) {
					$bio->append(conjunction(map { $_->as_string() } @phrases))->append('.');
					@phrases = ();
				}
			}
			$notes =~ s/\.$//;
			$phrase = Data::Text->new("\n")->append($notes);
		}

		if($opts{'C'}) {
			foreach my $child(@children) {
				if(my $dob = dateofbirth($child)) {
					unless($opts{'B'}) {
						$phrase->append("\n\t");
					}
					$phrase->append($child->given_names() .
						' was born ' .
						year({ person => $child, date => $dob }));
					if($opts{'w'} && ($birth_dt || $death_dt) &&
					   ($dob !~ /^\d{3,4}$/) && ($dob =~ /^\d/) &&
					   ($dob !~ /[a-z]$/i)) {
						my $d;
						eval {
							$d = $date_parser->parse(date => $dob);
						};
						if($d) {
							$d = @{$d}[0];
						}
						if($d) {
							$d = $dfn->parse_datetime($d->{'canonical'});
							if($birth_dt && ($d <= $birth_dt)) {
								complain({ person => $child, warning => 'born before parent was born' });
							}
							if(($sex eq 'F') && $death_dt && ($d > $death_dt)) {
								complain({ person => $child, warning => 'born after mother died' });
							} elsif(($sex eq 'M') && $death_dt && ($d > ($death_dt + $tenmonths))) {
								# Allow the child to be
								# born up to 10 months
								# after the death of the
								# father
								complain({ person => $child, warning => 'born more than 10 months after father died' });
							}
						}
					}
					$phrase->append('.');
				} elsif(my $bd = get_value({ person => $child, value => 'baptism date' })) {
					$phrase->append("\t" . $child->given_names() .
						" was born c. $bd.");
				}
			}

			if(scalar(@children)) {
				$bio->append(conjunction(map { $_->as_string() } @phrases))->append('.');
				@phrases = ();

				$phrase = Data::Text->new("\n\t");
			}
		}

		if($phrase->length() > 2) {
			push @phrases, $phrase;
		}
		if($opts{'c'}) {
			if(scalar(@phrases)) {
				$bio->append(conjunction(map { $_->as_string() } @phrases));
				if($phrase->as_string() !~ /\."$/) {
					$bio->append('.');
				}
				@phrases = ();

				$phrase = Data::Text->new("\n\t");
			} elsif($citationcount) {
				$phrase->append("\n\t");
			}

			my $ufinder = URI::Find::Schemeless->new(sub {
				# my($uri, $orig_uri) = @_;
				my $orig_uri = $_[1];

				if($opts{'w'}) {
					my $u = URI->new($orig_uri);
					if($u && (ref($u) ne 'URI::_generic') && !$browser->head($orig_uri)) {
						complain({ person => $person, warning => "$orig_uri: not found" });
					}
				}
				return $orig_uri;
			});

			my %census_years;
			my $burialrecord;
			foreach my $index(1..$citationcount) {
				my $citation = $citations{$index};
				if(!$citation) {
					complain({
						person => $person,
						warning => "[$index]: empty citation"
					});
					next;
				}
				my $title = $citation->title();
				if(!defined($title)) {
					# For example, FMP 'web' source
					if($citation->items()) {
						my @items = $citation->items();
						# $Data::Dumper::Maxdepth = 2;
						# print Data::Dumper->new([\@items])->Dump();
						$title = $items[0]->{'value'};
					} elsif($citation->value()) {
						$title = $citation->value();
					} else {
						complain({
							person => $person,
							warning => "[$index]: no citation title"
						});
						$title = 'No citation title';
					}
				}
				if($opts{'B'}) {
					if(scalar(@phrases)) {
						$bio->append(conjunction(map { $_->as_string() } @phrases));
					}
					$bio->append('.  ');
					$phrase = Data::Text->new();
					@phrases = ();

					if($bio->length()) {
						if(!pdfprint(string => $bio, text => $text, pdfpage => $pdfpage)) {
							$text->textend();

							$pdfpage = NJH::PDFPage->new($pdf);

							$text = $pdfpage->text();
							$text->font($params{'font'}, 12);
							pdfprint(string => $bio, text => $text, pdfpage => $pdfpage);
						}
						$bio = Data::Text->new(' ');
					}
				} else {
					$phrase->rtrim()->append("\n\t");
				}
				$phrase->append("[$index]: $title");
				# if(defined(my $publication = $citation->publication())) {
					# print " $publication";
					# if(defined(my $continuation = $citation->cont())) {
						# print $continuation;
					# }
				# }
				if(defined(my $page = $citation->page())) {
					$phrase->append(" $page");
				}

				my @notes = $citation->note();
				foreach my $note(@notes) {
					if(ref($note) eq 'Gedcom::Record') {
						$note = $note->note();
					}

					if($note && ($note !~ /^This information comes from/)) {
						if($opts{'w'}) {
							$ufinder->find(\$note);
						}
						$phrase->append(" ($note)") unless($note eq $title);
					}
				}
				if($citationnotes{$index}) {
					$citationnotes{$index} =~ s/\.$//;
					$phrase->append(" ($citationnotes{$index})");
				}

				if(($title =~ /census/i) && ($title =~ /(\d{3,4})/)) {
					$census_years{$1} = $title;
				}
				if(($title =~ /find a grave/i) ||
				   ($title =~ /billiongraves/i)) {
					$burialrecord = 1;
				}
			}
			$phrase->append("\n") if($citationcount);

			if($opts{'w'}) {
				# People alive during the years when censuses have been available must
				# have appeared in at least one census
				# FIXME:  should be a better test, e.g. catch people 1861-1930, don't
				#	catch 1862-1865.  The current test misses some but should have
				#	no false positives
				if((defined($yob) && ($yob >= 1841) && ($yob <= 1921)) &&
				  ((defined($yod)) && ($yod >= 1841) && ($yod <= 1921)) &&
				  (($yod - $yob) >= 10) &&
				  (scalar(keys(%census_years)) == 0)) {
					complain({ person => $person, warning => 'Appears in no censuses' });
				}

				my %unused_censuses = %census_years;
				foreach my $residence(@residences) {
					if(my $rdate = $residence->date()) {
						if($rdate =~ /(\d{3,4})$/) {
							$rdate = $1;
							delete $unused_censuses{$1};
						}
					}
				}
				foreach my $year(sort keys %unused_censuses) {
					complain({
						person => $person,
						warning => "The census for the year $year has been cited, but its information has not been used as a residence"
					});
				}
				foreach my $event(@events) {
					if(ref($event) eq 'Gedcom::Record') {
						my $type = $event->type();
						my $year;
						if($type =~ /^Census U[KS] (\d{4})$/) {
							$year = $1;
							if(!$event->date()) {
								complain({ person => $person, warning => "Census for $year missing a date" });
							}
						} elsif($type eq 'Register UK 1939') {
							if(!$event->date()) {
								complain({ person => $person, warning => '1939 UK register is missing the date 29 Sep 1939' });
							}
							$year = 1939;
						} elsif($type =~ /^(\d{4}) Census of Canada/) {
							$year = $1;
							if(!$event->date()) {
								complain({ person => $person, warning => "Census for $year missing a date" });
							}
							# Check Location includes Canada
							if(my $place = place({ person => $person, record => $event, nopreposition => 1 })) {
								if($place =~ /Canada$/i) {
									complain({ person => $person, warning => "Canadian census for $year doesn't list Canada as the location" });
								}
							} else {
								complain({ person => $person, warning => "Canadian census for $year doesn't list Canada as the location" });
							}
						} elsif($type eq 'Census') {
							if(my $date = $event->date()) {
								if($date =~ /(\d{4})$/) {
									$year = $1;
								}
							}
							if(!defined($year)) {
								complain({ person => $person, warning => '1939 UK register is missing the date 29 Sep 1939' });
							}
						} else {
							next;
						}
						$census_years{$year} = $type;
						if(defined($yod) && ($year > $yod)) {
							complain({ person => $person, warning => "Census for $year after year of death ($yod)" });
						} elsif(defined($yob) && ($year < $yob)) {
							complain({ person => $person, warning => "Census for $year before year of birth ($yob)" });
						}
					}
				}
				foreach my $year(sort { $a <=> $b } keys(%census_years)) {
					if($census_years{$year + 20} && !$census_years{$year + 10}) {
						# FIXME: the 1890 US Census was lost, don't error on that
						complain({
							person => $person,
							warning => 'Census information missing between ' . $census_years{$year} . ' and ' . $census_years{$year + 20}
						});
					}
				}
				if($dateofdeath && !defined($placeofdeath)) {
					complain({ person => $person, warning => 'Date of death is known, but not place' });
				} elsif($placeofbirth && $dateofdeath && (!$census_years{1939}) &&
				   (datecmp($dateofdeath, '1939') >= 0) && ($placeofbirth =~ /England$/) && ($placeofdeath =~ /England$/) &&
				   ((!$dateofbirth) || (datecmp($dateofbirth, '1939') <= 0))) {
					my $has1939 = 0;
					foreach my $residence(@residences) {
						if($residence->date() && ($residence->date() =~ /1939$/)) {
							$has1939 = 1;
							last;
						}
					}
					if(!$has1939) {
						complain({
							person => $person,
							warning => '1939 UK register information missing'
						});
					}
				}
				my $surname = $lastname;
				if(defined($sex) && ($sex eq 'F')) {
					if(my $husband = $person->husband()) {
						$surname = $husband->surname();
					}
				}
				if($yod && $firstname && $surname && !$burialrecord) {
					my %opts = (
						date_of_death => $yod,
						firstname => $firstname,
						lastname => $surname,
						ua => $browser,
					);
					if($placeofburial) {
						if($placeofburial =~ /.+,\s+(\w+)/) {
							$opts{'country'} = $1;
						}
					} elsif($placeofdeath) {
						if($placeofdeath =~ /.+,\s+(\w+)/) {
							$opts{'country'} = $1;
						}
					}
					if($opts{'country'} && ($opts{'country'} eq 'USA')) {
						$opts{'country'} = 'United States of America';
					}
					# foreach my $b(WWW::Scrape::FindaGrave->new(\%opts)) {
					if(defined($grave_modules)) {
						if(ref($grave_modules)) {
							foreach my $m(@{$grave_modules}) {
								my $b = $m->new(\%opts);
								while(my $url = $b->get_next_entry()) {
									complain({
										person => $person,
										warning => "possible burial link $url"
									});
								}
							}
						} else {
							my $b = $grave_modules->new(\%opts);
							while(my $url = $b->get_next_entry()) {
								complain({
									person => $person,
									warning => "possible burial link $url"
								});
							}
						}
					}
				}
			}
		} else {
			if(scalar(@phrases)) {
				$bio->append(conjunction(map { $_->as_string() } @phrases))->append('.');

				@phrases = ();

				$phrase = Data::Text->new("\n");
			}
			if($citationcount) {
				die "Bug: citationcount = $citationcount when -c not given";
			}
		}

		if($opts{'B'}) {
			if($phrase->rtrim()->length()) {
				push @phrases, $phrase;
			}
			if(scalar(@phrases)) {
				$bio->append(conjunction(map { $_->as_string() } @phrases));
				$phrase = Data::Text->new();
				@phrases = ();
			}
			if($bio->length()) {
				if($bio->length() > 3000) {
					# It's not going to fit on one page
					# Split into paragraphs
					my @paras = split(/\n/, $bio->as_string());
					foreach my $p(@paras) {
						next if(length($p) == 0);
						if(length($p) > 3000) {
							# Very long paragraph
							my @lines = split(/\n/, wrap('', '', ($p)));
							foreach my $l(@lines) {
								if(!pdfprint(string => $l, text => $text, pdfpage => $pdfpage, noindent => 1)) {
									$text->textend();

									$pdfpage = NJH::PDFPage->new($pdf);

									$text = $pdfpage->text();
									$text->font($params{'font'}, 12);
									die "Print failure: $l" if(!pdfprint(string => $l, text => $text, pdfpage => $pdfpage, noindent => 1));
								}
							}
						} elsif(!pdfprint(string => $p, text => $text, pdfpage => $pdfpage)) {
							$text->textend();

							$pdfpage = NJH::PDFPage->new($pdf);

							$text = $pdfpage->text();
							$text->font($params{'font'}, 12);
							die "Print failure: $p" if(!pdfprint(string => $p, text => $text, pdfpage => $pdfpage));
						}
					}
				} elsif(!pdfprint(string => $bio, text => $text, pdfpage => $pdfpage)) {
					$text->textend();

					$pdfpage = NJH::PDFPage->new($pdf);

					$text = $pdfpage->text();
					$text->font($params{'font'}, 12);
					die 'Print failure' if(!pdfprint(string => $bio, text => $text, pdfpage => $pdfpage));
					$bio = Data::Text->new();
				}
				$phrase = undef;
			}
		} elsif((!defined($bio)) || ($bio->length() == 0) || ($bio->as_string() eq "\t.")) {
			if(scalar(@phrases)) {
				print conjunction(map { $_->as_string() } @phrases), ".\n", '-' x 80, "\n";
			} else {
				complain({ person => $person, warning => "couldn't extract a biography" });
			}
		} else {
			if($phrase->rtrim()->length() > 0) {
				# FIXME: don't do this if this is the last person
				push @phrases, $phrase;
				if(scalar(@phrases)) {
					$bio->append(conjunction(map { $_->as_string() } @phrases));
				}
			}
			print $bio->rtrim()->as_string(), "\n", '-' x 80, "\n";
		}
	} else {
		my ($dob, $dod);
		eval {
			$dob = dateofbirth($person);
			$dod = dateofdeath($person);
		};
		if($@) {
			warn "Can't parse record for $firstname $lastname";
			return;
		}

		if(defined($dob) && (!$onlydeaths) && !$onlybirthdays) {
			my $d;
			if(($dob !~ /^\d{3,4}$/) && ($dob =~ /^\d/)) {
				eval {
					$d = $date_parser->parse(date => $dob);
				};
			}
			if($d) {
				$d = @{$d}[0];
				$birth_dt = $dfn->parse_datetime($d->{'canonical'});
				print "\tBorn: ", $birth_dt->strftime('%x');
			} else {
				if($@) {
					if($opts{'f'}) {
						die $@;
					}
					if($opts{'w'}) {
						red_warning({ person => $person, warning => $@ });
					}
				}
				print "\tBorn: $dob";
			}
			print "\n";
		}
		if(defined($dod) && (!$onlydeaths) && !$onlybirthdays) {
			if(defined($death_dt)) {
				print "\tDied: ", $death_dt->strftime('%x'), "\n";
			} else {
				my $d;
				if(($dod !~ /^\d{3,4}$/) && ($dod =~ /^\d/)) {
					eval {
						$d = $date_parser->parse(date => $dod);
					};
				}
				if($d) {
					$d = @{$d}[0];
					$death_dt = $dfn->parse_datetime($d->{'canonical'});
					print "\tDied: ", $death_dt->strftime('%x');
				} else {
					if($@) {
						if($opts{'f'}) {
							die $@;
						}
						if($opts{'w'}) {
							red_warning({ person => $person, warning => $@ });
						}
					}
					print "\tDied: $dod\n";
				}
				print "\n";
			}
		}
	}
	# $printed{$person->xref()} = 1;

	if($opts{'B'}) {
		my @images;
		my %files;
		foreach my $o($person->obje()) {
			my $obje;
			if(ref($o) eq 'Gedcom::Record') {
				$obje = $o;	# e.g. Ancestry
			} else {
				$obje = $ged->resolve_xref($o);	# e.g. FMP
			}
			next if(!defined($obje));
			if(my $file = $obje->file()) {
				if(ref($file) eq 'Gedcom::Record') {
					# warn $file->tag(), "\n" if($file->tag());
					$file = $file->{'file'};
					next if($file eq '*');
				}
				if($files{$file}) {
					print "$file is already printed\n" if($opts{'v'});
					next;
				}
				$files{$file} = 1;
				my $title = $obje->title() || $obje->tag_record('TITL', 1);
				my $form = $obje->form();
				if((!$form) && $obje->items()) {
					# Family Tree Maker does this
					my @items = $obje->items();
					$file = $items[0]->{'value'};
					# TODO: Find the title
				}
				$file =~ s/\{0\}//g;
				$file =~ s/\r//g;
				my $image;
				my $filename;
				my $orig_image;
				my $orig_filename;
				my $gd;
				if($file =~ /^http:\/\/(\w+)\.findmypast\.(co[\w\.]+)\/(.+)/) {
					$file = "https://$1.findmypast.$2/$3";
				}
				if(($file =~ /^https?:\/\//) && ($file !~ /\.jpe?g$/) && ($file !~ /ancestry.com.*image.*guid=/)) {
					$file =~ s/%2f/\//gi;
					print "Download $file\n" if($opts{'v'});

					# Returns HTTP::Response
					my $resp = $cached_browser->get($file);
					if($resp->is_success() && ($resp->content_type() eq 'image/jpeg')) {
						$title = $file if(!defined($title));
						my $tmp = File::Temp->new(UNLINK => 0);
						$filename = $tmp->filename();
						open(my $fh, '>', $filename);
						binmode($fh);
						print $fh $resp->decoded_content();
						close $fh;
						$orig_filename = $filename;

						print "Resize $filename\n" if($opts{'v'});

						my $resize = Image::Resize->new($filename);
						my $width = $resize->width();
						my $height = $resize->height();
						if($height > 250) {
							my $newwidth = $width * (250 / $height);
							my $newheight;
							if($newwidth > 550) {
								$newheight = $height * (550 / $width);
								$gd = $resize->resize(550, $newheight);
							} else {
								$gd = $resize->resize($newwidth, 250);
								$newheight = 205;
							}
						} elsif($width > 550) {
							my $newheight = $height * (550 / $width);
							$gd = $resize->resize(550, $newheight);
						}
						if($gd) {
							$image = $pdf->image_gd($gd, -lossless => 1);
						} else {
							$image = $pdf->image_jpeg($filename);
						}
						$orig_image = $pdf->image_jpeg($orig_filename);
					} else {
						if(!$resp->is_success()) {
							complain({ person => $person, warning => "download $file failed " . $resp->status_line() });
						}
						$title = undef;
					}
				} elsif(($file =~ /^([A-Z]:[\/\\].+\.jpe?g+)/) || ($file =~ /^(\/.+\.jpe?g)/)) {
					$form = 'JPG';
				}
				if((!defined($image)) && $form && (lc($form) eq 'jpg')) {
					if($file =~ /ancestry.com.+guid=.+&tid=/) {
						# Ancestry's Gedcoms are broken, perhaps pointing to an old
						# location that they forgot to fix
						if($file =~ /guid=([a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12})/) {
							# FIXME: Ancestry pictures attached from another
							# tree aren't downloaded.  This URL will generate a
							# 404
							$file = "https://mediasvc.ancestry.com/v2/image/namespaces/1093/media/$1.jpg?client=Trees";
						} else {
							complain({ person => $person, warning => "BUG: update ACOM mapping for $file" });
							unlink $filename if(defined($filename));
							unlink $orig_filename if(defined($orig_filename));
							next;
						}
					}
					my $rc;
					my $tmp = File::Temp->new(UNLINK => 0);
					$filename = $tmp->filename();
					$orig_filename = $filename;
					print "Downloading $file to $filename\n" if($opts{'v'});
					if(LWP::Simple::WithCache::is_success($rc = LWP::Simple::WithCache::getstore($file, $filename))) {
						if(-z $filename) {
							complain({ person => $person, warning => "Downloaded file '$file' was empty" });
							$title = undef;
						} else {
							print "Resize $filename\n" if($opts{'v'});

							my $resize = Image::Resize->new($filename);
							my $width = $resize->width();
							my $height = $resize->height();
							if($height > 250) {
								my $newwidth = $width * (250 / $height);
								my $newheight;
								if($newwidth > 550) {
									$newheight = $height * (550 / $width);
									$gd = $resize->resize(550, $newheight);
								} else {
									$gd = $resize->resize($newwidth, 250);
									$newheight = 250;
								}
							} elsif($width > 550) {
								my $newheight = $height * (550 / $width);
								$gd = $resize->resize(550, $newheight);
							}
							if($gd) {
								# $orig_image = $pdf->image_jpeg($orig_filename);
								# $tmp = File::Temp->new(UNLINK => 0);
								# $filename = $tmp->filename();
								# open(my $fh, '>', $filename);
								# print $fh $gd->jpeg();
								# close $fh;
								$image = $pdf->image_gd($gd, -lossless => 1);
							}
							$image = $pdf->image_jpeg($filename);
							$title = $file if(!defined($title));
							# $image->height(32);
							# $image->width(32);
						}
					} else {
						red_warning({ person => $person, warning => "download $file failed to $filename: $rc" });
						$title = undef;
					}
				}
				if($title) {
					push @images, { image => $image, orig_image => $orig_image, title => $title, orig_filename => $orig_filename };
					push @tmpfiles, $orig_filename if(defined($orig_filename) && ($orig_filename ne $filename));
				} elsif(defined($orig_filename) && ($orig_filename ne $filename)) {
					# I don't think this path is ever taken
					unlink $orig_filename;
				}
				push @tmpfiles, $filename if(defined($filename));
			}
		}
		if(scalar(@images)) {
			$text->textend();
		}
		while(my $i = shift @images) {
			my $title = $i->{'title'};

			my $newpage;
			my $trigger_page_throw;
			if(my $image = $i->{'image'}) {
				if($opts{'v'}) {
					print "$title: height/width: ", $image->height(), '/', $image->width(), "\n";
				}

				if(($image->height() >= ($pdfpage->y() - 80)) ||
				   ($pdfpage->linesleft() <= 15)) {
					print "New page to fit image on it\n" if($opts{'v'});
					$pdfpage = NJH::PDFPage->new($pdf);
					$newpage = 1;
				}
				my $y = $pdfpage->newline() - $image->height();

				if(my $peek = $images[0]) {
					if(my $pimage = $peek->{'image'}) {
						if(($image->width() < 250) && ($pimage->width() < 250) &&
						   ($pimage->height() <= $y) && ($pimage->height() <= $image->height())) {
							# Print two images side by side
							$peek = shift @images;

							my $x = 150 - ($image->width() / 2);
							$pdfpage->page()->gfx()->image($image, $x, $y);
							$x = 450 - ($pimage->width() / 2);
							$pdfpage->page()->gfx()->image($pimage, $x, $y);
							$pdfpage->y($y);

							$text = $pdfpage->text();
							# This is needed because of the text end above
							$text->textstart() if(!$newpage);
							$text->font($pdf->corefont('Times-Italic'), 12);
							$x = 150 - (length($title) / 2);
							if(!pdfprint(string => $title, text => $text, pdfpage => $pdfpage, x => $x, centre => 1)) {
								die "Didn't make enough room for $title; y = ", $pdfpage->y();
							}
							my $ptitle = $peek->{'title'};
							$pdfpage->y($y);	# Put the two captions on the same line
							$x = 450 - (length($ptitle) / 2);
							if(!pdfprint(string => $ptitle, text => $text, pdfpage => $pdfpage, x => $x, centre => 1)) {
								die "Didn't make enough room for $ptitle ; y = ", $pdfpage->y();
							}
							# $text->textend();
							next;
						}
					}
				}

				my $orig_image = $i->{'orig_image'};

				next unless($image || $orig_image);

				if($orig_image && ($pdfpage->y() > ($orig_image->height() + 80)) && ($orig_image->width() < 550)) {
					# No need to shrink the image
					$y = $pdfpage->y() - $orig_image->height();
					my $x = 300 - ($orig_image->width() / 2);
					$pdfpage->page()->gfx()->image($orig_image, $x, $y);
					$pdfpage->y($y);
				} elsif($orig_image && $newpage && ($orig_image->width() < 550)) {
					# Shrink the image to take the entire page height and appropriate width
					my $width = $orig_image->width();
					my $height = $orig_image->height();
					if($height >= 650) {
						my $newwidth = ($width * 650) / $height;
						my $gd = GD::Image->new($i->{'orig_filename'});
						print "Resize $gd\n" if($opts{'v'});
						my $resize = Image::Resize->new($gd);
						$gd = $resize->resize($newwidth, 650);
						$image = $pdf->image_gd($gd, -lossless => 1);
						$width = $newwidth;
						$height = 650;
					} else {
						$image = $orig_image;
					}
					my $x = 300 - ($width / 2);
					$pdfpage->page()->gfx()->image($image, $x, 740 - $height);
					$pdfpage->y(740 - $height);
				} elsif($orig_image && $newpage && ($orig_image->height() < 650)) {
					# Shrink the image to take the entire page width and appropriate height
					my $width = $orig_image->width();
					my $height = $orig_image->height();
					if($width >= 500) {
						my $newheight = ($height * 500) / $width;
						my $gd = GD::Image->new($i->{'orig_filename'});
						print "Resize $gd\n" if($opts{'v'});
						my $resize = Image::Resize->new($gd);
						$gd = $resize->resize(500, $newheight);
						$image = $pdf->image_gd($gd, -lossless => 1);
						$width = 500;
						$height = $newheight;
					} else {
						$image = $orig_image;
					}
					my $x = 300 - ($width / 2);
					$pdfpage->page()->gfx()->image($image, $x, 740 - $height);
					$pdfpage->y(740 - $height);
				} elsif($orig_image && $newpage) {
					if($opts{'v'}) {
						print "$title height and width are too big. height/width: ", $orig_image->height(), '/', $orig_image->width(), "\n";
					}
					# Handle when both height and width are too big
					my $width = $orig_image->width();
					my $height = $orig_image->height();
					my $newwidth = ($width * 650) / $height;
					my $newheight = 650;
					if($newwidth > 500) {
						$newheight = ($height * 500) / $width;
						$newwidth = 500;
					}
					my $gd = GD::Image->new($i->{'orig_filename'});
					print "Resize $gd\n" if($opts{'v'});
					my $resize = Image::Resize->new($gd);
					$gd = $resize->resize($newwidth, $newheight);
					$image = $pdf->image_gd($gd, -lossless => 1);
					$height = $newheight;
					$width = $newwidth;
					my $x = 300 - ($width / 2);
					$pdfpage->page()->gfx()->image($image, $x, 740 - $height);
					$pdfpage->y(740 - $height);
					$trigger_page_throw = 1;
				} else {
					# Shrink the image to fit on the page
					if($image->height() > 650) {
						my $width = $image->width();
						my $height = $image->height();
						my $newwidth = ($width * 650) / $height;
						my $newheight = 650;
						if($newwidth > 500) {
							$newheight = ($height * 500) / $width;
							$newwidth = 500;
						}
						my $gd = GD::Image->new($i->{'orig_filename'});
						print "Resize $gd\n" if($opts{'v'});
						my $resize = Image::Resize->new($gd);
						$gd = $resize->resize($newwidth, $newheight);
						$image = $pdf->image_gd($gd, -lossless => 1);
						$height = $newheight;
						$width = $newwidth;
						$y = $pdfpage->newline() - $newheight;
					}
					my $x = 300 - ($image->width() / 2);
					$pdfpage->page()->gfx()->image($image, $x, $y);
					if($image->height() >= ($y - 80)) {
						print "It took the entire page\n" if($opts{'v'});
					}
					$pdfpage->y($y);
				}
			}

			if($title) {
				$text = $pdfpage->text();
				# This is needed because of the text end above
				$text->textstart() if(!$newpage);
				$text->font($pdf->corefont('Times-Italic'), 12);
				if(length($title) > 200) {
					complain({ person => $person, warning => "Truncating long picture title $title" });
					$title = substr $title, 0, 200;
				}
				my $x = 300 - (length($title) / 2);
				if(!pdfprint(string => $title, pdfpage => $pdfpage, x => $x, centre => 1)) {
					print "Didn't make enough room for '$title'; y = ", $pdfpage->y(), "\n" if($opts{'v'});
					if($title =~ /^https?:\/\/(.+?)\//) {
						# e.g. https://tree.findmypast.com/assetHandler?id=100826878&at=1&ok=403385977&w=&h=&rk=&ex=81CDFFBD0A70580195F0C60BDF1D942B17C0A5670AFDA7C1AEC258BE52F02982CECF804E453E6779AE43C81D700C43258C3167FFE76CCCBC845
						$title = $1;
					}
					if(!pdfprint(string => $title, pdfpage => $pdfpage, x => $x, centre => 1)) {
						die "Didn't make enough room for '$title'; y = ", $pdfpage->y();
					}
				}
				# $text->textend();
			}
			if($trigger_page_throw) {
				$pdfpage = NJH::PDFPage->new($pdf);
			}
		}
	}
	# It would be nice to remove @tmpfiles here, but the PDF::API2 module needs them until the
	#	PDF is finally created
	print Data::Dumper->new([$person->state()])->Dump() if($opts{'v'});
}

# Create an SQLite database
sub sqlite
{
	my %args = (ref($_[0]) eq 'HASH') ? %{$_[0]} : @_;

	my $person = $args{'person'};

	my $mother = $person->mother() || 'NULL';
	my $father = $person->father() || 'NULL';

	if($mother ne 'NULL') {
		$mother = $mother->xref();
	}
	if($father ne 'NULL') {
		$father = $father->xref();
	}

	my $name = $person->name();
	$name =~ s/\///g;
	$nameparser->parse($name);
	my %name_components = $nameparser->components();
	my $firstname = $person->given_names() // $name_components{'given_name_1'};
	if($firstname) {
		$firstname =~ s/\'/\\\'/g;
	} else {
		$firstname = 'NULL';
	}
	my $surname = $name_components{'surname_1'};
	if($surname) {
		$surname =~ s/\'/\\\'/g;
	} else {
		$surname = 'NULL';
	}

	print "$firstname, $surname\n";

	my $dateofbirth = dateofbirth($person);
	if($dateofbirth) {
		$dateofbirth =~ tr/\//-/;
	} else {
		$dateofbirth = 'NULL';
	}

	my $dateofdeath = dateofdeath($person);

	if($dateofdeath) {
		$dateofdeath =~ tr/\//-/;
	} else {
		$dateofdeath = 'NULL';
	}
	my $query = "INSERT INTO people('xref', 'givennames', 'surname', 'mother', 'father', 'birth', 'death') VALUES (?, ?, ?, ?, ?, ?, ?);";
	my $statement = $dbh->prepare($query);

	my $xref = $person->xref();
	print "$xref: $firstname $surname\n";

	die unless($statement->execute($xref, $firstname, $surname, $mother, $father, $dateofbirth, $dateofdeath) == 1);

	my @siblings = $person->siblings();
	if(scalar(@siblings)) {
		$query = "INSERT INTO siblings('xref', 'sibling') VALUES (?, ?);";
		$statement = $dbh->prepare($query);
		foreach my $s(@siblings) {
			print ">$xref: $surname: ", $s->xref(), "\n";
			die unless($statement->execute($xref, $s->xref()) == 1);
		}
	}

	my @children = $person->children();
	if(scalar(@children)) {
		$query = "INSERT INTO children('xref', 'child') VALUES (?, ?);";
		$statement = $dbh->prepare($query);
		foreach my $c(@children) {
			print ">>$xref: $surname: ",
				$c->xref(), ': ',
				$c->given_names(), "\n";
			die unless($statement->execute($xref, $c->xref()) == 1);
		}
	}

	my @spouses = $person->spouse();
	if(scalar(@spouses)) {
		@spouses = map { Class::Simple::Readonly::Cached->new({ object => $_, cache => {}, quiet => 1 }) } @spouses;
		$query = "INSERT INTO spouses('xref', 'spouse', 'dateofmarriage', 'placeofmarriage') VALUES (?, ?, ?, ?);";
		$statement = $dbh->prepare($query);
		foreach my $spouse(@spouses) {
			my $date = get_value({ person => $spouse, value => 'marriage date' });
			my $marriage = $spouse->get_record('marriage') || $spouse->get_record('fams marriage');
			if((!defined($date)) && $marriage) {
				$date = $marriage->date();
			}
			if(!defined($date)) {
				$date = 'NULL';
			}
			my $place = get_value({
				person => $person,
				value => 'marriage place',
			});
			if((!defined($place)) && $marriage) {
				$place = $marriage->place();
			}
			if($place) {
				$place = place({
					person => $person,
					record => $place,
					nopreposition => 1
				});
				$place =~ s/^\s+//g;
			} else {
				$place = 'NULL';
			}
			print ">>>$xref: $surname, $date, $place: ",
				$spouse->xref(),
				"\n",
				$spouse->as_string(),
				"\n";
			die unless($statement->execute($xref, $spouse->xref(), $date, $place) == 1);
		}
	}
	my @residences = get_all_residences($person);
	if(scalar(@residences)) {
		$query = "INSERT INTO residences('xref', 'date', 'location') VALUES (?, ?, ?);";
		$statement = $dbh->prepare($query);
		foreach my $residence(@residences) {
			my $date = $residence->date() || 'NULL';
			my $place;
			if($residence->place()) {
				$place = place({
					person => $person,
					record => $residence,
					nopreposition => 1
				});
				$place =~ s/^\s+//g;
				$all_locations{$place} = $residence;
			} else {
				$place = 'NULL';
			}
			print ">>>>$xref: $date, $place\n";
			die unless($statement->execute($xref, $date, $place) == 1);
		}
	}
	my @occupations = get_all_occupations(person => $person);
	if(scalar(@occupations)) {
		$query = "INSERT INTO occupations('xref', 'occupation') VALUES (?, ?);";
		$statement = $dbh->prepare($query);
		foreach my $occupation(@occupations) {
			print ">>>>>$xref: $occupation\n";
			die unless($statement->execute($xref, $occupation) == 1);
		}
	}
}

sub all_records_have_date
{
	my %args = (ref($_[0]) eq 'HASH') ? %{$_[0]} : @_;

	my @records = @{$args{'records'}};
	my $person = $args{'person'};

	foreach my $record(@records) {
		if((!ref($record)) || (ref($record) ne 'Gedcom::Record') || !$record->date()) {
			return 0;
		}
		if(my $date = $record->date()) {
			if(($date !~ /^\d/) || ($date =~ /[a-z]$/i) ||
			   ($date =~ /[\/\-]/) || ($date =~ / to /) || !date_parser_cached(date => $date)) {
				return 0;
			}
			if(!date_parser_cached(date => $date)) {
				complain({
					person => $person,
					warning => "Record has an invalid date of $date"
				});
				return 0;
			}
		} else {
			return 0;
		}
	}
	return 1;
}

# nee: Born, used to denote a woman's maiden name (e.g., Anne Gibson nee West)
sub Gedcom::Individual::as_string
{
	my $self = shift;
	my %args = (ref($_[0]) eq 'HASH') ? %{$_[0]} : @_;

	my $name;

	if($args{'use_aka'}) {
		my $n2 = $self->tag_record('NAME', 2);
		if(defined($n2) && (ref($n2) eq 'Gedcom::Record') && defined($n2->type()) && ($n2->type() eq 'AlsoKnownAs') && ($n2->value() ne $self->name())) {
			$name = $n2->value();
		} else {
			return;
		}
	} else {
		$name = $self->name();

		# FIXME: how do I get to the NSFX (e.g. "OBE") value for the person?
		#	none of these methods works
		my $nsfx = $self->nsfx();
		if($nsfx) {
			die $nsfx;
		}
		$nsfx = $self->tag_record('NSFX');
		if($nsfx) {
			die $nsfx;
		}
		$nsfx = get_value({ person => $self, value => 'nsfx' });
		if($nsfx) {
			die $nsfx;
		}
	}

	$name =~ s/\///g;

	# FIXME: Correctly handle other names, relies on Lingua::EN::NameParse
	#	too much

	$name = Unicode::Diacritic::Strip::strip_diacritics($name);
	# $name =~ tr/ÄÃ¡Å/can/;
	# $name =~ s/Ä/c/g;
	# $name =~ s/Ã¡/a/g;
	# $name =~ s/Å/n/g;
	$nameparser->parse($name);

	my %name_components = $nameparser->components();
	my $first_name = $name_components{'given_name_1'} // $name_components{'initials_1'};
	my $middle_name = $name_components{'middle_name'};
	my $surname = $name_components{'surname_1'};
	if($name_components{'surname_2'}) {
		$surname .= ' ' . $name_components{'surname_2'};
	}
	if($name_components{'non_matching'}) {
		if($name =~ /(\w{2,})\s(\w{2,})\s(\w+)\s(\w{2,})/) {
			# Name parser doesn't parse names like this very well
			$first_name = $1;
			$middle_name = "$2 $3";
			$surname = $4;
		} else {
			if($surname) {
				$surname .= ' ';
			}
			my $rest = $name_components{'non_matching'};
			if($rest =~ /(.+) $/) {
				$rest = $1;
			}
			$surname .= $rest;

			# Remove the middle name, since it's come in from the non_matching
			$middle_name = undef;
			delete $args{'middle_names'};
		}
	} elsif(!defined($surname)) {
		$surname = $self->surname();
	}

	my $has_maiden_name;
	if($args{'nee'}) {
		my $sex = get_value({ person => $self, value => 'sex' });
		if(defined($sex) && ($sex eq 'F')) {
			my @husbands = $self->husband();
			if(my $husband = pop @husbands) {
				$surname = $husband->surname();
				$has_maiden_name = 1;
			} elsif(my $spouse = $self->spouse()) {
				complain({ person => $self, warning => 'married, but no husband relationship' });
				$surname = $spouse->surname();
				$has_maiden_name = 1;
			}
		}
	}

	my $rc;

	if($args{'title'}) {
		if($name_components{'title_1'}) {
			$rc = $name_components{'title_1'};
			if($rc) {
				$rc .= ' ';
			}
		} else {
			# FIXME: how do I get to the NPFX (e.g. "Cpl") value for the person?
			#	none of these methods works
			my $npfx = $self->npfx();
			if($npfx) {
				die $npfx;
			}
			$npfx = $self->tag_record('NPFX');
			if($npfx) {
				die $npfx;
			}
			$npfx = get_value({ person => $self, value => 'npfx' });
			if($npfx) {
				die $npfx;
			}
		}
	}

	if($first_name) {
		$rc .= $first_name;
	} elsif($self->given_names()) {
		$rc .= $self->given_names();
	} elsif($args{'print_unknown'}) {
		$rc .= ' ?';
	}

	if($args{'middle_names'}) {
		if($middle_name) {
			$rc .= " $middle_name";
		} elsif($name =~ /\s([A-Z])\s.+/) {
			# Just an initial has been given
			$rc .= " $1";
		}
	}

	if($surname) {
		if($rc) {
			$rc .= ' ';
		}
		$rc .= normalize_name($surname);
		if(my $suffix = $name_components{'suffix'}) {
			$rc .= " $suffix";
		}
	} elsif($args{'print_unknown'}) {
		$rc .= ' UNKNOWN';
	}

	if($has_maiden_name && (my $surname = $self->surname())) {
		# nÃ©e
		$rc .= " (n\N{U+00E9}e " . normalize_name($surname) . ')';
	}

	if(!defined($rc)) {
		complain({ warning => "Can't parse the name of '$name'" });
		$args{'include_years'} = 1;
		$rc = 'Unknown person';
	}

	# utf8::decode($rc);

	if($args{'include_years'}) {
		my $dob = dateofbirth($self);

		my $yob;	# Year of birth
		if($dob && ($dob =~ /.*?(\d{3,4})/)) {
			if($dob =~ /^(Abt|ca?)\.?\s*(.+)/i) {
				my $year = $2;
				if($year =~ /^[A-Z]{3}\s(.+)/i) {
					$yob = "c$1";	# Get the "1951" from "Feb 1951"
				}
				$yob = "c$year";
			} else {
				$yob = $1;
			}
		} else {
			$dob = get_value({ person => $self, value => 'baptism date' });
			if($dob && ($dob =~ /.*?(\d{3,4})/)) {
				$yob = "c$1";
			}
		}

		my $dod = dateofdeath($self);

		my $yod;	# Year of death
		if($dod && ($dod =~ /.*?(\d{3,4})/)) {
			if($dod =~ /^(Abt|ca?)\.?\s*(.+)/i) {
				my $year = $2;
				if($year =~ /^[A-Z]{3}\s(.+)/i) {
					$yod = "c$1";	# Get the "1951" from "Feb 1951"
				} else {
					$yod = "c$year";
				}
			} else {
				$yod = $1;
			}
		} else {
			$dod = get_value({ person => $self, value => 'burial date' });
			if($dod && ($dod =~ /.*?(\d{3,4})/)) {
				$yod = "c$1";
			}
		}

		$rc .= ' ' if($yob || $yod);

		if($yob) {
			$rc .= "$yob ";
		}

		$rc .= '-' if($yob || $yod);

		if($yod) {
			return "$rc $yod";
		}
	}

	if(!defined($rc)) {
		complain({ warning => [ "Can't determine the name for record ", $self->xref() ] });
		return '';
	}

	$rc =~ tr/"/'/;	# fix issues with Graphviz and others - compatibility with ged2site

	return $rc;
}

sub Gedcom::Individual::as_sort_key
{
	my $self = shift;
	my $surname = $self->surname();
	my $given_names = $self->given_names();

	if($surname && length($surname)) {
		if($given_names) {
			if($surname =~ /\s(.+?)$/) {
				$surname = $1;
			}
			return normalize_name("$surname, $given_names");
		}
		return normalize_name($surname) . ', ZZZZZ';
	} elsif($given_names) {
		return 'ZZZZZ, ' . normalize_name($given_names);
	}

	my $name = $self->name();

	$name =~ s/\///g;
	$nameparser->parse($name);

	my %name_components = $nameparser->components();
	my $first_name = $name_components{'given_name_1'};
	my $middle_name = $name_components{'middle_name'};
	$surname = $name_components{'surname_1'};
	if($name_components{'surname_2'}) {
		$surname .= ' ' . $name_components{'surname_2'};
	}
	my $rest;
	if($name_components{'non_matching'}) {
		if($name =~ /(\w+)\s(\w+)\s(\w+)\s(\w+)$/) {
			# Name parser doesn't parse names like this very well
			$first_name = $1;
			$middle_name = "$2 $3";
			$surname = $4;
		} else {
			if($surname) {
				$surname .= ' ';
			}
			$rest = $name_components{'non_matching'};
			if($rest =~ /(.+) $/) {
				$rest = $1;
			}
		}
	} elsif(!defined($surname)) {
		$surname = $self->surname();
	}

	my $rc;

	if($surname) {
		$rc = normalize_name($surname);
		if(my $suffix = $name_components{'suffix'}) {
			$rc .= " $suffix";
		}
	} else {
		$rc = 'ZZZZZZ';
	}

	if($first_name) {
		$rc .= ", $first_name";
	} elsif($given_names) {
		$rc .= ", $given_names";
	}

	if($middle_name) {
		$rc .= " $middle_name";
	} elsif($name =~ /\s([A-Z])\s.+/) {
		# Just an initial has been given
		$rc .= " $1";
	}

	if($rest) {
		$rc .= $rest;
	}

	if((!defined($rc)) && $opts{'w'}) {
		if($opts{'f'}) {
			die "\nCan't determine the name for record ", $self->xref();
		}
		red_warning({ "Can't determine the name for record " . $self->xref() });
		return '';
	}

	return $rc;
}

sub normalize_name
{
	my $name = shift;

	# utf8::decode($name);
	if($name =~ /[^[:ascii:]]/) {
		return $name;	# It will break encoding, so don't even try

		# my $rc;

		# foreach my $word(split(/-| |'/, lc($name))) {
			# $rc .= '-' if($rc && ($name =~ /-/));
			# $rc .= "'" if($rc && ($name =~ /'/));
			# $rc .= ' ' if($rc && ($name =~ / /));
			# $rc .= ucfirst($word);
		# }

		# return $rc;
	}

	return Lingua::EN::NameCase::nc($name);
}

sub Gedcom::Individual::pronoun
{
	my $self = shift;

	if(defined(my $sex = get_value({ person => $self, value => 'sex' }))) {
		if($sex eq 'F') {
			return 'She';
		}
		if($sex eq 'M') {
			return 'He';
		}
	}
	return 'They';
}

sub Gedcom::Individual::possessive
{
	my $self = shift;

	my $rc = {
		'He' => 'His',
		'She' => 'Her',
		'They' => 'Their',
	};

	return $rc->{$self->pronoun()};
}

# FIXME: currently only finds ancestors
# TODO: find in-laws
# See http://www.myrelative.com/html/relationship.html for inspiration
sub Gedcom::Individual::relationship {
	my $self = shift;
	my $other = shift;

	return if($other->xref() eq $self->xref());

	if($self->mother() && $other->mother() && $self->father() && $other->father()) {
		my $sex = $other->sex() || get_value({ person => $other, value => 'sex' });
		if(($self->mother()->xref() eq $other->mother()->xref()) && ($self->father()->xref() eq $other->father()->xref())) {
			if($language eq 'Farsi') {
				# return ($sex eq 'M') ? 'barÄdar' : 'khÄhar';
				return ($sex eq 'M') ? "\N{U+0631}\N{U+062F}\N{U+0637}\N{U+0631}\N{U+0638}" : "khÄhar\N{U+0631}\N{U+0647}\N{U+0627}\N{U+0648}\N{U+062E}";
			}
			return i18n(($sex eq 'M') ? 'brother' : 'sister');
		}
		if(($self->mother()->xref() eq $other->mother()->xref()) || ($self->father()->xref() eq $other->father()->xref())) {
			if($language eq 'Latin') {
				return ($sex eq 'M') ? 'frÄter uterÄ«nus' : 'soror uterÄ«na';
			} elsif($language eq 'German') {
				return ($sex eq 'M') ? 'Halbbruder' : 'Halbschwester';
			}
			return ($sex eq 'M') ? 'half-brother' : 'half-sister';
		}
	}

	return $self->relationship_down($other) || $self->relationship_up($other);
}

sub Gedcom::Individual::relationship_up
{
	my $self = shift;
	my $other = shift;
	my @ancestors;

	unless(@myancestors) {
		@myancestors = $self->ancestors();
	}
	if($me && ($self->xref() eq $me->xref())) {
		unless(@myancestors) {
			@myancestors = $me->ancestors();
		}
		return unless scalar(@myancestors);
		@ancestors = @myancestors;
	} else {
		@ancestors = $self->ancestors();
	}

	my $sex = get_value({ person => $other, value => 'sex' });
	if((!defined($sex)) || ($sex !~ /[MF]/)) {
		complain({ person => $other, warning => 'unknown sex' });
		return;
	}

	foreach my $person1(@ancestors) {
		die $person1->as_string() if($person1 eq $self);
		if($person1->xref() eq $other->xref()) {
			# Direct ancestor
			my $steps = stepsabove($self, $other, 0);
			my $title;

			if($language eq 'Farsi') {
				# return ($sex eq 'M') ? 'pedar' : 'mÄdar';
				return ($sex eq 'M') ? "\N{U+0631}\N{U+062F}\N{U+067E}" : "\N{U+0631}\N{U+062F}\N{U+0627}\N{U+0645}";
			} elsif($language eq 'Spanish') {
				return ($sex eq 'M') ? 'padre' : 'mother';
			} else {
				$title = i18n(($sex eq 'M') ? 'father' : 'mother');
			}

			if($steps >= 5) {
				if($language eq 'Latin') {
					if($steps == 5) {
						return ($sex eq 'M') ? 'atavus' : 'atavia';
					}
					if($steps == 6) {
						return ($sex eq 'M') ? 'tritavus' : 'tritavia';
					}
				}
				$steps -= 2;
				return "$steps times great-grand$title";
			} elsif($steps == 1) {
				return $title;
			} elsif($steps == 2) {
				if($language eq 'French') {
					return "grand-$title";
				} elsif($language eq 'Latin') {
					return ($sex eq 'M') ? 'avus' : 'avia';
				} elsif($language eq 'German') {
					return ($sex eq 'M') ? "Gro\N{U+00DF}vater" : "Gro\N{U+00DF}utter";
				}
				return "grand$title";
			} elsif($steps == 3) {
				if($language eq 'French') {
					return "arri\N{U+00E8}re-grand-$title";
				} elsif($language eq 'Latin') {
					return ($sex eq 'M') ? 'proavus' : 'proavia';
				} elsif($language eq 'German') {
					return ($sex eq 'M') ? "Urgro\N{U+00DF}vater" : "Urgro\N{U+00DF}utter";
				}
				return "great-grand$title";
			} elsif($steps == 4) {
				if($language eq 'Latin') {
					return ($sex eq 'M') ? 'abavus' : 'abavia';
				} elsif($language eq 'German') {
					return ($sex eq 'M') ? "Ur-urgro\N{U+00DF}vater" : "Ur-urgro\N{U+00DF}utter";
				}
				return "great-great-grand$title";
			} elsif($steps <= 0) {
				if(my $spouse = $other->spouse()) {
					if(stepsabove($self, $spouse, 0)) {
						# The caller should now check
						# the spouse's relationship
						return;
					}
				}
				complain({ person => $other, warning => ": BUG - not a direct ancestor, steps = $steps" });
			}
		}
	}

	my @ancestors2 = $other->ancestors();
	return unless(@ancestors2);

	foreach my $person1(@ancestors) {
		foreach my $person2(@ancestors2) {
			# print $person1->as_string(), '->', $person2->as_string(), "\n";
			# G::C is noisy
			# TODO - apparently fixed in Github, awaiting new version on CPAN
			# my $c = Gedcom::Comparison->new($person1, $person2);
			# if($c->identical($person2)) {
				# die 'match found';
			# }

			if($person1->xref() eq $person2->xref()) {
				# Common ancestor is $person2
				my $steps1 = stepsabove($self, $person1, 0);
				# die $steps1 if($steps1 > 23);
				return if($steps1 > 23);
				my $steps2 = stepsabove($other, $person2, 0);
				# die $steps2 if($steps2 > 23);
				return if($steps2 > 23);

				if(defined($language) && ($language eq 'Latin')) {
					if(($steps1 == 1) && ($steps2 == 1)) {
						return ($sex eq 'M') ? 'frÄter' : 'soror';
					}
					my $myfather = $self->father();
					if(($steps1 == 2) && ($steps2 == 1)) {
						if($sex eq 'M') {
							if($myfather && (stepsabove($myfather, $person2, 0) > 0)) {
								return 'patruus';	# paternal uncle
							}
							return 'avunculus';	# maternal uncle
						} else {
							if($myfather && (stepsabove($myfather, $person2, 0) > 0)) {
								return 'amita';	# paternal aunt
							}
							return 'mÄtereta';	# maternal aunt
						}
					} elsif(($steps1 == 3) && ($steps2 == 1)) {
						if($sex eq 'M') {
							if($myfather && (stepsabove($myfather, $person2, 0) > 0)) {
								return 'patruus mÄgnus';	# paternal great-uncle
							}
							return 'avunculus mÄgnus';	# maternal great-uncle
						} else {
							if($myfather && (stepsabove($myfather, $person2, 0) > 0)) {
								return 'amita mÄgna';	# paternal great-aunt
							}
							return 'mÄtereta mÄgna';	# maternal great-aunt
						}
					} elsif(($steps1 == 4) && ($steps2 == 1)) {
						if($sex eq 'M') {
							if($myfather && (stepsabove($myfather, $person2, 0) > 0)) {
								return 'patruus mÄior';	# paternal great-great-uncle
							}
							return 'avunculus mÄior';	# maternal great-great-uncle
						} else {
							if($myfather && (stepsabove($myfather, $person2, 0) > 0)) {
								return 'amita mÄior';	# paternal great-great-aunt
							}
							return 'matertera mÄior';	# maternal great-great-aunt
						}
					} elsif(($steps1 == 5) && ($steps2 == 1)) {
						if($sex eq 'M') {
							if($myfather && (stepsabove($myfather, $person2, 0) > 0)) {
								return 'patruus mÄximus';	# paternal great-great-great-uncle
							}
							return 'avunculus mÄximus';	# maternal great-great-great-uncle
						} else {
							if($myfather && (stepsabove($myfather, $person2, 0) > 0)) {
								return 'amita mÄxima';	# paternal great-great-great-aunt
							}
							return 'matertera mÄxima';	# maternal great-great-great-aunt
						}
					} elsif(($steps1 == 2) && ($steps2 == 2)) {
						if($sex eq 'M') {
							if($myfather && (stepsabove($myfather, $person2, 0) > 0)) {
								return 'patruelis';	# paternal male 1st cousin
							}
							return 'consorbrius';	# maternal male 1st cousin
						} else {
							if($myfather && (stepsabove($myfather, $person2, 0) > 0)) {
								return 'patruelis';	# paternal female 1st cousin
							}
							return 'consorbria';	# maternal female 1st cousin
						}
					} elsif(($steps1 == 1) && ($steps2 == 2)) {
						if($other->father() && isbrother($self, $other->father())) {
							if($sex eq 'M') {
								return 'fratris filius';	# nephew - brother's son
							}
							return 'fratrais filia';	# niece - brother's daughter
						} elsif($other->mother() && issister($self, $other->mother())) {
							if($sex eq 'M') {
								return 'sororis filius';	# nephew - sister's son
							}
							return 'sororis filia';	# niece - sister's daughter
						} else {
							die 'BUG: parent neither sister nor brother';
						}
					}
				}

				# TODO: It would be nice to do this as an algorithm
				my %en_male_relationships = (
					1 << 24 | 1 => 'brother',
					1 << 24 | 2 => 'nephew',
					1 << 24 | 3 => 'great-nephew',
					1 << 24 | 4 => 'great-great-nephew',
					2 << 24 | 1 => 'uncle',
					2 << 24 | 2 => 'cousin',
					2 << 24 | 3 => 'first cousin once-removed',
					2 << 24 | 4 => 'first cousin twice-removed',
					2 << 24 | 5 => 'first cousin three-times-removed',
					3 << 24 | 1 => 'great-uncle',
					3 << 24 | 2 => 'first cousin once-removed',
					3 << 24 | 3 => 'second cousin',
					3 << 24 | 4 => 'second cousin once-removed',
					3 << 24 | 5 => 'second cousin twice-removed',
					3 << 24 | 6 => 'second cousin three-times-removed',
					4 << 24 | 1 => 'great-great-uncle',
					4 << 24 | 2 => 'first cousin twice-removed',
					4 << 24 | 3 => 'second cousin once-removed',
					4 << 24 | 4 => 'third cousin',
					4 << 24 | 5 => 'third cousin once-removed',
					4 << 24 | 6 => 'third cousin twice-removed',
					4 << 24 | 7 => 'third cousin three-times-removed',
					5 << 24 | 1 => 'three times great-uncle',
					5 << 24 | 2 => 'first cousin three-times-removed',
					5 << 24 | 3 => 'second cousin twice-removed',
					5 << 24 | 4 => 'third cousin once-removed',
					5 << 24 | 5 => 'fourth cousin',
					5 << 24 | 6 => 'fourth cousin once-removed',
					5 << 24 | 7 => 'fourth cousin twice-removed',
					6 << 24 | 1 => 'four times great-uncle',
					6 << 24 | 2 => 'first cousin four-times-removed',
					6 << 24 | 3 => 'second cousin three-times-removed',
					6 << 24 | 4 => 'third cousin twice-removed',
					6 << 24 | 5 => 'fourth cousin once-removed',
					6 << 24 | 6 => 'fifth cousin',
					6 << 24 | 7 => 'fifth cousin once-removed',
					6 << 24 | 8 => 'fifth cousin twice-removed',
					7 << 24 | 1 => 'fifth times great-uncle',
					7 << 24 | 2 => 'first cousin five-times-removed',
					7 << 24 | 3 => 'second cousin four-times-removed',
					7 << 24 | 4 => 'third cousin three-times-removed',
					7 << 24 | 5 => 'fourth cousin twice-removed',
					7 << 24 | 6 => 'fifth cousin once-removed',
					7 << 24 | 7 => 'sixth cousin',
					7 << 24 | 8 => 'sixth cousin once-removed',
					8 << 24 | 1 => 'six times great-uncle',
					8 << 24 | 2 => 'first cousin six-times-removed',
					8 << 24 | 3 => 'second cousin five-times-removed',
					8 << 24 | 4 => 'third cousin four-times-removed',
					9 << 24 | 1 => 'seven times great-uncle',
					9 << 24 | 2 => 'first cousin seven-times-removed',
					9 << 24 | 3 => 'second cousin six-times-removed',
					9 << 24 | 4 => 'third cousin five-times-removed',
					10 << 24 | 1 => 'eight times great-uncle',
					10 << 24 | 2 => 'first cousin eight-times-removed',
					10 << 24 | 3 => 'second cousin seven-times-removed',
					10 << 24 | 4 => 'third cousin six-times-removed',
					11 << 24 | 1 => 'nine times great-uncle',
					11 << 24 | 2 => 'first cousin nine-times-removed',
					11 << 24 | 3 => 'second cousin eight-times-removed',
					11 << 24 | 4 => 'third cousin seven-times-removed',
					11 << 24 | 5 => 'fourth cousin six-times-removed',
					12 << 24 | 1 => 'ten times great-uncle',
					12 << 24 | 2 => 'first cousin ten-times-removed',
					12 << 24 | 3 => 'second cousin nine-times-removed',
					12 << 24 | 4 => 'third cousin eight-times-removed',
					12 << 24 | 5 => 'fourth cousin seven-times-removed',
					13 << 24 | 1 => 'eleven times great-uncle',
					14 << 24 | 1 => 'twelve times great-uncle',
					15 << 24 | 1 => 'thirteen times great-uncle',
					16 << 24 | 1 => 'fourteen times great-uncle',
					17 << 24 | 1 => 'fifteen times great-uncle',
					18 << 24 | 1 => 'sixteen times great-uncle',
				);
				# https://www.tfcg.ca/tableau-des-liens-de-parente
				my %fr_male_relationships = (
					1 << 24 | 1 => "fr\N{U+00E8}re",
					1 << 24 | 2 => 'neveu',
					1 << 24 | 3 => 'great-nephew',
					1 << 24 | 4 => 'great-great-nephew',
					2 << 24 | 1 => 'oncle',
					2 << 24 | 2 => 'cousin germain',
					2 << 24 | 3 => 'first cousin once-removed',
					2 << 24 | 4 => 'first cousin twice-removed',
					2 << 24 | 5 => 'first cousin three-times-removed',
					3 << 24 | 1 => 'great-uncle',
					3 << 24 | 2 => 'first cousin once-removed',
					3 << 24 | 3 => 'cousin issu de germain',
					3 << 24 | 4 => 'second cousin once-removed',
					3 << 24 | 5 => "cousin issu de germains \N{U+00E9}loign\N{U+00E9} au 2e degr\N{U+00E9}",
					3 << 24 | 6 => 'second cousin three-times-removed',
					4 << 24 | 1 => 'great-great-uncle',
					4 << 24 | 2 => 'first cousin twice-removed',
					4 << 24 | 3 => 'second cousin once-removed',
					4 << 24 | 4 => 'third cousin',
					4 << 24 | 5 => 'third cousin once-removed',
					4 << 24 | 6 => 'third cousin twice-removed',
					4 << 24 | 7 => 'third cousin three-times-removed',
					5 << 24 | 1 => 'three times great-uncle',
					5 << 24 | 2 => 'first cousin three-times-removed',
					5 << 24 | 3 => "cousin issu de germains \N{U+00E9}loign\N{U+00E9} au 2e degr\N{U+00E9}",
					5 << 24 | 4 => 'third cousin once-removed',
					5 << 24 | 5 => 'fourth cousin',
					5 << 24 | 6 => "arri\N{U+00E8}re-petit-cousin \N{U+00E9}loign\N{U+00E9} au 1er degr\N{U+00E9}",
					5 << 24 | 7 => "arri\N{U+00E8}re-petit-cousin \N{U+00E9}loign\N{U+00E9} au 2e degr\N{U+00E9}",
					6 << 24 | 1 => 'four times great-uncle',
					6 << 24 | 2 => 'first cousin four-times-removed',
					6 << 24 | 3 => 'second cousin three-times-removed',
					6 << 24 | 4 => 'third cousin twice-removed',
					6 << 24 | 5 => "arri\N{U+00E8}re-petit-cousin \N{U+00E9}loign\N{U+00E9} au 1er degr\N{U+00E9}",
					6 << 24 | 6 => "arri\N{U+00E8}re-arri\N{U+00E8}re-petit-cousin",
					6 << 24 | 7 => 'fifth cousin once-removed',
					6 << 24 | 8 => 'fifth cousin twice-removed',
					7 << 24 | 1 => 'five times great-uncle',
					7 << 24 | 2 => 'first cousin five-times-removed',
					7 << 24 | 3 => 'second cousin four-times-removed',
					7 << 24 | 4 => 'third cousin three-times-removed',
					7 << 24 | 4 => "petit-cousin \N{U+00E9}loign\N{U+00E9} au 3e degr\N{U+00E9}",
					7 << 24 | 5 => "arri\N{U+00E8}re-petit-cousin \N{U+00E9}loign\N{U+00E9} au 2e degr\N{U+00E9}",
					7 << 24 | 6 => 'fifth cousin once-removed',
					7 << 24 | 7 => "sixi\N{U+00E8}me cousin",
					7 << 24 | 8 => "sixi\N{U+00E8}me cousin once-removed",
					8 << 24 | 1 => 'six times great-uncle',
					8 << 24 | 2 => 'first cousin six-times-removed',
					8 << 24 | 3 => 'second cousin five-times-removed',
					8 << 24 | 4 => 'third cousin four-times-removed',
					9 << 24 | 1 => 'seven times great-uncle',
					9 << 24 | 2 => 'first cousin seven-times-removed',
					9 << 24 | 3 => 'second cousin six-times-removed',
					9 << 24 | 4 => 'third cousin five-times-removed',
					10 << 24 | 1 => 'eight times great-uncle',
					10 << 24 | 2 => 'first cousin eight-times-removed',
					10 << 24 | 3 => 'second cousin seven-times-removed',
					10 << 24 | 4 => 'third cousin six-times-removed',
					11 << 24 | 1 => 'nine times great-uncle',
					11 << 24 | 2 => 'first cousin nine-times-removed',
					11 << 24 | 3 => 'second cousin eight-times-removed',
					11 << 24 | 4 => 'third cousin seven-times-removed',
					11 << 24 | 5 => 'fourth cousin six-times-removed',
					12 << 24 | 1 => 'ten times great-uncle',
					12 << 24 | 2 => 'first cousin ten-times-removed',
					12 << 24 | 3 => 'second cousin nine-times-removed',
					12 << 24 | 4 => 'third cousin eight-times-removed',
					12 << 24 | 5 => 'fourth cousin seven-times-removed',
					13 << 24 | 1 => 'eleven times great-uncle',
					14 << 24 | 1 => 'twelve times great-uncle',
					15 << 24 | 1 => 'thirteen times great-uncle',
					16 << 24 | 1 => 'fourteen times great-uncle',
					17 << 24 | 1 => 'fifteen times great-uncle',
					18 << 24 | 1 => 'sixteen times great-uncle',
				);
				my %de_male_relationships = (
					1 << 24 | 1 => 'Brude',
					1 << 24 | 2 => 'Neffe',
					1 << 24 | 3 => 'great-nephew',
					1 << 24 | 4 => 'great-great-nephew',
					2 << 24 | 1 => 'Onkle',
					2 << 24 | 2 => 'Cousin',
					2 << 24 | 3 => 'first cousin once-removed',
					2 << 24 | 4 => 'first cousin twice-removed',
					2 << 24 | 5 => 'first cousin three-times-removed',
					3 << 24 | 1 => 'great-uncle',
					3 << 24 | 2 => 'first cousin once-removed',
					3 << 24 | 3 => 'second cousin',
					3 << 24 | 4 => 'second cousin once-removed',
					3 << 24 | 5 => 'second cousin twice-removed',
					3 << 24 | 6 => 'second cousin three-times-removed',
					4 << 24 | 1 => 'great-great-uncle',
					4 << 24 | 2 => 'first cousin twice-removed',
					4 << 24 | 3 => 'second cousin once-removed',
					4 << 24 | 4 => 'third cousin',
					4 << 24 | 5 => 'third cousin once-removed',
					4 << 24 | 6 => 'third cousin twice-removed',
					4 << 24 | 7 => 'third cousin three-times-removed',
					5 << 24 | 1 => 'three times great-uncle',
					5 << 24 | 2 => 'first cousin three-times-removed',
					5 << 24 | 3 => 'second cousin twice-removed',
					5 << 24 | 4 => 'third cousin once-removed',
					5 << 24 | 5 => 'fourth cousin',
					5 << 24 | 6 => 'fourth cousin once-removed',
					5 << 24 | 7 => 'fourth cousin twice-removed',
					6 << 24 | 1 => 'four times great-uncle',
					6 << 24 | 2 => 'first cousin four-times-removed',
					6 << 24 | 3 => 'second cousin three-times-removed',
					6 << 24 | 4 => 'third cousin twice-removed',
					6 << 24 | 5 => 'fourth cousin once-removed',
					6 << 24 | 6 => 'fifth cousin',
					6 << 24 | 7 => 'fifth cousin once-removed',
					6 << 24 | 8 => 'fifth cousin twice-removed',
					7 << 24 | 1 => 'fifth times great-uncle',
					7 << 24 | 2 => 'first cousin five-times-removed',
					7 << 24 | 3 => 'second cousin four-times-removed',
					7 << 24 | 4 => 'third cousin three-times-removed',
					7 << 24 | 5 => 'fourth cousin twice-removed',
					7 << 24 | 6 => 'fifth cousin once-removed',
					7 << 24 | 7 => 'sixth cousin',
					7 << 24 | 8 => 'sixth cousin once-removed',
					8 << 24 | 1 => 'six times great-uncle',
					8 << 24 | 2 => 'first cousin six-times-removed',
					8 << 24 | 3 => 'second cousin five-times-removed',
					8 << 24 | 4 => 'third cousin four-times-removed',
					9 << 24 | 1 => 'seven times great-uncle',
					9 << 24 | 2 => 'first cousin seven-times-removed',
					9 << 24 | 3 => 'second cousin six-times-removed',
					9 << 24 | 4 => 'third cousin five-times-removed',
					10 << 24 | 1 => 'eight times great-uncle',
					10 << 24 | 2 => 'first cousin eight-times-removed',
					10 << 24 | 3 => 'second cousin seven-times-removed',
					10 << 24 | 4 => 'third cousin six-times-removed',
					11 << 24 | 1 => 'nine times great-uncle',
					11 << 24 | 2 => 'first cousin nine-times-removed',
					11 << 24 | 3 => 'second cousin eight-times-removed',
					11 << 24 | 4 => 'third cousin seven-times-removed',
					11 << 24 | 5 => 'fourth cousin six-times-removed',
					12 << 24 | 1 => 'ten times great-uncle',
					12 << 24 | 2 => 'first cousin ten-times-removed',
					12 << 24 | 3 => 'second cousin nine-times-removed',
					12 << 24 | 4 => 'third cousin eight-times-removed',
					12 << 24 | 5 => 'fourth cousin seven-times-removed',
					13 << 24 | 1 => 'eleven times great-uncle',
					14 << 24 | 1 => 'twelve times great-uncle',
					15 << 24 | 1 => 'thirteen times great-uncle',
					16 << 24 | 1 => 'fourteen times great-uncle',
					17 << 24 | 1 => 'fifteen times great-uncle',
					18 << 24 | 1 => 'sixteen times great-uncle',
				);
				my %en_female_relationships = (
					1 << 24 | 1 => 'sister',
					1 << 24 | 2 => 'niece',
					1 << 24 | 3 => 'great-niece',
					1 << 24 | 4 => 'great-great-niece',
					2 << 24 | 1 => 'aunt',
					2 << 24 | 2 => 'cousin',
					2 << 24 | 3 => 'first cousin once-removed',
					2 << 24 | 4 => 'first cousin twice-removed',
					2 << 24 | 5 => 'first cousin three-times-removed',
					3 << 24 | 1 => 'great-aunt',
					3 << 24 | 2 => 'first cousin once-removed',
					3 << 24 | 3 => 'second cousin',
					3 << 24 | 4 => 'second cousin once-removed',
					3 << 24 | 5 => 'second cousin twice-removed',
					3 << 24 | 6 => 'second cousin three-times-removed',
					4 << 24 | 1 => 'great-great-aunt',
					4 << 24 | 2 => 'first cousin twice-removed',
					4 << 24 | 3 => 'second cousin once-removed',
					4 << 24 | 4 => 'third cousin',
					4 << 24 | 5 => 'third cousin once-removed',
					4 << 24 | 6 => 'third cousin twice-removed',
					4 << 24 | 7 => 'third cousin three-times-removed',
					5 << 24 | 1 => 'three times great-aunt',
					5 << 24 | 2 => 'first cousin three-times-removed',
					5 << 24 | 3 => 'second cousin twice-removed',
					5 << 24 | 4 => 'third cousin once-removed',
					5 << 24 | 5 => 'fourth cousin',
					5 << 24 | 6 => 'fourth cousin once-removed',
					5 << 24 | 7 => 'fourth cousin twice-removed',
					6 << 24 | 1 => 'four times great-aunt',
					6 << 24 | 2 => 'first cousin four-times-removed',
					6 << 24 | 3 => 'second cousin three-times-removed',
					6 << 24 | 4 => 'third cousin twice-removed',
					6 << 24 | 5 => 'fourth cousin once-removed',
					6 << 24 | 6 => 'fifth cousin',
					6 << 24 | 7 => 'fifth cousin once-removed',
					6 << 24 | 8 => 'fifth cousin twice-removed',
					7 << 24 | 1 => 'five times great-aunt',
					7 << 24 | 2 => 'first cousin five-times-removed',
					7 << 24 | 3 => 'second cousin four-times-removed',
					7 << 24 | 4 => 'third cousin three-times-removed',
					7 << 24 | 5 => 'fourth cousin twice-removed',
					7 << 24 | 6 => 'fifth cousin once-removed',
					7 << 24 | 7 => 'sixth cousin',
					7 << 24 | 8 => 'sixth cousin once-removed',
					8 << 24 | 1 => 'six times great-aunt',
					8 << 24 | 2 => 'first cousin six-times-removed',
					8 << 24 | 3 => 'second cousin five-times-removed',
					8 << 24 | 4 => 'third cousin four-times-removed',
					9 << 24 | 1 => 'seven times great-aunt',
					9 << 24 | 2 => 'first cousin seven-times-removed',
					9 << 24 | 3 => 'second cousin six-times-removed',
					9 << 24 | 4 => 'third cousin five-times-removed',
					10 << 24 | 1 => 'eight times great-aunt',
					10 << 24 | 2 => 'first cousin eight-times-removed',
					10 << 24 | 3 => 'second cousin seven-times-removed',
					10 << 24 | 4 => 'third cousin six-times-removed',
					11 << 24 | 1 => 'nine times great-aunt',
					11 << 24 | 2 => 'first cousin nine-times-removed',
					11 << 24 | 3 => 'second cousin eight-times-removed',
					11 << 24 | 4 => 'third cousin seven-times-removed',
					11 << 24 | 5 => 'fourth cousin six-times-removed',
					12 << 24 | 1 => 'ten times great-aunt',
					12 << 24 | 2 => 'first cousin ten-times-removed',
					12 << 24 | 3 => 'second cousin nine-times-removed',
					12 << 24 | 4 => 'third cousin eight-times-removed',
					12 << 24 | 5 => 'fourth cousin seven-times-removed',
					13 << 24 | 1 => 'eleven times great-aunt',
					14 << 24 | 1 => 'twelve times great-aunt',
					15 << 24 | 1 => 'thirteen times great-aunt',
					16 << 24 | 1 => 'fourteen times great-aunt',
					17 << 24 | 1 => 'fifteen times great-aunt',
					18 << 24 | 1 => 'sixteen times great-aunt',
				);
				my %fr_female_relationships = (
					1 << 24 | 1 => 'sÅur',
					1 << 24 | 2 => "ni\N{U+00E8}ce",
					1 << 24 | 3 => 'great-niece',
					1 << 24 | 4 => 'great-great-niece',
					2 << 24 | 1 => 'tant',
					2 << 24 | 2 => 'cousine germaine',
					2 << 24 | 3 => 'first cousin once-removed',
					2 << 24 | 4 => 'first cousin twice-removed',
					2 << 24 | 5 => 'first cousin three-times-removed',
					3 << 24 | 1 => 'great-aunt',
					3 << 24 | 2 => 'first cousin once-removed',
					3 << 24 | 3 => 'cousine issue de germain',
					3 << 24 | 4 => 'second cousin once-removed',
					3 << 24 | 5 => "cousine issue de germains \N{U+00E9}loign\N{U+00E9}e au 2e degr\N{U+00E9}",
					3 << 24 | 6 => 'second cousin three-times-removed',
					4 << 24 | 1 => 'great-great-aunt',
					4 << 24 | 2 => 'first cousin twice-removed',
					4 << 24 | 3 => 'second cousin once-removed',
					4 << 24 | 4 => 'third cousin',
					4 << 24 | 5 => 'third cousin once-removed',
					4 << 24 | 6 => 'third cousin twice-removed',
					4 << 24 | 7 => 'third cousin three-times-removed',
					5 << 24 | 1 => 'three times great-aunt',
					5 << 24 | 2 => 'first cousin three-times-removed',
					5 << 24 | 3 => "cousine issue de germains \N{U+00E9}loign\N{U+00E9}e au 2e degr\N{U+00E9}",
					5 << 24 | 4 => 'third cousin once-removed',
					5 << 24 | 5 => 'fourth cousin',
					5 << 24 | 6 => "arri\N{U+00E8}re-petite-cousine \N{U+00E9}loign\N{U+00E9}e au 1er degr\N{U+00E9}",
					5 << 24 | 7 => "arri\N{U+00E8}re-petite-cousine \N{U+00E9}loign\N{U+00E9}e au 2e degr\N{U+00E9}",
					6 << 24 | 1 => 'four times great-aunt',
					6 << 24 | 2 => 'first cousin four-times-removed',
					6 << 24 | 3 => 'second cousin three-times-removed',
					6 << 24 | 4 => 'third cousin twice-removed',
					6 << 24 | 5 => "arri\N{U+00E8}re-petite-cousine \N{U+00E9}loign\N{U+00E9}e au 1er degr\N{U+00E9}",
					6 << 24 | 6 => "arri\N{U+00E8}re-arri\N{U+00E8}re-petite-cousine",
					6 << 24 | 7 => 'fifth cousin once-removed',
					6 << 24 | 8 => 'fifth cousin twice-removed',
					7 << 24 | 1 => 'fifth times great-aunt',
					7 << 24 | 2 => 'first cousin five-times-removed',
					7 << 24 | 3 => 'second cousin four-times-removed',
					7 << 24 | 4 => "petite-cousine \N{U+00E9}loign\N{U+00E9}e au 3e degr\N{U+00E9}",
					7 << 24 | 5 => "arri\N{U+00E8}re-petite-cousine \N{U+00E9}loign\N{U+00E9}e au 2e degr\N{U+00E9}",
					7 << 24 | 6 => 'fifth cousin once-removed',
					7 << 24 | 7 => "sixi\N{U+00E8}me cousin",
					7 << 24 | 8 => "sixi\N{U+00E8}me cousin once-removed",
					8 << 24 | 1 => 'six times great-aunt',
					8 << 24 | 2 => 'first cousin six-times-removed',
					8 << 24 | 3 => 'second cousin five-times-removed',
					8 << 24 | 4 => 'third cousin four-times-removed',
					9 << 24 | 1 => 'seven times great-aunt',
					9 << 24 | 2 => 'first cousin seven-times-removed',
					9 << 24 | 3 => 'second cousin six-times-removed',
					9 << 24 | 4 => 'third cousin five-times-removed',
					10 << 24 | 1 => 'eight times great-aunt',
					10 << 24 | 2 => 'first cousin eight-times-removed',
					10 << 24 | 3 => 'second cousin seven-times-removed',
					10 << 24 | 4 => 'third cousin six-times-removed',
					11 << 24 | 1 => 'nine times great-aunt',
					11 << 24 | 2 => 'first cousin nine-times-removed',
					11 << 24 | 3 => 'second cousin eight-times-removed',
					11 << 24 | 4 => 'third cousin seven-times-removed',
					11 << 24 | 5 => 'fourth cousin six-times-removed',
					12 << 24 | 1 => 'ten times great-aunt',
					12 << 24 | 2 => 'first cousin ten-times-removed',
					12 << 24 | 3 => 'second cousin nine-times-removed',
					12 << 24 | 4 => 'third cousin eight-times-removed',
					12 << 24 | 5 => 'fourth cousin seven-times-removed',
					13 << 24 | 1 => 'eleven times great-aunt',
					14 << 24 | 1 => 'twelve times great-aunt',
					15 << 24 | 1 => 'thirteen times great-aunt',
					16 << 24 | 1 => 'fourteen times great-aunt',
					17 << 24 | 1 => 'fifteen times great-aunt',
					18 << 24 | 1 => 'sixteen times great-aunt',
				);
				my %de_female_relationships = (
					1 << 24 | 1 => 'Schwester',
					1 << 24 | 2 => 'niece',
					1 << 24 | 3 => 'great-niece',
					1 << 24 | 4 => 'great-great-niece',
					2 << 24 | 1 => 'Tante',
					2 << 24 | 2 => 'Cousine',
					2 << 24 | 3 => 'first cousin once-removed',
					2 << 24 | 4 => 'first cousin twice-removed',
					2 << 24 | 5 => 'first cousin three-times-removed',
					3 << 24 | 1 => 'great-aunt',
					3 << 24 | 2 => 'first cousin once-removed',
					3 << 24 | 3 => 'second cousin',
					3 << 24 | 4 => 'second cousin once-removed',
					3 << 24 | 5 => 'second cousin twice-removed',
					3 << 24 | 6 => 'second cousin three-times-removed',
					4 << 24 | 1 => 'great-great-aunt',
					4 << 24 | 2 => 'first cousin twice-removed',
					4 << 24 | 3 => 'second cousin once-removed',
					4 << 24 | 4 => 'third cousin',
					4 << 24 | 5 => 'third cousin once-removed',
					4 << 24 | 6 => 'third cousin twice-removed',
					4 << 24 | 7 => 'third cousin three-times-removed',
					5 << 24 | 1 => 'three times great-aunt',
					5 << 24 | 2 => 'first cousin three-times-removed',
					5 << 24 | 3 => 'second cousin twice-removed',
					5 << 24 | 4 => 'third cousin once-removed',
					5 << 24 | 5 => 'fourth cousin',
					5 << 24 | 6 => 'fourth cousin once-removed',
					5 << 24 | 7 => 'fourth cousin twice-removed',
					6 << 24 | 1 => 'four times great-aunt',
					6 << 24 | 2 => 'first cousin four-times-removed',
					6 << 24 | 3 => 'second cousin three-times-removed',
					6 << 24 | 4 => 'third cousin twice-removed',
					6 << 24 | 5 => 'fourth cousin once-removed',
					6 << 24 | 6 => 'fifth cousin',
					6 << 24 | 7 => 'fifth cousin once-removed',
					6 << 24 | 8 => 'fifth cousin twice-removed',
					7 << 24 | 1 => 'five times great-aunt',
					7 << 24 | 2 => 'first cousin five-times-removed',
					7 << 24 | 3 => 'second cousin four-times-removed',
					7 << 24 | 4 => 'third cousin three-times-removed',
					7 << 24 | 5 => 'fourth cousin twice-removed',
					7 << 24 | 6 => 'fifth cousin once-removed',
					7 << 24 | 7 => 'sixth cousin',
					7 << 24 | 8 => 'sixth cousin once-removed',
					8 << 24 | 1 => 'six times great-aunt',
					8 << 24 | 2 => 'first cousin six-times-removed',
					8 << 24 | 3 => 'second cousin five-times-removed',
					8 << 24 | 4 => 'third cousin four-times-removed',
					9 << 24 | 1 => 'seven times great-aunt',
					9 << 24 | 2 => 'first cousin seven-times-removed',
					9 << 24 | 3 => 'second cousin six-times-removed',
					9 << 24 | 4 => 'third cousin five-times-removed',
					10 << 24 | 1 => 'eight times great-aunt',
					10 << 24 | 2 => 'first cousin eight-times-removed',
					10 << 24 | 3 => 'second cousin seven-times-removed',
					10 << 24 | 4 => 'third cousin six-times-removed',
					11 << 24 | 1 => 'nine times great-aunt',
					11 << 24 | 2 => 'first cousin nine-times-removed',
					11 << 24 | 3 => 'second cousin eight-times-removed',
					11 << 24 | 4 => 'third cousin seven-times-removed',
					11 << 24 | 5 => 'fourth cousin six-times-removed',
					12 << 24 | 1 => 'ten times great-aunt',
					12 << 24 | 2 => 'first cousin ten-times-removed',
					12 << 24 | 3 => 'second cousin nine-times-removed',
					12 << 24 | 4 => 'third cousin eight-times-removed',
					12 << 24 | 5 => 'fourth cousin seven-times-removed',
					13 << 24 | 1 => 'eleven times great-aunt',
					14 << 24 | 1 => 'twelve times great-aunt',
					15 << 24 | 1 => 'thirteen times great-aunt',
					16 << 24 | 1 => 'fourteen times great-aunt',
					17 << 24 | 1 => 'fifteen times great-aunt',
					18 << 24 | 1 => 'sixteen times great-aunt',
				);

				my $rc;
				if(defined($language) && ($language eq 'French')) {
					$rc = ($sex eq 'M') ?
						$fr_male_relationships{($steps1 << 24) | $steps2} :
						$fr_female_relationships{($steps1 << 24) | $steps2};
				} elsif(defined($language) && ($language eq 'German')) {
					$rc = ($sex eq 'M') ?
						$de_male_relationships{($steps1 << 24) | $steps2} :
						$de_female_relationships{($steps1 << 24) | $steps2};
				} else {
					$rc = ($sex eq 'M') ?
						$en_male_relationships{($steps1 << 24) | $steps2} :
						$en_female_relationships{($steps1 << 24) | $steps2};
				}
				if(defined($rc) && ($rc =~ /cousin/)) {
					my $myfather = $self->father();
					my $mymother = $self->mother();
					if($myfather && (stepsabove($myfather, $person2, 0) > 0)) {
						if($me && ($self->xref() eq $me->xref())) {
							$rc .= i18n(" on your father's side");
						} else {
							$rc .= ' on ' .
								lcfirst($self->possessive()) .
								" father's side";
						}
					} elsif($mymother && (stepsabove($mymother, $person2, 0) > 0)) {
						if($me && ($self->xref() eq $me->xref())) {
							$rc .= i18n(" on your mother's side");
						} else {
							$rc .= ' on ' .
								lcfirst($self->possessive()) .
								" mother's side";
						}
					}
				}
				if(!defined($rc)) {
					# die $other->as_string(), ": $steps1, $steps2";
					complain({ person => $other, warning => "TODO: $steps1, $steps2" });
				}
				return $rc;
			}
		}
	}
}

sub Gedcom::Individual::relationship_down
{
	my $self = shift;
	my $other = shift;
	my @descendant;

	if($me && ($self->xref() eq $me->xref())) {
		unless(@mydescendants) {
			@mydescendants = $me->descendants();
		}
		return unless scalar(@mydescendants);
		@descendant = @mydescendants;
	} else {
		@descendant = $self->descendants();
	}

	my $sex = get_value({ person => $other, value => 'sex' });
	if((!defined($sex)) || ($sex !~ /[MF]/)) {
		complain({ person => $other, warning => 'unknown sex' });
		return;
	}

	# print __LINE__, ': ', $self->as_string(), '/', $other->as_string(), "\n";
	# my $i = 0;
	# while((my @call_details = caller($i++))) {
		# print STDERR "\t", colored($call_details[2] . ' of ' . $call_details[1], 'red'), "\n";
	# }
	foreach my $person1(@descendant) {
		# print __LINE__, "\t", $person1->as_string(), "\n";
		die $person1->as_string() if($person1 eq $self);
		if($person1 eq $other) {
			# Direct descendant
			my $steps = stepsabove($other, $self, 0);
			my $title = i18n(($sex eq 'M') ? 'son' : 'daughter');
			if($steps >= 5) {
				$steps -= 2;
				return "$steps times great-grand$title";
			} elsif($steps == 1) {
				if($language eq 'French') {
					if($sex eq 'M') {
						return 'fils';
					}
				} elsif($language eq 'Farsi') {
					# return ($sex eq 'M') ? 'pesar' : 'dokhtar';
					return ($sex eq 'M') ? "\N{U+0631}\N{U+0633}\N{U+067E}" : "\N{U+0631}\N{U+062A}\N{U+062E}\N{U+062F}";
				} elsif($language eq 'Latin') {
					return ($sex eq 'M') ? 'fÄ«lius' : 'fÄ«lia';
				}
				return $title;
			} elsif($steps == 2) {
				if($language eq 'French') {
					if($sex eq 'M') {
						return 'petit-fils';
					}
				} elsif($language eq 'Latin') {
					return ($sex eq 'M') ? 'nepÅs' : 'neptis';
				}
				return "grand$title";
			} elsif($steps == 3) {
				if($language eq 'French') {
					if($sex eq 'M') {
						return "arri\N{U+00E8}re-petit-fils";
					}
				} elsif($language eq 'Latin') {
					return ($sex eq 'M') ? 'prÅnepÅs' : 'prÅneptis';
				}
				return "great-grand$title";
			} elsif($steps == 4) {
				return "great-great-grand$title";
			} elsif($steps <= 0) {
				if(my $spouse = $other->spouse()) {
					if(stepsabove($self, $spouse, 0)) {
						# The caller should now check
						# the spouse's relationship
						return;
					}
				}
				complain({ person => $other, warning => ": BUG - not a direct ancestor, steps = $steps" });
			}
		}
	}
}

sub stepsabove
{
	my $person = shift;
	my $target = shift;
	my $count = shift;

	return -1 if($count == -1);

	if(!defined($target)) {
		print STDERR "\n";
		my $i = 0;
		while((my @call_details = caller($i++))) {
			print STDERR "\t", colored($call_details[2] . ' of ' . $call_details[1], 'red'), "\n";
		}
		die 'Usage: stepsabove($person, $target, $count)';
	}

	if($person->xref() eq $target->xref()) {
		return $count;
	}

	my @father = $person->father();
	if(my $father = $father[0]) {
		my $rc = stepsabove($father, $target, $count + 1);
		return $rc if($rc != -1);
	}

	my @mother = $person->mother();
	if(my $mother = $mother[0]) {
		return stepsabove($mother, $target, $count + 1);
	}

	return -1;
}

# Returns a human readable string from a date variable, handles data verification
# and locales
sub year
{
	my %params = (ref($_[0]) eq 'HASH') ? %{$_[0]} : @_;

	my $string = $params{'string'} || $params{'date'};

	if(!defined($string)) {
		$string = $params{'record'};
		return unless($string);

		if(ref($string) eq 'Gedcom::Record') {
			$string = $string->date();
			return unless($string);
			$string =~ s/\s+$//;
		}
	}

	if($string =~ /^\d{3,4}$/) {
		if($language eq 'French') {
			return "en $string";
		}
		return "in $string";
	}
	if($string =~ /^(Abt|ca?)\.?\s*(.+)/i) {
		my $rc = $2;
		if($opts{'w'}) {
			if(my $must_postdate = $params{'must_postdate'}) {
				my $dt;
				if($rc !~ /^\d/) {
					$dt = date_to_datetime("1 $rc");
				} else {
					$dt = date_to_datetime($rc);
				}
				if($dt && ($dt < $must_postdate)) {
					complain({ person => $params{'person'}, warning => "Something is wrong with the date $string which should be after $must_postdate" });
				}
			}
			if(my $must_predate = $params{'must_predate'}) {
				my $dt;
				if($rc !~ /^\d/) {
					$dt = date_to_datetime("1 $rc");
				} else {
					$dt = date_to_datetime($rc);
				}
				if($dt && ($dt > $must_predate)) {
					complain({ person => $params{'person'}, warning => "Something is wrong with the date $string which should be before $must_predate" });
				}
			}
		}
		if(!defined($params{'circa'})) {
			$params{'circa'} //= 'c.';
		}
		if($language ne 'English') {
			my $d = $date_parser->parse(date => $rc);
			if($d && (ref($d) eq 'ARRAY')) {
				$d = $d->[0];
			}
			$d = $dfn->parse_datetime($d->{'canonical'});
			if($ENV{'LC_TIME'}) {
				$d->set_locale($ENV{'LC_TIME'});
			} elsif($ENV{'LC_ALL'}) {
				$d->set_locale($ENV{'LC_ALL'});
			} elsif($ENV{'LANG'}) {
				$d->set_locale($ENV{'LANG'});
			}
			return $params{'circa'} . ' ' . $d->strftime('%b %Y');
		}
		return $params{'circa'} . " $rc";
	}

	if($string =~ /^\s*(.+\d\d)\s*\-\s*(.+\d\d)\s*$/) {
		my $start = $1;
		my $end = $2;
		if($end !~ /^\d\d\-\d\d$/) {
			complain({ warning => "Changing date '$string' to 'bet $start and $end'" });
			$string = "bet $start and $end";
		}
	}

	if(($string =~ /^bet (.+) and (.+)/i) ||
	   ($string =~ /^Fro?m (.+) to (.+)/i)) {
		my $from = year({ %params, string => $1 });
		my $to = year({ %params, string => $2 });

		if($language eq 'French') {
			$from =~ s/^(en|c.) //;
			$to =~ s/^(en|c.) //;
			if($from =~ /^le (.+)/) {
				$from = "du $1";
			} else {
				$from = "de $from";
			}
			if($to =~ /^le (.+)/) {
				$to = "au $1";
			} else {
				$to = "\N{U+00E0} $to";
			}
			return "$from $to";
		}
		$from =~ s/^(in|on|c.) //;
		$to =~ s/^(in|on|c.) //;
		if($language eq 'German') {
			return "von $from bis $to";
		}
		return "from $from to $to";
	}

	if($string =~ /(.+)\s(\d{4})\/\d{2}/) {
		my $year = $2 + 1;
		complain({ person => $params{'person'}, warning => "old-style date ($string) should be in $year" });
		$string = "$1 $year";
	}

	if(($string =~ /^\d/) && ($string !~ /[a-z]$/i)) {
		# Precise date
		my $person = $params{'person'};
		if($string =~ /^31 Nov/) {
			complain({ person => $person, warning => "$string is invalid, there are only 30 days in November" });
			return;
		}
		if(my $d = date_parser_cached(date => $string)) {
			$d = $dfn->parse_datetime($d->{'canonical'});
			if(my $must_postdate = $params{'must_postdate'}) {
				complain({
					person => $person,
					warning => [ "Something is wrong with the date $string which should be after ", $must_postdate->strftime('%x') ],
					# stack_trace => 1,
				}) if($d < $must_postdate);
			}
			if(my $must_predate = $params{'must_predate'}) {
				complain({ person => $person, warning => "Something is wrong with the date $string which should be before " . $must_predate->strftime('%x') }) if($d > $must_predate);
			}
			if($ENV{'LC_TIME'}) {
				$d->set_locale($ENV{'LC_TIME'});
			} elsif($ENV{'LC_ALL'}) {
				$d->set_locale($ENV{'LC_ALL'});
			} elsif($ENV{'LANG'}) {
				$d->set_locale($ENV{'LANG'});
			}
			if($language eq 'French') {
				my $year = $d->strftime('%x');
				if($year =~ /^[AEIOU]/) {
					return "l'$year";
				}
				return "le $year";
			}
			my $year;
			if($language eq 'Farsi') {	# For Tulip
				$year = HTML::Entities::decode(Lingua::FA::Number::convert($d->strftime('%Y %b %e')));
			} else {
				$year = $d->strftime('%x');
			}
			return "on $year";
		}
		if($@) {
			# RT 107354
			chomp $@;
			if($opts{'f'}) {
				if($person) {
					die $person->as_string(), ": $@";
				}
				die $@;
			}
			if($opts{'w'}) {
				red_warning({ person => $person, warning => $@ });
			}
		}
		if($language eq 'French') {
			return "en $string";
		}
		return "on $string";
	}
	if($string =~ /^bef.*\s+(\d{3,4})/i) {
		if($string !~ /^bef.? (\d{3,4})/i) {
			if(my $person = $params{'person'}) {
				complain({ person => $person, warning => "Date '$string' should start with 'Bef'" });
			} else {
				complain("Date '$string' should start with 'Bef'");
			}
		}
		if($language eq 'French') {
			return "avant $1";
		}
		return "before $1";
	}
	if($string =~ /^by.? (\d{3,4})/i) {
		return "by $1";
	}
	if($string =~ /^By (\d{3,4})/i) {
		if(my $person = $params{'person'}) {
			complain({ person => $person, warning => "says 'By' instead of 'Bef'" });
		} else {
			complain("says 'By' instead of 'Bef'");
		}
		if($language eq 'French') {
			return "avant $1";
		}
		return "before $1";
	}
	if($string =~ /^aft.? (\d{3,4})/i) {
		return i18n({ format => 'after %s', args => $1 });
	}

	if($params{'nopreposition'}) {
		return $string;
	}
	if($string =~ /^bef\s(.+)/i) {
		return i18n({ format => 'before %s', args => $1 });
	}
	if($string =~ /^aft\s(.+)/i) {
		my $rc = i18n({ format => 'after %s', args => $1 });
		if(my $d = date_parser_cached(date => $1)) {
			$d = $dfn->parse_datetime($d->{'canonical'});
			if($ENV{'LC_TIME'}) {
				$d->set_locale($ENV{'LC_TIME'});
			} elsif($ENV{'LC_ALL'}) {
				$d->set_locale($ENV{'LC_ALL'});
			} elsif($ENV{'LANG'}) {
				$d->set_locale($ENV{'LANG'});
			}
			return i18n({ format => 'after %s', args => $d->strftime('%x') });
		}
		return $rc;
	}
	if($language eq 'French') {
		if($string =~ /^[AEIOU]/) {
			return "l'$string";
		}
		return ($string =~ /\d$/) ? "en $string" : "le $string";
	}
	if(defined($ENV{'LANG'}) && ($ENV{'LANG'} =~ /^en_US/)) {
		$string = ucfirst(lc($string));	# Starts with a month name so it's easily capitalised
	}
	return ($string =~ /\d$/) ? "in $string" : "on $string";
}

sub place {
	my %params = (ref($_[0]) eq 'HASH') ? %{$_[0]} : @_;

	return if($opts{'O'});

	my $place = $params{'place'};
	my $address = $params{'address'};

	# if(!defined($params{'encode'})) {
		# $params{'encode'} = 1;
	# }
	$params{'encode'} = 0;

	if(!defined($place)) {
		$place = $params{'record'};
		return unless($place);

		if(ref($place) eq 'Gedcom::Record') {
			my $p = $place;
			$address = $place->address();
			if(ref($address) eq 'Gedcom::Record') {
				$place = getaddress($address);
				$address = undef;
			} else {
				$place = $place->place();
			}
			if(!defined($place)) {
				if($opts{'w'} && (!$params{'allow_empty'}) && $params{'record'}->type() && ($params{'record'}->type() ne 'Story')) {
					if(my $date = $p->date()) {
						if($date =~ /^bet\s*(.+)/i) {
							complain({ person => $params{'person'}, warning => "Location for the event between $1 is empty" });
						} else {
							complain({ person => $params{'person'}, warning => 'Location for "' . lcfirst($params{'record'}->type()) . "\" on $date is empty" });
						}
					} else {
						complain({ person => $params{'person'}, warning => 'Location is empty' });
					}
				}
				return;
			}
		}
	} elsif(ref($address)) {
		$place = getaddress($address);
		$address = undef;
	}

	$place =~ s/\.$//;

	return if(lc($place) eq 'unknown');

	# if((!defined($address)) &&
	   # ($place !~ /USA$/) && ($place !~ /United States$/) &&
	   # ($place =~ /(.+),\s*(.+,\s*.+,\s*.+)$/)) {
		# $address = $1;
		# $place = $2;
	# }

	# Google maps (and possibly others) sometimes works better with full names
	my $on_road;
	if($address) {
		$address =~ s/\xc3\xb1/\N{U+00F1}/g;	# Ã±
		$address =~ s/\xc3\xa9/\N{U+00E9}/g;	# Ã©
		if($address =~ /(.+)\sSt\.?$/) {
			$address = "$1 Street";
			$on_road = 1;
		} elsif($address =~ /(.+)\sAve\.?$/) {
			$address = "$1 Avenue";
			$on_road = 1;
		} elsif($address =~ /(.+)\sRd\.?$/) {
			$address = "$1 Road";
			$on_road = 1;
		} elsif($address =~ /(.+)\sLn\.?$/) {
			$address = "$1 Lane";
			$on_road = 1;
		} elsif($address =~ /\sLane$/) {
			$on_road = 1;
		}
		if($address =~ / Church, /) {
			$on_road = 0;
		}
	}

	my $there = $params{'there'};

	if($there && ($place eq $there)) {
		if($address) {
			if($place =~ /^(.+?),.+,/) {
				if($params{'nopreposition'}) {
					return " $address, $1";
				}
				if($language eq 'French') {
					return " \N{U+00E0} $address, $1";
				}
				return " at $address, $1";
			}
		} else {
			return ' there';
		}
	}

	# The more consistent the data, the fewer lookups on Geocoders and the smoother the English output
	my $rc = Lingua::String->new('en' => $place);
	my $lang = get_language_code() // 'en';
	if($lang ne 'en') {
		$rc->set({ lang => $lang, string => $place });
	}
	# $place =~ s/\xc3\xa9/Ã©/g;
	$place =~ s/\xc3\xa9/\N{U+00E9}/g;
	$place =~ s/\xc3\xb1/\N{U+00F1}/g;	# Ã±

	if(($place =~ /(.+?)\s*United States$/i) || ($place =~ /(.+?)\s*United States of America$/i)) {
		$place = "$1 USA";
	} elsif($place =~ /States\s.*$/) {
		complain({ person => $params{'person'}, warning => "Unexpected text at the end of the place '$place'" });
	} elsif($place =~ /(.*)(^|,\s*)(.+),\s*Canada$/i) {
		my $town = $1;
		my $province = $3;

		$rc->en($place);

		if(defined(my $p = $ca_en->{province2code}{uc($province)} || $ca_fr->{province2code}{uc($province)})) {
			my $ca;
			if($language eq 'French') {
				$ca = $ca_fr;
			} else {
				$ca = $ca_en;
			}
			if($p eq 'QC') {
				if($language eq 'French') {
					$p = "Qu\N{U+00E9}bec";
					if($town eq 'MontrÃ©al') {
						$town = "Montr\N{U+00E9}al";
					}
					$rc->fr("$town, Qu\N{U+00E9}bec, Canada");
				} else {
					$p = 'Quebec';
					if($town eq 'MontrÃ©al') {
						$town = 'Montreal';
					}
					$rc->en("$town, Quebec, Canada");
				}
			} else {
				$p = sortoutcase($ca->{code2province}{$p});
			}
			if(defined($town) && length($town)) {
				$place = "$town, $p, Canada";
			} else {
				$place = "$p, Canada";
			}
			$rc->set({ lang => $lang, string => $place });
		} elsif($province =~ /^Qu.+bec$/) {
			if($language eq 'French') {
				$province = "Qu\N{U+00E9}bec";
				if($town eq 'MontrÃ©al') {
					$town = "Montr\N{U+00E9}al";
				}
				$rc->fr("$town, Qu\N{U+00E9}bec, Canada");
			} else {
				$province = 'Quebec';
				if(($town eq 'MontrÃ©al') || ($town eq "Montr\N{U+00E9}al")) {
					$town = 'Montreal';
				}
				$rc->en("$town, Quebec, Canada");
			}
			if(defined($town) && length($town)) {
				$place = "$town, $province, Canada";
			} else {
				$place = "$province, Canada";
			}
			$rc->set({ lang => $lang, string => $place });
		} else {
			complain({ person => $params{'person'}, warning => "Unknown Canadian province $province" });
		}
	} elsif($place =~ /(.*)(^|,\s*.+),\s*(UK|England|Wales|Scotland)$/i) {
		# Translate the city from English
		# TODO: if language eq English, translate a city to English
		if($language ne 'English') {
			# if($language ne 'French') {
				# die "TODO: add language $language";
			# }
			# FIXME: should be table driven
			$rc->en($place);
			if(my $t = $places->translate({ place => $1, from => 'en', to => $lang })) {
				$place = "$t$2, $3";
				$rc->set(lang => $lang, string => $place);
			}
		}
	}

	if($params{'person'}) {
		validate_place({ person => $params{'person'}, place => $rc });
	}

	if($birth_country && (!$opts{'r'}) && ($place =~ /(.+),\s*\Q$birth_country\E$/i)) {
		$place = $1;
	}

	# utf8::decode($place);
	if($place =~ /,,/) {
		complain({ person => $params{'person'}, warning => "Consecutive commas found in '$place'" });
		$place =~ s/,,/,/g;
		$place =~ s/,(\S)/, $1/g;
	}
	if($place =~ /,(\S)/) {
		complain({ person => $params{'person'}, warning => "Space missing after comma in '$place'" });
		$place =~ s/,(\S)/, $1/g;
	}

	if((!$opts{'r'}) && ($place =~ /^\d/)) {
		if(my $places_printed = $params{'places_printed'}) {
			$places_printed->{" at$place"} = 1;
			if($place =~ /(.+),(.+?),(.+?),(.+?),(.+?)$/) {
				if($places_printed->{" in$3,$4,$5"}) {
					$places_printed->{"at $1,$2,$3"} = 1;
					if($params{'nopreposition'}) {
						return "$1,$2,$3";
					}
					if($language eq 'French') {
						return " \N{U+00E0} $1,$2,$3";
					}
					return " at $1,$2,$3";
				}
			}
			if($place =~ /(.+),(.+?),(.+?),(.+?)$/) {
				$places_printed->{" in$2,$3,$4"} = 1;
			}
		}
		if($language eq 'French') {
			return " \N{U+00E0} $place";
		}
		if($params{'nopreposition'}) {
			return " $place";
		}
		return " at $place";
	}

	if($place eq 'USA') {
		if($language eq 'French') {
			if($params{'nopreposition'}) {
				return " \N{U+00C9}tats-Unis";
			}
			return " aux \N{U+00C9}tats-Unis";
		}
		if($language eq 'German') {
			if($params{'nopreposition'}) {
				return ' der Vereinigten Staaten';
			}
			return ' in den Vereinigten Staaten';
		}
		if($params{'nopreposition'}) {
			return ' USA';
		}
		return ' in the USA';
	}

	if($address) {
		# utf8::decode($address);
		if($params{'nopreposition'}) {
			$place = " $address, $place";
			$rc->en(" $address, " . $rc->en());
		} elsif($language eq 'French') {
			$place = " \N{U+00E0} $address, $place";
			$rc->fr($place);
			$rc->en("$address, " . $rc->en());
		} elsif($on_road && ($address =~ /^[a-z]+\s+.*[a-z]+$/i)) {
			# e.g on Appleby Street
			$place = " on $address, $place";
		} else {
			$place = " at $address, $place";
		}
	} elsif($params{'nopreposition'}) {
		$place = " $place";
	} elsif($place =~ /^Isle of /) {
		$place = " on the $place";
	} elsif(($language eq 'French') && ($place =~ /,/)) {
		$place = " \N{U+00E0} $place";
	} else {
		$place = " in $place";
	}
	$rc->set({ lang => $lang, string => $place });

	if((!$opts{'r'}) && (my $places_printed = $params{'places_printed'})) {
		if(($language eq 'French') && ($place =~ /(.+), London, England/)) {
			$place = "$1, Londres, Angleterre";
			$rc->fr($place);
		}
		if($places_printed->{$place} && ($place =~ /^(.+?),/)) {
			# Only print the town if the location has already been printed
			return $1;
		}
		if($place =~ /(.+),(.+?),(.+?),(.+?)$/) {
			my $str = "$2,$3,$4";
			if($params{'person'} && $address) {
				validate_place({ person => $params{'person'}, place => $place });
			}
			if($places_printed->{" in$str"}) {
				if(($4 eq ' USA') || ($4 eq ' Canada')) {
					return "$1,$3";
				}
				my $road = $1;
				my $town = $2;
				my $country = $4;
				if(($town !~ /,/) || !defined($address)) {
					if($language eq 'French') {
						return "$road \N{U+00E0}$town";
					}
					# Avoid "in in Paris"
					$road =~ s/^\s*in//;
					$road =~ s/\s+$//;
					$town =~ s/\s+$//;
					if(($road eq '') && ($town eq '')) {
						return "in$country";
					}
					return "$road in$town";
				}
				return $address;
			}
			if($places_printed->{" at$str"}) {
				return "$1,$2";
			}
			$str = "$3,$4";
			if($places_printed->{" in$str"} || $places_printed->{" at$str"}) {
				if($params{'encode'}) {
					return wide_to_html("$1,$2,$3");
				}
				return "$1,$2,$3";
			}
			$places_printed->{" in$str"} = 1;
			$places_printed->{" in$2,$3,$4"} = 1;
		} elsif($place =~ /(.+),(.+),(.+)$/) {
			# e.g. Southwark, London, England
			if($places_printed->{" in$2,$3"}) {
				# We did place, county, country before, so just
				# return place, county
				if(($language eq 'French') && ("$2,$3" eq ' London, England')) {
					$rc->fr("$1, Londres");
				} else {
					$rc->fr("$1,$2");
				}
				if($params{'encode'}) {
					$rc->encode();
				}
				return $rc;
			}
			$places_printed->{" in$2,$3"} = 1;
		}
		$places_printed->{$place} = 1;
	}

	if($lcm) {
		$rc->set({ lang => $lang, string => $place });
		if($place =~ /(.*),\s+([A-Z\s]+)$/i) {
			my $c = $2;
			if($c eq 'USA' || ($c eq 'US')) {
				$c = 'United States';
			}
			if(($language eq 'French') && ($c eq 'England')) {
				$rc->fr("$1, Angleterre");
			} elsif(($language eq 'French') && ($c eq 'France')) {
				$place =~ s/Normandy,/Normandie,/;
				$rc->fr($place);
			} elsif(($language eq 'English') && ($c eq 'France')) {
				$place =~ s/Normandie,/Normandy,/;
				$rc->en($place);
			} elsif(($language eq 'French') && ($c eq 'Scotland')) {
				$rc->fr("$1, Ecosse");
			} elsif(($language eq 'French') && ($c eq 'Wales')) {
				$rc->fr("$1, Pays de Galles");
			} elsif(($language eq 'Welsh') && ($c eq 'Wales')) {
				my $town = $1;
				$town =~ s/Swansea$/Abertawe/;
				$rc->cy("$town, Cymru");
			} elsif(my $code = $lcm->country2code($c, 'LOCALE_CODE_ALPHA_2', 'en')) {
				# Translate the name of the country into the current locale
				$c = $lcm->code2country($code, $lang);
				if($c ne 'United States') {
					# utf8::decode($c);
					my $place = $1;
					$c =~ s/Ã/\N{U+00C9}/g;
					$rc->set({ lang => $lang, string => "$place, $c" });
				}
			}
		} elsif($place !~ /,/ && ($language ne 'English')) {
			$rc->en($place);
			my $en = $place;
			$en =~ s/^ in //;
			if(my $code = $lcm->country2code($en, 'LOCALE_CODE_ALPHA_2', 'en')) {
				$place = $lcm->code2country($code, $lang);
				if(!$params{'nopreposition'}) {
					if($language eq 'French') {
						my $preposition;
						if($place =~ /e$/) {
							# TODO: others https://yolainebodin.com/the-language-nook/french/gender-of-countries-in-french
							if($place eq 'Mexique') {
								$preposition = 'au';
							} else {
								$preposition = 'en';
							}
						} else {
							if($place =~ /^[aeiou]/) {
								$preposition = 'en';
							} else {
								$preposition = 'au';
							}
						}
						# utf8::decode($place);
						$place = " $preposition $place";
					}
				}
				$rc->set({ lang => $lang, string => $place });
			}
		}
	}

	if($params{'encode'}) {
		$rc->encode();
	}

	return $rc;
}

sub getaddress {
	my $address = shift;

	my $rc;

	if(my $city = $address->city()) {
		$rc = $city;
	}
	if(my $state = $address->state()) {
		if($rc) {
			$rc .= ', ';
		}
		$rc .= $state;
	}
	if(my $country = $address->country()) {
		if($rc) {
			$rc .= ', ';
		}
		$rc .= $country;
	}

	return $rc;
}

# paragraph => 1: ignore spacing and put it all into one paragraph
sub notes {
	my %params = (ref($_[0]) eq 'HASH') ? %{$_[0]} : @_;

	my $record = $params{'record'};
	if(!$record) {
		print STDERR "\n";
		my $i = 0;
		while((my @call_details = caller($i++))) {
			print STDERR "\t", colored($call_details[2] . ' of ' . $call_details[1], 'red'), "\n";
		}
		die 'Usage: notes(record => $record)';
	}

	my $paragraph = $params{'paragraph'};
	my @notes = $record->get_record('note');

	# my @deathnotes = get_value({ person => $person, value => 'death note' });
	my $rc = $record->get_value();
	$rc = undef if(defined($rc) && (lc($rc) eq 'was recorded at this address'));
	$rc .= '.' if($rc && !scalar(@notes));

	foreach my $note(@notes) {
		if($note) {
			if(ref($note) eq 'Gedcom::Record') {
				$note = $note->full_value();	# Include CONC records

				# Handle linked notes
				# https://github.com/nigelhorne/ged2site/issues/114
				if(my $n = $ged->resolve_xref($note)) {
					$note = $n->full_value();
				}
			} else {
				complain("Note record is just description ($note), information may have been lost");
			}
			$note =~ s/\r//g;
			next if($note =~ /^\s*$/);
			$note =~ s/\s\s+/ /g;
			if($paragraph) {
				$note =~ s/\n+/\n\t/g;
			} else {
				$note =~ s/\n+/; /g;
			}
			$note =~ s/\s+$//g;
			$note =~ s/\. /.  /g;
			$note =~ s/Dr\.\s\s/Dr. /g;
			$note =~ s/Mr\.\s\s/Mr. /g;
			$note =~ s/Mrs\.\s\s/Mrs. /g;
			$note =~ s/Rev\.\s\s/Rev. /g;
			$note =~ s/St\.\s\s/St. /g;
			$note =~ s/([A-Z]\.\s)\s/$1/g;

			# FIXME: a lot of duplicated code here
			if(defined($rc)) {
				if($rc ne $note) {
					$rc =~ s/\s$//g;
					if($paragraph) {
						if($rc) {
							$rc =~ s/\.$//;
							$rc .= ".\n";
						}
						if($opts{'B'}) {
							$rc .= '    ';
						} else {
							$rc .= "\t";
						}
					} elsif($rc) {
						$rc =~ s/\.$//;
						$rc .= '; ';
					}
					$rc .= $note;
					$rc .= '.' if($note !~ /\."?$/);
				} else {
					# complain("Note record ($note) is the same as the description");
				}
			} else {
				if($paragraph) {
					if($opts{'B'}) {
						$rc = "    $note";
					} else {
						$rc = "\t$note";
					}
				} else {
					$rc = $note;
				}
			}
		} else {
			complain('Notes field is empty');
		}
	}
	if((!defined($rc)) || (length($rc) == 0)) {
		return;
	}
	$rc =~ s/([\.:]); /$1  /g;
	$rc =~ s/\s+$//;
	$rc =~ s/\xe2\x80\x9c/"/g;	# left quotation
	$rc =~ s/\xe2\x80\x9d/"/g;	# right quotation
	$rc =~ s/\x80"/"/g;
	$rc =~ s/\xe2\x80\x99/'/g;
	$rc =~ s/[\x93\x94]/"/g;
	$rc =~ s/[\x91\x92]/'/g;
	$rc =~ s/[\xc2\xe2]//g;

	if($language eq 'English') {
		if($ENV{'LANG'} =~ /^en_US/) {
			$rc = Lingua::EN::ABC::b2a($rc);
		} elsif($ENV{'LANG'} =~ /^en_CA/) {
			$rc = Lingua::EN::ABC::b2c($rc);
		} else {
			$rc = Lingua::EN::ABC::a2b($rc);
		}
	}

	# my $region;

	# if($record) {
		# $region = $record->place();
	# }
	# if(!$region && (my $person = $params{'person'})) {
		# $region = get_value({ person => $person, value => 'birth place' });
		# if(!$region) {
			# $region = get_value({ person => $person, value => 'death place' });
		# }
	# }
	# if($region && ($region =~ /^.+,\s([[a-z\s]+)$/i)) {
		# if($1 =~ /(England|United Kingdom)/i) {
			# $region = 'gb';
		# } elsif($1 =~ /(USA|US|United States)/i) {
			# $region = 'us';
		# } elsif(lc($1) eq 'Canada') {
			# $region = 'ca';
		# }
	# }

	# my @call_details = caller(0);
	# print 'line ', $call_details[2], ">>>>$region\n";
	# foreach my $k(keys %params) {
		# print "\t$k\n";
	# }
	# if(($rc !~ /^was /i) && (my @hr = $textgeocoder->geocode(scantext => $rc, region => $region))) {
		# print STDERR Data::Dumper->new([\@hr])->Dump();
	# }
	return $rc;
}

sub validate_place
{
	my %params = (ref($_[0]) eq 'HASH') ? %{$_[0]} : @_;

	my $place = $params{'place'};
	if(!$place) {
		print STDERR "\n";
		my $i = 0;
		while((my @call_details = caller($i++))) {
			print STDERR "\t", colored($call_details[2] . ' of ' . $call_details[1], 'red'), "\n";
		}
		die 'place is not optional';
	}

	$place =~ s/^\s+//;
	if($language eq 'French') {
		$place =~ s/^\N{U+00E0}\s+//;
	} else {
		$place =~ s/^at\s+//;
	}
	if(defined($places{$place})) {
		return $places{$place};
	}

	# US and Canada are more logical, using city,county,state,country, than other countries
	if($opts{'w'} && (($place !~ /,.*,.*,.*/) || ($place =~ /USA|Canada/i))) {
		if($place =~ /(.*),\s*Independent Cities\s*(.*)/i) {
			$place = "$1$2";
		}
		$place =~ s/^(in|at)\s//;
		if(defined($places{$place})) {
			return $places{$place};
		}
		# my $ap;
		# my $p = $place;
		# if(($place =~ /USA$/) || ($place =~ /United States$/)) {
			# $ap = Lingua::EN::AddressParse->new(country => 'US', auto_clean => 1, force_case => 1, force_post_code_flag => 0);
		# } elsif($place =~ /England$/) {
			# $ap = Lingua::EN::AddressParse->new(country => 'GB', auto_clean => 1, force_case => 1, force_post_code_flag => 0);
			# $p .= ', United Kingdom';
		# }
		# if($ap) {
			# my $error = $ap->parse("$address, $p");
			# print $ap->report();
		# }

		# if(($place =~ /USA$/) || ($place =~ /United States$/)) {
			# if(my $href = Geo::StreetAddress::US->parse_location($place)) {
				# if($href->{'state'} && !$us->{code2state}{$href->{'state'}} && !$us->{state2code}{$href->{'state'}}) {
				# die $href->{'state'};
					# complain({ person => $params{'person'}, warning => "Unknown state in $place" });
				# }
			# }
		# }
		if((($place =~ /USA$/) || ($place =~ /United States$/) || ($place =~ /U\.S\.A\./)) &&
		    ($place =~ /^.+,\s*([\w\s]+),[\w\s]+$/)) {
			my $state = uc($1);
			if((!$us->{code2state}{$state}) && !$us->{state2code}{$state}) {
				complain({ person => $params{'person'}, warning => "Unknown state '$state' in $place" });
			} elsif($place =~ /\sWard \d+,/) {
				complain({ person => $params{'person'}, warning => "Census ward number left in location '$place'" });
			}
		}

		if($opts{'w'}) {
			# Strange locations in censuses
			if($place =~ /Royal Navy/) {
				return 0;
			}
			print "Look up location $place\n", if($opts{'v'});
			# Force wantarray for improved caching in
			# G:C:L
			if(($place eq 'England') || ($place eq 'Scotland')) {
				$place = 'United Kingdom';
			} elsif($place eq 'U.S.A.') {
				$place = 'USA';
			}
			# my @locations = $geocoder->geocode($place);
			my @locations = get_location($place);
			if(scalar(@locations) == 0) {
				# Don't die because there are many
				# false positives as locations
				# may no longer exist
				if(my $person = $params{'person'}) {
					if($opts{'W'}) {
						print STDERR $person->as_string({ include_years => 1 }), ": unknown location '$place'\n";
					} else {
						my @call_details = caller(0);
						warn colored($person->as_string({ include_years => 1 }) . ": unknown location '$place' at line " . $call_details[2], 'red');
					}
				} else {
					if($opts{'W'}) {
						print STDERR "Unknown location $place\n";
					} else {
						warn colored("Unknown location $place", 'red');
					}
				}
				$places{$place} = 0;
				return 0;
			} elsif(($place !~ /,/) && !Locale::Country::country2code($place)) {
				if(my $person = $params{'person'}) {
					complain({ person => $person, warning => "Country not included in country, or misspelt country '$place'" });
				} else {
					complain("Country not included in country, or misspelt country '$place'");
				}
				$places{$place} = 0;
				return 0;
			}
		}
	}
	$places{$place} = 1;
	return 1;
}

# Are two places the same? exact => 1 means must be equal, otherwise use fuzzy logic
sub places_are_the_same
{
	my %params = (ref($_[0]) eq 'HASH') ? %{$_[0]} : @_;

	my $record1 = $params{'first'};
	my $record2 = $params{'second'};

	die 'first is not optional' unless $record1;
	die 'second is not optional' unless $record2;

	if((!ref($record1)) && (!ref($record2))) {
		return $record1 eq $record2;
	}

	my $place1 = $record1->place();
	return 0 unless(defined($place1));
	my $place2 = $record2->place();
	return 0 unless(defined($place2));

	my $person = $params{'person'};
	if($person) {
		validate_place({ person => $person, place => $place1 });
		validate_place({ person => $person, place => $place2 }) unless(lc($place1) eq lc($place2));
	}

	if($place1 =~ /(.+?)\s*United States$/i) {
		$place1 = "$1 USA";
	}
	if(my $address = $record1->address()) {
		$place1 = $abbr->normalize($address) . ", $place1";
	}
	if(my $address = $record2->address()) {
		$place2 = $abbr->normalize($address) . ", $place2";
	}

	if($place2 =~ /(.+?)\s*United States$/i) {
		if($person) {
			complain({ person => $person, warning => "Changing 'United States' to 'USA' in $place2" });
		} else {
			complain("Changing 'United States' to 'USA' in $place2");
		}
		$place2 = "$1 USA";
	}
	# if($place2 =~ /(.+)\sSt\.?$/) {
		# if($person) {
			# complain({ person => $person, warning => "Changing 'St' to 'Street' in $place2" });
		# } else {
			# complain("Changing 'St' to 'Street' in $place2");
		# }
		# $place2 = "$1 Street";
	# } elsif($place2 =~ /(.+)\sAve\.?$/) {
		# if($person) {
			# complain({ person => $person, warning => "Changing 'Ave' to 'Avenue' in $place2" });
		# } else {
			# complain("Changing 'Ave' to 'Avenue' in $place2");
		# }
		# $place2 = "$1 Avenue";
	# } elsif($place2 =~ /(.+)\sRd\.?$/) {
		# if($person) {
			# complain({ person => $person, warning => "Changing 'Rd' to 'Road' in $place2" });
		# } else {
			# complain("Changing 'Rd' to 'Road' in $place2");
		# }
		# $place2 = "$1 Road";
	# }
	return 1 if(lc($place1) eq lc($place2));
	return 1 if(place(record => $record1) eq place(record => $record2));
	return 0 if($params{'exact'});
	if(compare($place1, $place2) > 0.5) {
		if($person) {
			complain({ $person => $person, warning => "The places '$place1' and '$place2' seem similar; is there a typo?" });
		} else {
			complain("The places '$place1' and '$place2' seem similar; is there a typo?");
		}
	}
	return 0;
}

sub sibling_baptism_string
{
	my %params = (ref($_[0]) eq 'HASH') ? %{$_[0]} : @_;

	my $person = $params{'person'};
	my $siblings = $params{'siblings'};
	my $date = $params{'date'};
	my $birthdate = $params{'birthdate'};

	return '' if(scalar(@{$siblings}) == 0);

	my @onsameday;
	foreach my $sibling(@{$siblings}) {
		my $dateofsiblingbaptism = get_value({ person => $sibling, value => 'baptism date' });
		if($dateofsiblingbaptism && ($dateofsiblingbaptism eq $date)) {
			push @onsameday, $sibling;
		}
	}
	return '' if(scalar(@onsameday) == 0);

	my $allsamesex = 1;
	if(scalar(@onsameday) > 1) {
		foreach my $sibling(@onsameday) {
			if($sibling->sex() ne $person->sex()) {
				$allsamesex = 0;
				last;
			}
		}
		if($allsamesex) {
			foreach my $sibling(@onsameday) {
				my $dateofsiblingbirth = dateofbirth($sibling);
				if($dateofsiblingbirth && $birthdate && ($dateofsiblingbirth eq $birthdate)) {
					$allsamesex = 0;	# Fudge to force special twin handler
				}
			}
		}
	} else {
		$allsamesex = 0;
	}

	if($allsamesex) {
		return ', ' . i18n('the same day as ') . lcfirst($person->possessive()) . ' ' .
			i18n(($onsameday[0]->sex() eq 'M' ? 'brothers ' : 'sisters ')) .
			conjunction(map { $_->given_names() } @onsameday);
	}

	my @baptisms;
	foreach my $sibling(@onsameday) {
		my $baptism;

		if($language eq 'French') {
			$baptism = ($sibling->sex() eq 'F') ? 'sa ' : 'son ';
		} else {
			$baptism = lcfirst($person->possessive()) . ' ';
		}

		my $dateofsiblingbirth = dateofbirth($sibling);
		if($dateofsiblingbirth && $birthdate && ($dateofsiblingbirth eq $birthdate)) {
			if($language eq 'French') {
				$baptism .= ($sibling->sex() eq 'F') ? 'jumelle ' : 'jumeau ';
			} else {
				$baptism .= 'twin ';
			}
		}
		$baptism .= i18n(($sibling->sex() eq 'M' ? 'brother ' : 'sister ')) .
			$sibling->given_names();
		push @baptisms, $baptism;
	}
	return ', ' . i18n('the same day as ') . conjunction(@baptisms);
}

sub complain
{
	my %params;

	if(ref($_[0]) eq 'HASH') {
		%params = %{$_[0]};
	} elsif(scalar(@_) % 2 == 0) {
		%params = @_;
	} else {
		$params{'warning'} = shift;
	}

	if(!defined($params{'warning'})) {
		if(defined($params{'message'})) {
			$params{'warning'} = $params{'message'};
		} else {
			my @call_details = caller(0);
			die "What do you want to say on line $call_details[2]?";
		}
	}

	# Support warning being a ref to an array
	if(ref($params{'warning'}) eq 'ARRAY') {
		$params{'warning'} = join('', @{$params{'warning'}});
	}
	if($opts{'f'}) {
		my @call_details = caller(0);
		if($params{'person'}) {
			die $params{'person'}->as_string(), ': ', ucfirst($params{'warning'}), ' at line ', $call_details[2];
		}
		die ucfirst($params{'warning'}), ' at line ', $call_details[2];
	}

	if($opts{'w'}) {
		$params{'caller'} = 1;
		red_warning(%params);
	}
}

sub red_warning
{
	return unless($opts{'w'});

	my %params = (ref($_[0]) eq 'HASH') ? %{$_[0]} : @_;

	die 'What do you want to say?' unless($params{'warning'});

	my @call_details = caller($params{'caller'} || 0);
	if($opts{'B'}) {
		my $text = $pdfpage->text();
		$text->fillcolor('red');

		my $message;
		if($params{'person'}) {
			$message = $params{'person'}->as_string(middle_names => 1) . ': ' . $params{'warning'};
		} else {
			$message = params{'warning'};
		}
		if(!pdfprint(string => $message, text => $text, pdfpage => $pdfpage)) {
			$text->textend();

			$pdfpage = NJH::PDFPage->new($pdf);

			$text = $pdfpage->text();
			$text->font($pdf->corefont('Times-Roman'), 12);
			$text->fillcolor('red');
			pdfprint(string => $message, text => $text, pdfpage => $pdfpage);
		}
		$text->fillcolor('black');
	} elsif($params{'person'}) {
		if($opts{'W'}) {
			print STDERR $params{'person'}->as_string(middle_names => 1), ': ', $params{'warning'}, "\n";
		} else {
			warn colored(['red'], $params{'person'}->as_string(middle_names => 1), ': ', $params{'warning'}, ' at line ', $call_details[2]);
		}
	} else {
		if($opts{'W'}) {
			print STDERR $params{'warning'}, "\n";
		} else {
			warn colored(['red'], $params{'warning'}, ' at line ', $call_details[2]);
		}
	}
	if($params{'stack_trace'}) {
		my $i = 0;
		while((my @call_details = (caller($i++)))) {
			print STDERR "\t", colored($call_details[1] . ':' . $call_details[2] . ' calling function ' . $call_details[3], 'red'), "\n";
		}
	}
}

# Cache gedcom values
sub get_value
{
	my %params = (ref($_[0]) eq 'HASH') ? %{$_[0]} : @_;

	# if($fetcher) {
		# my $args = {
			# object => $params{'person'},
			# message => 'get_value',
			# arg => $params{'value'}
		# };

		# # Doesn't use the prefetching feature, but will automatically cache which is nice
		# # $fetcher->prime($args);
		# return $fetcher->get($args);
	# }
	my $person = $params{'person'};
	if(!defined($person)) {
		my $i = 0;
		while((my @call_details = caller($i++))) {
			print STDERR "\t", colored($call_details[2] . ' of ' . $call_details[1], 'red'), "\n";
		}
		die 'BUG: person argument is mandatory';
	}
	if(!ref($person)) {
		my $i = 0;
		while((my @call_details = caller($i++))) {
			print STDERR "\t", colored($call_details[2] . ' of ' . $call_details[1], 'red'), "\n";
		}
		die "BUG: person argument isn't an object";
	}

	return $params{'person'}->get_value($params{'value'});
}

sub get_source
{
	my %params = (ref($_[0]) eq 'HASH') ? %{$_[0]} : @_;
	my $source = $params{'source'};

	# my $args = {
		# object => $params{'gedcom'},
		# message => 'get_source',
		# arg => $params{'source'}
	# };

	# # Doesn't use the prefetching feature, but will automatically cache which is nice
	# # $fetcher->prime($args);
	# return $fetcher->get($args);
	if(ref($source)) {
		if($source->title()) {
			return $source;
		}
		return;
	}
	return $params{'gedcom'}->get_source($source);
}

sub must_predate
{
	return unless($opts{'w'});

	my %params = (ref($_[0]) eq 'HASH') ? %{$_[0]} : @_;

	my $person = $params{'person'};
	my $date = $params{'date'};
	my $predate = $params{'predate'};

	return unless($params{'predate'} && $params{'date'});

	my $d1 = $dfn->parse_datetime($date);
	my $d2 = $dfn->parse_datetime($predate);

	if($d1->year() > $d2->year()) {
		complain({
			person => $person,
			warning => "Something is wrong with the date $date which should be before $predate"
		});
	}
}

sub is_alive
{
	my %params;

	if(ref($_[0]) eq 'HASH') {
		%params = %{$_[0]};
	} elsif(scalar(@_) % 2 == 0) {
		%params = @_;
	} else {
		$params{'person'} = shift;
	}

	my $person = $params{'person'};

	if($person->get_record('death') || dateofdeath($person)) {
		return 0;
	}
	if($person->get_record('burial')) {
		return 0;
	}
	my $dob = dateofbirth($person);

	if(!defined($dob)) {
		# If the residences of this person was some time ago, they should be dead by now
		foreach my $event(get_all_residences($person)) {
			if(my $edate = $event->date()) {
				if(my $eyear = get_year_from_date($edate)) {
					if($eyear <= 1900) {
						complain({ person => $person, warning => "Was alive in $eyear but can't find death information" });
						return 0;
					}
				}
			}
		}
		return 0;	# Err on the side of caution
				# TODO: Look at children's lifespan for a clue
	}

	my $year = (localtime)[5];
	$year += 1900 if($year < 1900);

	if(($dob =~ /^\d{3,4}$/) && ($dob < ($year - ASSUME_NOT_LIVING))) {
		return 0;
	}
	if($dob =~ /^abt (\d{4})$/i) {
		$dob = $1;
	}
	if(($dob =~ /^\d/) && ($dob !~ /[a-z]$/i)) {
		if(my $d = date_parser_cached(date => $dob)) {
			$d = $dfn->parse_datetime($d->{'canonical'});
			if($d->strftime('%Y') < ($year - ASSUME_NOT_LIVING)) {
				return 0;
			}
		}
	}
	return 1;
}

sub make_filename_from_person
{
	my %params = (ref($_[0]) eq 'HASH') ? %{$_[0]} : @_;

	my $person = $params{'person'};

	die if(!defined($person));

	my $rc = $person->as_string(include_years => 1);
	$rc =~ tr/ /-/s;
	$rc =~ tr/ /-/s;
	$rc =~ tr/"/'/s;
	$rc =~ tr/\//-/s;
	$rc =~ s/--+/-/g;
	# $rc =~ s/--/-/g;
	$rc =~ s/-$//;

	utf8::decode($rc);
	$rc = Unicode::Diacritic::Strip::strip_diacritics($rc);

	return "$rc.html";
}

# Parse Gedcom format dates
# Genealogy::Gedcom::Date is expensive, so cache results
sub date_parser_cached
{
	my %params;

	if(ref($_[0]) eq 'HASH') {
		%params = %{$_[0]};
	} elsif(scalar(@_) % 2 == 0) {
		%params = @_;
	} else {
		$params{'date'} = shift;
	}

	my $date = $params{'date'};

	if($date =~ /^([A-Z]{3})\s+(\d{1,2}),\s+(\d{3,4})$/i) {
		complain(warning => "Changing US format date '$date' to Gedcom format '$2 $1 $3'");
		$date = "$2 $1 $3";
	}
	if($date =~ /(.+?\d{3,4})\s(.+)$/) {
		if(my $person = $params{'person'}) {
			complain({ person => $person, warning => "'$date': removing trailing text" });
		} else {
			complain("'$date': removing trailing text");
		}
		$date = $1;
	}

	if($all_dates{$date}) {
		print "$date is already known\n" if($opts{'v'});
		return $all_dates{$date};
	}
	if($date !~ /\d$/) {
		my $i = 0;
		while((my @call_details = caller($i++))) {
			print STDERR "\t", colored($call_details[2] . ' of ' . $call_details[1], 'red'), "\n";
		}
		die "BUG: date_parser_cached($date) illegal date should have been trapped by now";
	}
	print "Parse date $date\n" if($opts{'v'});
	my $d;
	eval {
		$d = $date_parser->parse(date => $date);
	};
	if($d && (ref($d) eq 'ARRAY')) {
		$d = $d->[0];
		$all_dates{$date} = $d;
	}
	return $d;
}

# Try hard to convert a Gedcom date to a DateTime object.
sub date_to_datetime
{
	my %params;

	if(ref($_[0]) eq 'HASH') {
		%params = %{$_[0]};
	} elsif(scalar(@_) % 2 == 0) {
		%params = @_;
	} else {
		$params{'date'} = shift;
	}

	if(my $date = $params{'date'}) {
		# if($date !~ /^(bef|abt|aft).?\s/i) {
		if(($date !~ /^(bef|abt|aft)/i) && ($date !~ /\sor\s/)) {
			$params{'quiet'} = 1 if(!$opts{'w'});
			return $dfg->parse_datetime(%params);
		}
	}
	return;	# undef
}

sub descendants
{
	my $person = shift;

	my @list;
	if(my $l = shift) {
		@list = @{$l};
	}

	my @children = $person->children();
	if(scalar(@children)) {
		foreach my $child(@children) {
			push @list, $child;
			# my @spouses = $child->spouse();
			# if(scalar(@spouses)) {
				# push @list, @spouses;
			# }
			@list = descendants($child, \@list);
		}
	}

	return @list;
}

sub ancestors
{
	my $person = shift;

	my @list;
	if(my $l = shift) {
		@list = @{$l};
	}

	if(my $mother = $person->mother()) {
		push @list, $mother;
		@list = ancestors($mother, \@list);
		my @siblings = $mother->siblings();
		foreach my $sibling(@siblings) {
			push @list, $sibling;
			# my @spouses = $sibling->spouse();
			# if(scalar(@spouses)) {
				# push @list, @spouses;
			# }
			@list = descendants($sibling, \@list);
		}
	}
	if(my $father = $person->father()) {
		push @list, $father;
		@list = ancestors($father, \@list);
		my @siblings = $father->siblings();
		foreach my $sibling(@siblings) {
			push @list, $sibling;
			# my @spouses = $sibling->spouse();
			# if(scalar(@spouses)) {
				# push @list, @spouses;
			# }
			@list = descendants($sibling, \@list);
		}
	}

	return @list;
}

# Print the text in "string" to the "text" object returned from PDF::API2->text()
# Returns success or failure.  On failure it means there's not enough room for the text
#	so start a new page.
sub pdfprint
{
	my %params = (ref($_[0]) eq 'HASH') ? %{$_[0]} : @_;

	my $pdfpage = $params{'pdfpage'};

	die 'pdfprint: pdfpage is not optional' if(!defined($pdfpage));

	if($pdfpage->full()) {
		print "pdfprint: full returned true\n" if($opts{'v'});
		return 0;
	}

	my $indent = ($params{'noindent'}) ? '' : '    ';

	if(ref($params{'string'})) {
		$params{'string'} = $params{'string'}->as_string();
	}

	# TODO: support UTF-8 fonts
	my $string = $params{'string'};
	if(!defined($string)) {
		print STDERR "\n";
		my $i = 0;
		while((my @call_details = caller($i++))) {
			print STDERR "\t", colored($call_details[2] . ' of ' . $call_details[1], 'red'), "\n";
		}
		die 'BUG: string not defined';
	}
	utf8::decode($string);
	$string = Unicode::Diacritic::Strip::strip_diacritics($string);
	my @lines = split(/\n/, wrap($indent, '', $string));

	if(scalar(@lines) >= $pdfpage->linesleft() - 1) {
		print 'pdfprint: ', scalar(@lines), ' >= ', ($pdfpage->linesleft() - 1), "\n" if($opts{'v'});

		return 0;
	}

	my $text = $pdfpage->text();
	my $x = $params{'x'} || 40;

	foreach my $line (@lines) {
		$text->translate($x, $pdfpage->newline());
		if($params{'centre'}) {
			$text->text_center($line);
		} else {
			$text->text($line);
		}
	}
	return 1;
}

# Inspired by Tree::Family.  That module doesn't quite do what I want, so
# I've mercilessly re-used the ideas of what to do from it.
sub print_graphviz
{
	my %params = (ref($_[0]) eq 'HASH') ? %{$_[0]} : @_;

	my $fout = $params{'fout'};
	my $person = $params{'person'};
	my $colour = $params{'colour'};
	my $profile_image = $params{'profile_image'};

	if(!defined($colour)) {
		my $gender = get_value({ person => $person, value => 'sex' }) || $person->sex();
		if(defined($gender)) {
			$gender = $gender;
		} else {
			complain({ person => $person, warning => 'unknown sex' });
			$gender = 'M';	# Avoid "Use of uninitialized value" in Tree::Family
		}
		$colour = ($gender eq 'M' ? '#093AB5' : '#C666B8');
	}

	print $fout $person->xref(), ' [shape=box,fontsize="10",',
		"color=\"$colour\",";

	# if($params{'format'} eq 'dynamic') {
		# print $fout 'href="?page=people&entry=', $person->xref(), '",';
	# } else {
		# print $fout 'href="', make_filename_from_person(person => $person), '",';
	# }

	my $label = $person->as_string();
	my $dob = dateofbirth($person);
	my $dod = dateofdeath($person);

	my $thumbnail;

	# If you get 'Warning: No loadimage plugin for "jpeg:cairo"', do this
	# instead:
	# if(0) {
	if($profile_image && (defined($dod) || $opts{'l'})) {
		if(defined($dob)) {
			$dob .= "<TR><TD>b. $dob</TD></TR>";
		} else {
			$dob = '';
		}
		if(defined($dod)) {
			$dod .= "<TR><TD>d. $dod</TD></TR>";
		} else {
			$dod = '';
		}
		# Create a thumbnail
		my $image = Image::Magick->new();
		$image->read($profile_image);
		my ($thumb, $x, $y) = Image::Magick::Thumbnail::create($image, 100);
		my @thumbname = File::Basename::fileparse($profile_image);
		# use PNG to try to avoid
		#	'Warning: No loadimage plugin for "jpeg:cairo"'
		$thumbname[0] =~ s/\.jpg$/.png/;
		$thumbnail = "thumbs/$thumbname[0]";
		$thumb->Write($thumbnail);

		# FIXME: TABLE isn't supported by Graphviz
		print $fout "label=<<TABLE border=\"0\" cellborder=\"0\"><TR><TD><IMG SRC=\"thumbs/$thumbname[0]\" scale=\"true\" width=\"$x\" height=\"$y\"/></TD></TR><TR><TD>$label</TD></TR>$dob$dod</TABLE>>",
			",labelloc=b";

		# print $fout ",image=\"$profile_image\",labelloc=b";

		chmod 0444, $thumbnail;
	} elsif(defined($dod) || $opts{'l'}) {
		if(defined($dob)) {
			$label .= "\\nb. $dob";
		}
		if(defined($dod)) {
			$label .= "\\nd. $dod";
		}
		print $fout "label=\"$label\"";
	} else {
		print $fout "label=\"$label\"";
	}

	print $fout "];\n";

	return $thumbnail;
}

sub print_graphviz_generation
{
	my %params = (ref($_[0]) eq 'HASH') ? %{$_[0]} : @_;

	my $fout = $params{'fout'};
	my $person = $params{'person'};
	my $rank = $params{'rank'} + 1;
	my $maxrank = $params{'maxrank'} + 1;
	$params{'rank'} = $rank;

	return if($maxrank && ($rank >= $maxrank));

	print $fout "} subgraph children$rank { rank=\"$rank\"; ";
	print_graphviz({ person => $person, fout => $fout, format => 'dynamic' });

	if(($rank > 1) && (my $father = $person->father())) {
		print $fout $father->xref(), ' -> ', $person->xref(), ";\n";
	}

	if($person->sex() eq 'M') {
		# my @children = $person->children();
		my @children = map { $_->children() } $person->fams();
		if(scalar(@children) > 0) {
			# TODO: sort by date of birth
			foreach my $child(@children) {
				if($opts{'l'} || !is_alive(person => $child)) {
					$params{'person'} = $child;
					print_graphviz_generation(\%params);
				}
			}
		}
	}
}

sub get_all_residences
{
	my %params;

	if(ref($_[0]) eq 'HASH') {
		%params = %{$_[0]};
	} elsif(scalar(@_) % 2 == 0) {
		%params = @_;
	} else {
		$params{'person'} = shift;
	}

	my $person = $params{'person'};

	die 'Usage: get_all_residences($person)' unless($person);

	# Cache the records to save repeated expensive lookups
	if($all_residences{$person->xref()}) {
		return @{$all_residences{$person->xref()}};
	}

	my @residences = $person->residence();
	my @rc;
	my $index = 0;
	foreach my $residence(@residences) {
		$index++;
		if(!ref($residence)) {
			my $r = $person->tag_record('RESI', $index);
			if(ref($r) eq 'Gedcom::Record') {
				$residence = $r;
			}
		}
		if(ref($residence) eq 'Gedcom::Record') {
			push @rc, $residence;
		}
	}
	my @events = $person->event();
	$index = 0;
	foreach my $event(@events) {
		$index++;
		if(!ref($event)) {
			my $e = $person->tag_record('EVEN', $index);
			if(ref($e) eq 'Gedcom::Record') {
				$event = $e;
			}
		}
		next if($event->can('type') || $event->isa('Class::Simple::Readonly::Cached'));
		my $type = $event->type();
		next if(!defined($type));
		# if(($type =~ /^Census U[KS] \d{4}$/) || ($type eq 'Register UK 1939') || ($type eq 'Hospitalisation')) {
		if(($type =~ /Census/) || ($type eq 'Register UK 1939') || ($type eq 'Hospitalisation') || ($type eq 'Story')) {
			push @rc, $event;
		}
	}
	my @censuses = $person->census();
	$index = 0;
	foreach my $census(@censuses) {
		$index++;
		if(!ref($census)) {
			my $c = $person->tag_record('CENS', $index);
			if(ref($c) eq 'Gedcom::Record') {
				$census = $c;
			}
		}
		if(ref($census) eq 'Gedcom::Record') {
			push @rc, $census;
		}
	}

	# TODO: Can't do this as so many things check ref($record) eq 'Gedcom::Record'
	# @rc = map { Class::Simple::Readonly::Cached->new({ object => $_, cache => {} }) } @rc;

	if($opts{'w'}) {
		# Warn if the address was 33 Foo St in 1900, and Foo St in 1910.
		# Don't warn about earlier years if the year was before 1900
		#	as less information was kept so it can't be verified
		my $all_residences_have_date = 1;
		my $year = (localtime)[5];
		$year += 1900 if($year < 1900);
		foreach my $residence(@rc) {
			if(my $date = $residence->date()) {
				if(get_year_from_date($date) > $year) {
					complain({ person => $person, warning => 'Residence date is in the future' });
				}
			} else {
				complain({ person => $person, warning => 'Residence missing a date' });
				$all_residences_have_date = 0;
				last;
			}
		}
		if($all_residences_have_date) {
			my $prev_year;
			my $prev_place;
			foreach my $residence(Sort::Key::keysort { get_year_from_date($_->date()) } @rc) {
				my $date = $residence->date();
				next unless($date);

				if(my $place = place({ person => $person, record => $residence, nopreposition => 1 })) {
					$year = get_year_from_date($date);
					$place =~ s/^\s+//;
					if($prev_year && $prev_place) {
						if(($year >= 1900) && ($year >= $prev_year)) {
							next unless($place);
							next if($place =~ /^\d/);
							if($prev_place =~ /^\d/) {
								$prev_place =~ /^(\d+)\s+(.+)/;
								if($2 eq $place) {
									complain({ person => $person, warning => "Missing house number ($1) in $year that was known in $prev_year" });
								}
							}
						}
					} elsif($place && ($place =~ /^\d/)) {
						$prev_place = $place;
						$prev_year = $year;
					}
				}
			}
		}
	}

	$all_residences{$person->xref()} = \@rc;
	return @rc;
}

# TODO: railway/railroad = le chemin de fer
sub get_all_occupations
{
	my %params;

	if(ref($_[0]) eq 'HASH') {
		%params = %{$_[0]};
	} elsif(scalar(@_) % 2 == 0) {
		%params = @_;
	} else {
		$params{'person'} = shift;
	}

	my $person = $params{'person'};

	die 'Usage: get_all_occupations($person)' unless($person);

	my @occupations = get_value({ person => $person, value => 'occupation' });

	if((scalar(@occupations) == 1) && !defined($occupations[0])) {
		return;
	}

	while($occupations[0] && ($occupations[0] =~ /^scho(ol|lar)/i)) {
		shift @occupations;
	}
	while($occupations[0] && ($occupations[0] =~ /wife$/i)) {
		shift @occupations;
	}
	while($occupations[0] && ($occupations[0] =~ /unemployed/i)) {
		shift @occupations;
	}
	while($occupations[0] && ($occupations[0] =~ /Unpaid domestic duties/i)) {
		shift @occupations;
	}
	while($occupations[0] && ($occupations[0] =~ /home duties/i)) {
		shift @occupations;
	}
	while($occupations[0] && ($occupations[0] eq 'Retired')) {
		shift @occupations;
	}

	while(scalar(@occupations) > 1) {
		if(($occupations[0] =~ /^labou?rer/i) && ($occupations[1] =~ /^labou?rer/i)) {
			shift @occupations;
		} elsif(lc($occupations[0]) eq lc($occupations[1])) {
			shift @occupations;
		} else {
			last;
		}
	}

	# TODO: sort out case
	my @rc;

	while(my $occupation = shift @occupations) {
		$occupation =~ tr/\r//;
		$occupation =~ tr/\n/ /;
		$occupation =~ s/\.+$//;
		$occupation =~ s/[\(\)]//g;
		$occupation =~ s/\s\s/ /g;
		$occupation =~ s/\./;/g;

		$occupation =~ s/\s+Own Account//i;
		$occupation =~ s/^Formerly //i;
		$occupation =~ s/\sretired$//i;
		$occupation =~ s/Labor/Labour/i;

		if(($occupation =~ /(.+)\sdomestic$/i) ||
		   ($occupation =~ /(.+)\sdom$/i)) {
			$occupation = "Domestic $1";
		}

		if($occupation =~ /works? on (.+)/i) {
			$occupation = "$1 worker";
		} elsif(($occupation eq 'Ag Lab') ||
			($occupation eq 'Ag Labourer') ||
			($occupation eq 'Ag Labourer Pauper') ||
			($occupation eq 'Ag Lab Pauper') ||
			($occupation eq 'Farm Labourer') ||
			($occupation eq 'Agricultural Farm Labourer') ||
			($occupation eq 'Ordinary Agricultural Labourer') ||
			($occupation eq 'work on farm') ||
			($occupation eq 'Agricultural Lab') ||
			($occupation eq 'Agril Labourer') ||
			($occupation eq 'Labourer (Ag)')) {
			$occupation = 'Agricultural Labourer';
		} elsif($occupation eq 'Poultry Farming') {
			if($language eq 'French') {
				$occupation = (($person->sex() eq 'M') ? 'Agriculteur de poulet' : 'Agricultrice de poulet');
			} else {
				$occupation = 'Poultry Farmer';
			}
		} elsif($occupation eq 'Platelayer Railway') {
			$occupation = 'Railway Platelayer';
		} elsif(($occupation eq 'General Servant Domestic') ||
			($occupation =~ /^General serv.+dom/i) ||
			($occupation =~ /^Domestic servant$/i)) {
			if($language eq 'French') {
				$occupation = 'Domestique';
			} else {
				$occupation = 'Domestic servant';
			}
		} elsif($occupation =~ /(.+)\sserv$/i) {
			$occupation = "$1 servant";
		} elsif($occupation eq 'Lorry Driver Heavy Worker') {
			$occupation = 'Lorry Driver';
		} elsif($occupation =~ /^Shop Assistant (.*)/) {
			$occupation = "$1's Shop Assistant";
		} elsif($occupation =~ /(.*) Assistant$/i) {
			if($1 eq 'Bakers') {
				$occupation = "Baker's Assistant";
			} elsif($1 eq 'Butchers') {
				$occupation = "Butcher's Assistant";
			} elsif($1 ne 'Shop') {
				$occupation = "$1's Assistant" unless($1 =~ /'s$/);
			}
		} elsif($occupation =~ /Clerk (.*)/) {
			$occupation = "$1 Clerk";
		} elsif($occupation =~ /^Salesman (.*)/i) {
			$occupation = "$1 Salesman";
		} elsif($occupation =~ /Foreman (.*)/i) {
			$occupation = "$1 Foreman";
			$occupation =~ s/^of the //i;
		} elsif($occupation =~ /Labourer Gas Stoker/) {
			$occupation = 'Gas Stoker';
		} elsif(($occupation eq 'Under Gardener Domestic') ||
			($occupation eq 'Domestic Under Gardner')) {	# sic
			$occupation = 'Domestic Gardener';
		} elsif($occupation eq 'Market gardener') {
			$occupation = 'Market Gardener';
		} elsif($occupation eq "Brewer's Labourer") {
			$occupation = 'Brewery Labourer';
		} elsif($occupation eq "Labourer Builders") {
			$occupation = "Builder's labourer";
		} elsif(($occupation eq 'Gardener domestic') ||
			($occupation eq 'Gardner and domestic servant')) {
			$occupation = 'Gardener and Domestic';
		} elsif($occupation =~ /(.+)\sserv$/i) {
			$occupation = "$1 servant";
		} elsif($occupation =~ /^(.+) on farm/i) {
			$occupation = ($language eq 'French') ? "$1 en un ferme" : "$1 on a farm";
		} elsif($occupation eq 'Plate Glass Cutter') {
		} elsif($occupation =~ /police$/i) {
			$occupation .= ' officer';
		} elsif(($occupation eq 'Nurse') && ($language eq 'French')) {
			$occupation = ($person->sex() eq 'M') ? 'infirmier' : "infirmi\N{U+00E8}re";
		} elsif($occupation =~ /teaching/i) {
			if($language eq 'French') {
				$occupation = 'professeur';
			} elsif($language eq 'German') {
				$occupation = ($person->sex() eq 'M') ? 'Lehrer' : 'Lehrerin';
			} else {
				$occupation = 'teacher';
			}
		} elsif(($occupation !~ /gas works/i) && ($occupation =~ /(.+)([a-z])s\s+([a-z]+)$/i)) {
			# Don't change Bus Driver to Bu's Driver
			$occupation = "$1$2's $3" unless(("$1$2" eq 'Bu') || ("$1$2" eq 'Harnes'));
		} elsif(($occupation =~ /Manager (.*)/i) &&
			($occupation !~ /^Manager of /i) &&
			($occupation !~ /Manager & /i)) {
			$occupation = "$1 Manager";
		}

		if($language eq 'German') {
			if($occupation eq 'Bus driver') {
				$occupation = ($person->sex() eq 'M') ? 'Busfahrer' : 'Busfahrerin';
			}
		}

		if($occupation) {
			if($language eq 'English') {
				if($ENV{'LANG'} =~ /^en_US/) {
					$occupation = Lingua::EN::ABC::b2a(lc($occupation));
					$occupation =~ s/labour/labor/;
					$occupation =~ s/Labour/Labor/;
				} elsif($ENV{'LANG'} =~ /^en_CA/) {
					$occupation = Lingua::EN::ABC::b2c(lc($occupation));
				} else {
					$occupation = Lingua::EN::ABC::a2b(lc($occupation));
				}
			} elsif($language eq 'French') {
				if($occupation eq 'Postman') {
					$occupation = (($person->sex() eq 'M') ? 'Facteur' : 'Factrisse');
				} elsif($occupation =~ /(.+)\sFarmer/) {
					$occupation = (($person->sex() eq 'M') ? "Agriculteur $1" : "Agricultrice $1");
				} elsif($occupation eq 'Farmer') {
					$occupation = (($person->sex() eq 'M') ? 'Agriculteur' : 'Agricultrice');
				} elsif($occupation eq 'Teacher') {
					$occupation = 'Professeur';
				}
				$occupation =~ s/retired/\N{U+00E0} la retrainte/i;
			} elsif($language eq 'German') {
				if($occupation eq 'Teacher') {
					$occupation = (($person->sex() eq 'M') ? 'Lehrer' : 'Lehrerin');
				}
				$occupation =~ s/retired/im ruhestand/i;
				$occupation =~ s/self-employed/slbststa\N{U+00E4}ndig/;
			}
			if($occupation =~ /works? (on|for) (.+)/i) {
				$occupation = "$2 worker";
			} elsif($occupation =~ /^Cleaner\s+(.+)/i) {
				$occupation = "$1 cleaner";
			}
			$occupation = ucfirst($occupation);
			$occupation =~ s/\s+heavy worker$//i;
			$occupation =~ s/\s+own business$//i;

			push @rc, $occupation;
		} else {
			complain({
				person => $person,
				warning => 'Occupation is empty'
			});
		}
	}

	return @rc;
}

# Return the arrival record of the given person, or undef if none or more than one
sub arrival
{
	my %params = (ref($_[0]) eq 'HASH') ? %{$_[0]} : @_;

	my $person = $params{'person'};

	my @events = $person->event();
	my $rc;

	foreach my $event(@events) {
		if(($event->can('type') || $event->isa('Class::Simple::Readonly::Cached')) && ($event->type() eq 'Arrival')) {
			return if($rc);
			$rc = $event;
		}
	}
	return $rc
}

# Document a complete journey when both a departure and an arrival record exist
sub journey
{
	my %params = (ref($_[0]) eq 'HASH') ? %{$_[0]} : @_;

	my $person = $params{'person'};
	my $arrival = $params{'arrival'};
	my $departure = $params{'departure'};
	my @spouses;
	my @children;
	my $yod;
	my $yoa;
	my $dod = $departure->date();
	my $doa = $arrival->date();
	my $only_have_departure_year;

	@spouses = @{$params{'spouses'}} if($params{'spouses'});
	@children = @{$params{'children'}} if($params{'children'});

	# my $i = 0;
	# while((my @call_details = (caller($i++)))) {
		# print STDERR "\t", $call_details[1], ':', $call_details[2], ' calling function ', $call_details[3], "\n";
	# }

	if($doa && ($doa =~ /(\d{3,4})$/)) {
		$yoa = $1;
		$doa =~ s/\s+?\d{3,4}//;
		if($dod && ($dod =~ /(\d{3,4})$/)) {
			$yod = $1;
			$dod =~ s/\s?\d{3,4}//;
			if($dod =~ /^\d/) {
				$dod = "on $dod";
			} elsif(length($dod) && ($dod !~ /^abt\.?$/)) {
				$dod = i18n({ format => 'during %s', args => $dod });
			} else {
				# $dod = i18n({ format => 'during %s', args => $yod });
				$only_have_departure_year = 1;
			}
			if($doa =~ /^\d/) {
				$doa = "on $doa";
			} elsif($yoa == $yod) {
				$doa = i18n('later that same year');
			} elsif(length($doa)) {
				$doa = i18n({ format => 'during %s', args => $doa });
			} else {
				$doa = i18n({ format => 'during %s', args => $yoa });
			}
		}
	}

	my $rc = ucfirst(i18n($person->pronoun()));
	if($yoa || $yod) {
		my $year = $yoa // $yod;
		if($language eq 'French') {
			$rc = "En $year " . lc($rc);
		} else {
			$rc = "In $year " . lc($rc);
		}
		if($year eq $doa) {
			# Nothing more to print, avoid "In 1914 he arrived in 1914"
			# But keep "In 1914 he arrived on 1 Jul"
			undef $doa;
		}
	} else {
		die 'TODO: ', $person->as_string(), ': handle departure only record';
		# $yod = year({ person => $person, record => $departure });
		# $yoa = year({ person => $person, record => $arrival });
	}

	if($language eq 'French') {
		$rc .= " a voyag\N{U+00E9}";
	} elsif($ENV{'LANG'} =~ /^en_US/) {
		$rc .= ' traveled';
	} else {
		$rc .= ' travelled';
	}

	my $dnotes;

	if(defined($departure->place())) {
		$rc .= i18n(' from') . place({ person => $person, record => $departure, nopreposition => 1 });
		if($dnotes = notes(record => $departure)) {
			$dnotes = lcfirst($dnotes) unless($dnotes =~ /^[A-Z]{2}/);
			$dnotes =~ s/\.$//;
			$rc .= " ($dnotes)";
		}
	} else {
		complain({ person => $person, warning => 'Departure record has no location' });
	}
	if(defined($arrival->place())) {
		if($language eq 'French') {
			$rc .= " \N{U+00E0}";
		} elsif($language eq 'German') {
			$rc .= ' nach';
		} else {
			$rc .= ' to';
		}
		$rc .= place({ person => $person, record => $arrival, nopreposition => 1 });
		if(my $notes = notes(record => $arrival)) {
			if((!defined($dnotes)) || ($notes !~ qr/$dnotes/i)) {
				$notes = lcfirst($notes) unless($notes =~ /^[A-Z]{2}/);
				$notes =~ s/\.$//;
				$rc .= " ($notes)";
			}
		}
	} else {
		complain({ person => $person, warning => 'Arrival record has no location' });
	}

	if(defined($dod) && !$only_have_departure_year) {
		if($language eq 'French') {
			$rc .= ", partant $dod";
		} else {
			$rc .= ", departing $dod";
		}
	}

	if(defined($doa)) {
		$rc .= ", arriving $doa";
	}

	if($arrival->date()) {
		my $with_spouse;
		if($spouses[0] && ($opts{'l'} || !is_alive(person => $spouses[0])) &&
		   (my $sarrival = arrival({ person => $spouses[0] }))) {
			if($sarrival->date() eq $arrival->date()) {
				$rc .= i18n(' with ') .
					lcfirst($person->possessive()) . ' ' .
					((get_value({ person => $person, value => 'sex' }) eq 'M') ? 'wife' : 'husband') .
					', ' . $spouses[0]->given_names();
				$with_spouse++;
			}
		}
		my @childnames;
		foreach my $child(@children) {
			if(($opts{'l'} || !is_alive(person => $child))) {
				my $given_names = $child->given_names();
				$given_names =~ s/\.$//;
				push(@childnames, $given_names);
			}
		}
		if(scalar(@childnames)) {
			$rc .= (i18n(($with_spouse) ? ' and ' : ' with '));
			if(scalar(@childnames) == scalar(@children)) {
				$rc .= 'all of ' .
					lcfirst($person->possessive()) .
					i18n(' children');
			} elsif(scalar(@childnames) == 1) {
				$rc .= lcfirst($person->possessive()) .
					i18n(' child ') .
					$childnames[0];
			} elsif(scalar(@childnames) > 1) {
				$rc .= lcfirst($person->possessive()) .
					i18n(' children') .
					': ' . conjunction(@childnames);
			}
		}
	}
	return $rc
}

sub count_descendants_at_level
{
	my $person = shift;
	my $level = shift;

	my $count = 0;
	foreach my $child($person->children()) {
		if($level == 1) {
			$count++;
		} else {
			$count += count_descendants_at_level($child, $level - 1);
		}
	}
	return $count;
}

# Compare two dates. Approximate dates are compared.
# TODO: handle when only months are known
sub datecmp($$)
{
	my ($left, $right) = @_;

	if((!defined($left)) || !defined($right)) {
		# Shouldn't happen with the prototype
		print STDERR "\n";
		if(!defined($left)) {
			print STDERR "BUG: left not defined\n";
		}
		if(!defined($right)) {
			print STDERR "BUG: right not defined\n";
		}
		my $i = 0;
		while((my @call_details = caller($i++))) {
			print STDERR "\t", colored($call_details[2] . ' of ' . $call_details[1], 'red'), "\n";
		}
		return 0;
	}

	return 0 if($left eq $right);

	if(!ref($left)) {
		if((!ref($right)) && ($left =~ /(^|[\s\/])\d{4}$/) && ($right =~ /(^|[\s\/,])(\d{4})$/)) {
			my $ryear = $2;
			$left =~ /(^|[\s\/])(\d{4})$/;
			my $lyear = $2;
			if($lyear != $ryear) {
				# Easy comparison for different years
				return $lyear <=> $ryear;
			}
		}
		if($left =~ /^(bef|aft)/i) {
			if($right =~ /^\d+$/) {
				# For example, comparing bef 1 Jun 1965 <=> 1939
				if($left =~ /\s(\d+)$/) {
					# Easy comparison for different years
					if($1 != $right) {
						return $1 <=> $right;
					}
					# FIXME: same year
				}
			}
			print STDERR "$left <=> $right: not handled yet\n";
			my $i = 0;
			while((my @call_details = caller($i++))) {
				print STDERR "\t", colored($call_details[2] . ' of ' . $call_details[1], 'red'), "\n";
			}
			return 0;
		}
		if($left =~ /^(Abt|ca?)\.?\s+(.+)/i) {
			$left = $2;
		} elsif(($left =~ /\//) && ($left =~ /^[a-z\/]+\s+(.+)/i)) {
			# e.g. "Oct/Nov/Dec 1950"
			$left = $1;
		}

		# e.g. "1802 or 1803"
		if($left =~ /^(\d{3,4})\sor\s(\d{3,4})$/) {
			my($start, $end) = ($1, $2);
			if($start == $end) {
				complain("the years are the same '$left'");
			}
			$left = $start
		} elsif($left !~ /^\d{3,4}$/) {
			if(($left !~ /[a-z]/i) || ($left =~ /[a-z]$/)) {
				my $i = 0;
				while((my @call_details = caller($i++))) {
					print STDERR "\t", colored($call_details[2] . ' of ' . $call_details[1], 'red'), "\n";
				}
				die "Date parse failure: left = '$left' ($left <=> $right)";
			}
			my @l = $dfg->parse_datetime($left);
			my $rc = $l[1] || $l[0];
			if(!defined($rc)) {
				my $i = 0;
				while((my @call_details = caller($i++))) {
					print STDERR "\t", colored($call_details[2] . ' of ' . $call_details[1], 'red'), "\n";
				}
				die "Date parse failure: left = '$left' ($left <=> $right)";
			}
			$left = $rc;
		}
	}
	if(!ref($right)) {
		if($right =~ /^bef/i) {
			if($left =~ /^\d+$/) {
				# For example, comparing 1939 <=> bef 1 Jun 1965
				if($right =~ /\s(\d+)$/) {
					return $left <=> $1;
				}
			}
			print STDERR "$left <=> $right: Before not handled\n";
			my $i = 0;
			while((my @call_details = caller($i++))) {
				print STDERR "\t", colored($call_details[2] . ' of ' . $call_details[1], 'red'), "\n";
			}
			return 0;
		}
		if($right =~ /^(Abt|ca?)\.?\s+(.+)/i) {
			$right = $2;
		} elsif(($right =~ /\//) && ($right =~ /^[a-z\/]+\s+(.+)/i)) {
			# e.g. "Oct/Nov/Dec 1950"
			$right = $1;
		}

		if($right =~ /^\d{3,4}$/) {
			if(ref($left)) {
				return $left->year() <=> $right;
			} else {
				return $left <=> $right;
			}
		}
		# if(!$dfg->parse_datetime($right)) {
			# my $i = 0;
			# while((my @call_details = caller($i++))) {
				# print STDERR "\t", colored($call_details[2] . ' of ' . $call_details[1], 'red'), "\n";
			# }
			# die join('<=>', @_);
		# }
		my @r = $dfg->parse_datetime($right);
		if(!defined($r[0])) {
			if($right =~ /[\s\/](\d{4})$/) {
				# e.g. cmp "1891 <=> Oct/Nov/Dec 1892"
				# or 5/27/1872
				my $year = $1;
				if(ref($left)) {
					if($left->year() != $year) {
						return $left->year() <=> $year;
					}
				} else {
					if($left != $year) {
						return $left <=> $year;
					}
				}
			}
			# TODO: throw an error that we can catch
			my $i = 0;
			while((my @call_details = caller($i++))) {
				print STDERR "\t", colored($call_details[2] . ' of ' . $call_details[1], 'red'), "\n";
			}
			die $right;
		}
		$right = $r[0];
	}
	if((!ref($left)) && ref($right)) {
		return $left <=> $right->year();
	}
	if(ref($left) && (!ref($right))) {
		return $left->year() <=> $right;
	}

	return $left <=> $right;
}

sub chronicling_america
{
	my ($person, $chronicling_params) = @_;

	return unless($opts{'w'});

	if(!defined($chronicling_params->{'firstname'})) {
		my $i = 0;
		while((my @call_details = (caller($i++)))) {
			print STDERR "\t", $call_details[1], ':', $call_details[2], ' calling function ', $call_details[3], "\n";
		}
		die $person->as_string(), ': BUG: no first name given';
	}
	if(length($chronicling_params->{'state'}) <= 2) {
		my $i = 0;
		while((my @call_details = (caller($i++)))) {
			print STDERR "\t", $call_details[1], ':', $call_details[2], ' calling function ', $call_details[3], "\n";
		}
		die $person->as_string(), ': BUG: state "', $chronicling_params->{'state'}, '" too short';
	}

	print Data::Dumper->new([$chronicling_params])->Dump() if($opts{'v'});

	if(my $loc = Genealogy::ChroniclingAmerica->new($chronicling_params)) {
		while(my $url = $loc->get_next_entry()) {
			complain({ person => $person, warning => ucfirst(i18n('check out %s', $url)) });
		}
	}

	print "Leaving chronicling_america\n" if($opts{'v'});
}

sub obituaries
{
	my %params;

	if(ref($_[0]) eq 'HASH') {
		%params = %{$_[0]};
	} elsif(scalar(@_) % 2 == 0) {
		%params = @_;
	} else {
		my $i = 0;
		while((my @call_details = caller($i++))) {
			print STDERR "\t", colored($call_details[2] . ' of ' . $call_details[1], 'red'), "\n";
		}
		die 'BUG: no arguments given';
	}

	$Data::Dumper::Maxdepth = 2;
	print "obituaries:\n\t", Data::Dumper->new([\%params])->Dump() if($opts{'v'});

	my $yob = delete $params{'yob'};
	my $yod = delete $params{'yod'};
	my $person = delete $params{'person'};
	my @obituaries = $obituaries->search(\%params);

	print scalar(@obituaries), " obituaries found\n" if($opts{'v'});

	if(scalar(@obituaries)) {
		foreach my $obituary(@obituaries) {
			if(my $date = $obituary->{'date'}) {
				if($date =~ /^(\d+)\-\d+\-\d+$/) {
					my $year = $1;
					if($yod) {
						if(abs($year - $yod) <= 1) {
							if($yob && $obituary->{'age'}) {
								if(abs($year - ($yob + $obituary->{'age'})) <= 1) {
									complain({ person => $person, warning => ucfirst(i18n('check out %s', $obituary->{'url'})) });
								}
							} else {
								complain({ person => $person, warning => ucfirst(i18n('check out %s', $obituary->{'url'})) });
							}
						}
					} elsif($yob && $obituary->{'age'}) {
						if(abs($year - ($yob + $obituary->{'age'})) <= 1) {
							complain({ person => $person, warning => ucfirst(i18n('check out %s', $obituary->{'url'})) });
						}
					}
				}
			}
		}
	}

	return @obituaries;
}

sub wills
{
	my %params;

	return if(!defined($wills));

	if(ref($_[0]) eq 'HASH') {
		%params = %{$_[0]};
	} elsif(scalar(@_) % 2 == 0) {
		%params = @_;
	} else {
		my $i = 0;
		while((my @call_details = caller($i++))) {
			print STDERR "\t", colored($call_details[2] . ' of ' . $call_details[1], 'red'), "\n";
		}
		die 'BUG: no arguments given';
	}

	$Data::Dumper::Maxdepth = 2;
	print Data::Dumper->new([\%params])->Dump() if($opts{'v'});

	my $person = delete $params{'person'};
	my @wills = $wills->search(\%params);

	print scalar(@wills), " wills found\n" if($opts{'v'});

	foreach my $will(@wills) {
		complain({ person => $person, warning => ucfirst(i18n('check out %s', $will->{'url'})) });
	}

	return @wills;
}

# FIXME: once RT127603 has been fixed
sub Geo::Coder::PlaceFinder::ua
{
	my $self = shift;

	if(my $ua = shift) {
		return $self->{_ua} = $ua;
	}

	return $self->{_ua};
}

# See https://github.com/OpenCageData/perl-Geo-Coder-OpenCage/issues/8
sub Geo::Coder::OpenCage::ua {
	my $self = shift;

	# if(my $ua = shift) {
		# $self->{ua} = $ua;
	# }
	return $self->{ua};
}

sub add_to_ical {
	my %params = (ref($_[0]) eq 'HASH') ? %{$_[0]} : @_;

	my $datetime = $params{'datetime'};

	my $event = Data::ICal::Entry::Event->new();

	$event->start($datetime);
	$event->all_day(1);
	$event->add_properties(summary => $params{'summary'});

	$params{'ical'}->add_entry($event);
}

sub dateofbirth {
	my %params;

	if(ref($_[0]) eq 'HASH') {
		%params = %{$_[0]};
	} elsif(scalar(@_) % 2 == 0) {
		%params = @_;
	} else {
		$params{'person'} = shift;
	}

	my $person = $params{'person'};

	my @d = get_value({ person => $person, value => 'birth date' });
	my $dateofbirth;

	if((scalar(@d) == 2) && ($d[0] ne $d[1])) {
		my ($year1, $year2);

		if($d[0] =~ /(\d{3,4})/) {
			$year1 = $1;
		}
		if($d[1] =~ /(\d{3,4})/) {
			$year2 = $1;
		}

		if((defined($year1) && defined($year2)) && (abs($year1 - $year2) > 30)) {
			complain({ person => $person, warning => 'More than one date of birth separated by many years' });
		}

		# Get the primary date.
		# TODO: Is there a proper way to do this with the Gedcom module?
		# FIXME: limited to 2 dates
		my @b = $person->birth();

		for my $i(0..1) {
			if(ref($b[$i])) {
				foreach my $item(@{$b[$i]->{'items'}}) {
					if(($item->tag() eq '_PRIM') && ($item->value() eq 'Y')) {
						$dateofbirth = $b[$i]->date();
						last;
					}
				}
			} else {
				# TODO:  This is in more for debugging
				#	to make sure that the record's value
				#	is included in the bio
				complain({ person => $person, warning => [ $b[$i], ' is not a ref' ] });
				my @r = $person->get_record('birth');
				foreach my $item(@{$r[$i]->{'items'}}) {
					if(($item->tag() eq '_PRIM') && ($item->value() eq 'Y')) {
						$dateofbirth = $r[$i]->date();
						last;
					}
				}
			}
		}

		if(!defined($dateofbirth)) {
			complain({ person => $person, warning => "Two dates of birth ($d[0]/$d[1]), neither of which is marked primary" });
			$dateofbirth = $d[0];
		}
	} elsif(scalar(@d) == 1) {
		$dateofbirth = $d[0];
	} elsif(scalar(@d)) {
		# More than one date - are they all the same?
		while(defined($d[1]) && ($d[1] !~ /\sor\s/) && (datecmp($d[0], $d[1]) == 0)) {
			shift @d;
		}
		if(scalar(@d) == 1) {
			complain({ person => $person, warning => "Removed duplicate dates of birth ($d[0])" });
			return parse_date({ date => $d[0], type => 'Birth', person => $person });
		}
		complain({ person => $person, warning => [ 'TODO: handle more than 2 dates of birth: ', conjunction(map { year(date => $_) } @d) ] });
		# die "TODO: handle more than 2 dates of birth ($d[0]/$d[1])";
		return;
	}

	if((!defined($dateofbirth)) && (my $birth = $person->get_record('birth'))) {
		$dateofbirth = $birth->date();
	}
	if((!defined($dateofbirth)) && (my $birth = $person->get_record('birt'))) {
		$dateofbirth = $birth->date();
	}
	if(defined($dateofbirth)) {
		if($dateofbirth eq '?') {
			return undef;
		}
		if($dateofbirth =~ /\s$/) {
			complain({ person => $person, warning => "Removing trailing spaces from date of birth '$dateofbirth'" });
			$dateofbirth =~ s/\s+$//;
		}
		if($dateofbirth =~ /^0\d{3}/) {
			complain({ person => $person, warning => "Removing leading zeroes from date of birth '$dateofbirth'" });
			$dateofbirth =~ s/^0+//;
		}
		return parse_date({ date => $dateofbirth, type => 'Birth', person => $person });
	}
	return;	# return undef
}

sub dateofmarriage
{
	my %params;

	if(ref($_[0]) eq 'HASH') {
		%params = %{$_[0]};
	} elsif(scalar(@_) % 2 == 0) {
		%params = @_;
	} else {
		$params{'person'} = shift;
	}

	my $person = $params{'person'};

	# my $dateofmarriage = get_value({ person => $person, value => 'marriage date' });
	# if((!defined($dateofmarriage)) && (my $marriage = $person->get_record('marriage') || $person->get_record('fams marriage'))) {
		# $dateofmarriage = $marriage->date();
	# }

	# return parse_date({ date => $dateofmarriage, type => 'Marriage', person => $person });

	my @d = get_value({ person => $person, value => 'marriage date' });
	my $dateofmarriage;

	if(scalar(@d) == 2) {	# TODO: && dates not the same
		my ($year1, $year2);

		if($d[0] =~ /(\d{3,4})/) {
			$year1 = $1;
		}
		if($d[1] =~ /(\d{3,4})/) {
			$year2 = $1;
		}
		if(defined($year1) && defined($year2)) {
			if(abs($year1 - $year2) > 30) {
				complain({ person => $person, warning => 'More than one date of marriage separated by many years' });
			}
		}

		# Get the primary date.
		# TODO: Is there a proper way to do this with the Gedcom module?
		# FIXME: limited to 2 dates
		my @b = $person->marriage();

		for my $i(0..1) {
			foreach my $item(@{$b[$i]->{'items'}}) {
				if(($item->tag() eq '_PRIM') && ($item->value() eq 'Y')) {
					$dateofmarriage = $b[$i]->date();
					last;
				}
			}
		}
		if(!defined($dateofmarriage)) {
			complain({ person => $person, warning => 'two dates of marriage, neither of which is marked primary' });
			$dateofmarriage = $d[0];
		}
	} elsif(scalar(@d) == 1) {	# TODO: || scalar == 2 && dates are the same, though warn then
		$dateofmarriage = $d[0];
	} elsif(scalar(@d)) {
		complain({ person => $person, warning => [ 'TODO: handle more than 2 dates of marriage: ', conjunction(map { year(date => $_) } @d) ] });
		# die 'TODO: handle more than 2 dates of marriage';
		return;
	}

	if((!defined($dateofmarriage)) && (my $marriage = $person->get_record('marriage') // $person->get_record('fams marriage'))) {
		$dateofmarriage = $marriage->date();
	}
	if(defined($dateofmarriage)) {
		if($dateofmarriage =~ /\s$/) {
			complain({ person => $person, warning => "Removing trailing spaces from date of marriage '$dateofmarriage'" });
			$dateofmarriage =~ s/\s+$//;
		}
		if($dateofmarriage =~ /^About[:\s](.+)/i) {
			$dateofmarriage = "ABT $1";
		}
		if($opts{'w'} && ($dateofmarriage =~ /\d{3,4}$/) && (my $dateofbirth = dateofbirth($person))) {
			if(($dateofbirth =~ /\d{3,4}$/) && (datecmp($dateofmarriage, $dateofbirth) <= 0)) {
				complain({ person => $person, warning => "Date of marriage ($dateofmarriage) is before date of birth ($dateofbirth)" });
			}
		}
		return parse_date({ date => $dateofmarriage, type => 'Marriage', person => $person });
	}
	return;	# return undef
}

sub dateofdeath
{
	my %params;

	if(ref($_[0]) eq 'HASH') {
		%params = %{$_[0]};
	} elsif(scalar(@_) % 2 == 0) {
		%params = @_;
	} else {
		$params{'person'} = shift;
	}

	my $person = $params{'person'};

	my $dateofdeath = get_value({ person => $person, value => 'death date' });
	if((!defined($dateofdeath)) && (my $death = $person->get_record('death'))) {
		$dateofdeath = $death->date();
	}
	if(defined($dateofdeath)) {
		if($dateofdeath =~ /died at birth/i) {
			complain({ person => $person, warning => 'Getting date of death from date of birth' });
			return dateofbirth(%params);
		}
		if($dateofdeath =~ /\s$/) {
			complain({ person => $person, warning => "Removing trailing spaces from date of death '$dateofdeath'" });
			$dateofdeath =~ s/\s+$//;
		}
		if($dateofdeath =~ /\d+[\/\-]\d+[\/\-]\d+/) {
			complain({ person => $person, warning => "Invalid date format for date of death '$dateofdeath'" });
		} else {
			if(($dateofdeath =~ /^[a-z]/) && ($dateofdeath !~ /^(bef|abt|aft|bet)/i)) {
				complain({ person => $person, warning => "Capitalizing month in date of death '$dateofdeath'" });
				$dateofdeath = ucfirst($dateofdeath);
			}
			return parse_date({ date => $dateofdeath, type => 'Death', person => $person });
		}
	}
	return;	# undef
}

# Dig the date out of a field and return in a valid gedcom format
sub parse_date
{
	my %params;

	if(ref($_[0]) eq 'HASH') {
		%params = %{$_[0]};
	} elsif(scalar(@_) % 2 == 0) {
		%params = @_;
	} else {
		$params{'date'} = shift;
	}

	if(my $date = $params{'date'}) {
		if(lc($date) eq 'unknown') {
			return;
		}
		if(length($date) == 0) {
			return;
		}

		my $type = $params{'type'};
		my $person = $params{'person'};
		my $after;
		my $before;
		my $about;

		if($date =~ /^After\s+(.+)/i) {
			complain({ person => $person, warning => "$type date says 'After' instead of 'Aft'" });
			$date = $1;
			$after = 1;
		} elsif($date =~ /^Before\s+(.+)/i) {
			complain({ person => $person, warning => "$type date says 'Before' instead of 'Bef'" });
			$date = $1;
			$before = 1;
		} elsif($date =~ /^aft\s(.+)/i) {
			$date = $1;
			$after = 1;
		} elsif($date =~ /^bef\s(.+)/i) {
			$date = $1;
			$before = 1;
		} elsif($date =~ /^abt\s+(.+)/i) {
			$date = $1;
			$about = 1;
		}
		if($date =~ /[A-Z]{4,}/i) {
			complain({ person => $person, warning => "$type month '$date' should be 3 letters" });
			if($date =~ /from (.+) to (.+)/i) {
				return "bet $1 and $2";
			}
			if($date =~ /(.*\d{4})\s+(.+)/) {
				complain({ person => $person, warning => "$type date: removing trailing text '$2'" });
				$date = $1;
			}
			if($date =~ /^([\d\s]*)([A-Z]{4,})\.?\s+([\d\/]+)$/i) {
				if(lc($2) eq 'about') {
					return "abt $3";
				}
				# FIXME: assumes the months are in English
				return $1 . ucfirst(lc(substr($2, 0, 3))) . " $3";
			}
			if($date =~ /^([A-Z]{3,})\s+(\d+),?\s+([\d\/]+)$/i) {	# U.S. format - Jul 4 instead of 4 Jul
				# FIXME: assumes the months are in English
				my $rc = "$2 " . ucfirst(lc(substr($1, 0, 3))) . " $3";
				complain({ person => $person, warning => "$date changed to $rc" });
				return $rc;
			}
			my $i = 0;
			while((my @call_details = caller($i++))) {
				print STDERR "\t", colored($call_details[2] . ' of ' . $call_details[1], 'red'), "\n";
			}
			die 'BUG: handle "', $params{'date'}, ' on ', $person->as_string();
		}
		if($about) {
			$date = "abt $date";
		}
		if($after) {
			return "aft $date";
		} elsif($before) {
			return "bef $date";
		}
		return $date;
	}
}

sub dump_places {
	my $all_places = shift;
	my $year = shift;

	return if(scalar(keys(%{$all_places})) == 0);

	# my $g;
	# if(my $oa = $ENV{'OPENADDR_HOME'}) {
		# $g = Geo::Coder::Free::OpenAddresses->new(openaddr => $oa);
	# }
	print '"Location","People"', "\n" if($opts{'x'});
	print '<?xml version="1.0" encoding="UTF-8"?>', "\n",
		'<kml xmlns="http://www.opengis.net/kml/2.2">', "\n",
		"<Document>\n" if($opts{'g'});
	my %printed;
	my $url;
	foreach my $place(sort keys %{$all_places}) {
		my $location;
		if($opts{'x'}) {
			$place =~ s/"//g;
			print "\"$place\",\"";
		} elsif($opts{'g'}) {
			if($location = get_location($place)) {
				my $x_place = $place;
				$x_place =~ s/&/&amp;/g;
				print "\t<Placemark>\n",
					"\t\t<name>$x_place</name>\n",
					"\t\t<description>";
			} else {
				# warn "'$place' not found";
				next;
			}
		} elsif($opts{'M'}) {
			if($location = get_location($place)) {
				my $lat = $location->lat();
				my $long = $location->long();
				if(!defined($printed{$long}{$lat})) {
					if($url) {
						$url .= '~';
					} else {
						$url = 'https://static-maps.yandex.ru/1.x/?lang=en_US&ll=0.68,51.20&z=9&l=map&size=650,450&pt=';
					}
					$url .= "$long,$lat,round";
					$printed{$long}{$lat} = 1;
				}
			} else {
				warn "'$place' not found";
			}
			next;
		} elsif($opts{'P'}) {
			print "$place\n";
			next;
		} else {
			# $opts{'r'}
			print "$place: ";
		}
		my $previous;
		foreach my $person(@{$all_places->{$place}}) {
			if($previous && ($person->xref() eq $previous->xref())) {
				next;
			}
			print $person->as_string({ include_years => 1, middle_names => 1, nee => 1 }),
				';';
			$previous = $person;
		}
		print '"' if($opts{'x'});
		if($opts{'g'}) {
			print "</description>\n",
				"\t\t<Point>\n",
				"\t\t\t<coordinates>",
					$location->long(),
					',',
					$location->lat(),
				"</coordinates>\n",
				"\t\t</Point>\n",
				"\t</Placemark>\n";
		} else {
			print "\n";
		}
		# if($g && ($place =~ /USA|Canada/)) {
			# my @locations = $g->geocode($place);
			# if(scalar(@locations) == 0) {
				# # complain(person => $person, warning => "$place not found in Geo::Coder::Free");
				# warn colored(['red'], "$place not found in Geo::Coder::Free");
			# }
		# }
	}
	print "</Document>\n</kml>\n" if($opts{'g'});
	if($opts{'M'} && $url) {
		my $resp = $cached_browser->get($url);
		if($resp->is_success()) {
			my $filename = sprintf("frame%02d.png", $year);
			if(open(my $fout, '>', $filename)) {
				binmode($fout);
				print $fout $resp->decoded_content();
			}
			return $filename;
		}
	}
}

sub dump_occupations {
	my $all_occupations = shift;

	return if(scalar(keys(%{$all_occupations})) == 0);

	foreach my $occupation(sort keys %{$all_occupations}) {
		print "$occupation: ";
		my $previous;
		foreach my $person(@{$all_occupations->{$occupation}}) {
			if($previous && ($person->xref() eq $previous->xref())) {
				next;
			}
			print $person->as_string({ include_years => 1, middle_names => 1, nee => 1 }),
				';';
			$previous = $person;
		}
		print "\n";
	}
}

# Given a place return its latitude and longitude
sub get_location($)
{
	return unless(defined($geocoder));

	my $place = shift;

	if(!defined($place)) {
		print "\n";
		my $i = 0;
		while((my @call_details = caller($i++))) {
			print STDERR "\t", colored($call_details[2] . ' of ' . $call_details[1], 'red'), "\n";
		}
		die 'BUG: place argument not given';
	}

	print "get_location: $place\n" if($opts{'v'});

	# Translate to English so that Geo::Coder::List can choose the right geocoder
	if(ref($place) eq 'Lingua::String') {
		$place = $place->en();
		print "English translation: $place\n" if($opts{'v'});
	} elsif($lcm && ($place =~ /(.+),\s*(.+)$/)) {
		if($2 ne 'England') {
			my $c = $2;
			# utf8::encode($c);
			if(($language eq 'French') && ($c eq 'Angleterre')) {
				$place = "$1, England";
			} elsif(my $code = $lcm->country2code($c, 'LOCALE_CODE_ALPHA_2', get_language_code())) {
				$c = $lcm->code2country($code, 'en');
				if($c eq 'United States') {
					$c = 'USA';
				}
				$place = "$1, $c";
			}
			print "English translation: $place\n" if($opts{'v'});
		}
	}

	$place =~ s/^\s+//;
	if($language eq 'French') {
		$place =~ s/^\N{U+00E0}\s+//;
	} else {
		$place =~ s/^at\s+//;
		$place =~ s/^on\s+//;
	}

	my @locations = $geocoder->geocode($place);	# Use array to improve caching

	if(my $location = shift @locations) {
		if(ref($location) eq 'Geo::Location::Point') {
			return $location;
		}
		if(defined($location->{geometry}{location}{lat}) && defined($location->{geometry}{location}{lng})) {
			print Data::Dumper->new([$location])->Dump() if($opts{'v'});
			my $rc = Class::Simple->new();
			$rc->long($location->{geometry}{location}{lng});
			$rc->longitude($location->{geometry}{location}{lng});
			$rc->lat($location->{geometry}{location}{lat});
			$rc->latitude($location->{geometry}{location}{lat});
			return $rc;
		}
		if($opts{'w'}) {
			$Data::Dumper::Maxdepth = 0;
			print Data::Dumper->new([\$location])->Dump();
			print Data::Dumper->new([\@locations])->Dump();
			complain("Probable bug in Geo::Coder::List with '$place'");
		}
	}
}

sub dump_geocoder_log
{
	return unless($opts{'v'});
	return unless(defined($geocoder));

	my $log = $geocoder->log();
	$geocoder->flush();
	print Data::Dumper->new([$log])->Dump() if($log);

	foreach my $l(@{$log}) {
		if($l->{'line'}) {
			print 'Line ', $l->{'line'}, ': ';
		}
		if($l->{'error'}) {
			print $l->{'error'}, ', ';
		}
		if($l->{geocoder}) {
			if($l->{error}) {
				print $l->{location}, ': ', $l->{timetaken}, 's with ', $l->{geocoder}, '(', $l->{error}, ")\n";
			} else {
				print $l->{location}, ': ', $l->{timetaken}, 's with ', $l->{geocoder}, "\n";
			}
		} else {
			print $l->{location}, ": cached\n";
		}
	}
}

# Capitalise the first character
sub sortoutcase {
	my $field = lc(shift);

	my $ret = '';

	foreach my $word (split(/\s/, $field)) {
		if($ret ne '') {
			$ret .= ' ';
		}
		my @list = split(/-/, $word);
		if(scalar(@list) > 1) {
			foreach (@list) {
				if($ret ne '') {
					$ret .= '-';
				}
				$ret .= ucfirst($_);
			}
		} else {
			$ret .= ucfirst($word);
		}
	}

	return $ret;
}

sub isbrother
{
	my $person = shift;
	my $other = shift;

	return unless($other);

	my $other_xref = $other->xref();

	my @siblings = $person->siblings();
	foreach my $sibling(@siblings) {
		if(($sibling->sex() eq 'M') && ($sibling->xref() eq $other_xref)) {
			return 1;
		}
	}
	return 0;
}

sub issister
{
	my $person = shift;
	my $other = shift;

	return unless($other);

	my $other_xref = $other->xref();

	my @siblings = $person->siblings();
	foreach my $sibling(@siblings) {
		if(($sibling->sex() eq 'F') && ($sibling->xref() eq $other_xref)) {
			return 1;
		}
	}
	return 0;
}

# See also https://github.com/SBECK-github/Date-Manip/issues/34
sub get_year_from_date($)
{
	my $string = shift;
	if($string =~ /(\d{3,4})\s*$/) {
		return $1;
	}
	if($string =~ /(.+)\s(\d{4})\/\d{1,2}/) {
		my $year = $2 + 1;
		complain("old-style string ($string) should be in $year");
		return $year;
	}
	if(my $year = UnixDate(ParseDate($string), '%Y')) {	# Date::Manip
		$year =~ s/^0+//;	# Strip leading zeros
		return $year;
	}
	complain("Can't parse string '$string'");
}

# https://www.gnu.org/software/gettext/manual/html_node/Locale-Environment-Variables.html
# https://www.gnu.org/software/gettext/manual/html_node/The-LANGUAGE-variable.html
sub get_language
{
	if($ENV{'LANGUAGE'}) {
		my %langs = (
			'br' => 'Breton',
			'de' => 'German',
			'en' => 'English',
			'fr' => 'French',
			'fa' => 'Farsi',
			'la' => 'Latin'
		);
		foreach my $language(split/:/, $ENV{'LANGUAGE'}) {
			if(my $rc = $langs{$language}) {
				return $rc;
			}
		}
	}
	foreach my $variable('LC_ALL', 'LC_MESSAGES', 'LANG') {
		my $val = $ENV{$variable};
		next unless(defined($val));

		if($val =~ /^en/) {
			return 'English';
		}
		if($val =~ /^fr/) {
			return 'French';
		}
		if($val =~ /^de/) {
			return 'German';
		}
		if($val =~ /^fa/) {
			return 'Farsi';
		}
		if($val =~ /^la/) {
			return 'Latin';
		}
		if($val =~ /^br/) {
			return 'Breton';
		}
	}
	complain("Can't determine the language, falling back to English");
	return 'English';
}

sub get_language_code {
	if($ENV{'LANGUAGE'}) {
		if($ENV{'LANGUAGE'} =~ /^([a-z]{2})/i) {
			return lc($1);
		}
	}
	foreach my $variable('LC_ALL', 'LC_MESSAGES', 'LANG') {
		my $val = $ENV{$variable};
		next unless(defined($val));

		if($val =~ /^([a-z]{2})/i) {
			return lc($1);
		}
	}
	if(defined($ENV{'LANG'}) && (($ENV{'LANG'} =~ /^C\./) || ($ENV{'LANG'} eq 'C'))) {
		return 'en';
	}
	return;	# undef
}

# TODO:	format containing ':'
# FIXME: German nouns start with a capital letter
sub i18n
{
	my %params;

	if(ref($_[0]) eq 'HASH') {
		%params = %{$_[0]};
	} elsif((scalar(@_) % 2 == 0) && ref($_[1])) {
		%params = @_;
	} else {
		$params{'format'} = lc(shift);
		$params{'args'} = \@_;
	}

	my $format = $params{'format'};
	if(!defined($format)) {
		print "\n";
		my $i = 0;
		while((my @call_details = caller($i++))) {
			print STDERR "\t", colored($call_details[2] . ' of ' . $call_details[1], 'red'), "\n";
		}
		die 'BUG: format argument not given';
	}

	my $prepend_space;
	if($format =~ /^\s(.+)$/) {
		$format = $1;
		$prepend_space = 1;
	}
	my $append_space;
	if($format =~ /^(.+)\s$/) {
		$format = $1;
		$append_space = 1;
	}
	my $append_comma;
	if($format =~ /^(.+),$/) {
		$format = $1;
		$append_comma = 1;
	}

	if($i18n) {
		my $translation;
		my $person = $params{'person'};
		$translation = $i18n->{$format};
		if(ref($translation) eq 'HASH') {
			if(!defined($person)) {
				print STDERR "\n";
				my $i = 0;
				while((my @call_details = caller($i++))) {
					print STDERR "\t", colored($call_details[2] . ' of ' . $call_details[1], 'red'), "\n";
				}
				die "BUG: '$format' requires the person argument to determine gender";
			}
			$translation = $translation->{$person->sex()};
		}

		if($translation) {
			if($translation =~ /%/) {	# FIXME: %%
				if(ref($params{'args'}) eq 'ARRAY') {
					$translation = sprintf($translation, @{$params{'args'}});
				} elsif(ref($params{'args'})) {
					$translation = sprintf($translation, $params{'args'}->as_string());
				} elsif(length($params{'args'}) == 0) {
					print STDERR "\n";
					my $i = 0;
					while((my @call_details = caller($i++))) {
						print STDERR "\t", colored($call_details[2] . ' of ' . $call_details[1], 'red'), "\n";
					}
					die "BUG: '$format' requires non-empty argument";
				} else {
					my $arg = $params{'args'};
					utf8::encode($arg);
					$translation = sprintf($translation, $arg);
				}
			}
			utf8::decode($translation);
			$translation .= ',' if($append_comma);
			$translation .= ' ' if($append_space);
			if($prepend_space) {
				return " $translation";
			}
			return $translation;
		}

		my $i = 0;
		print "\n";
		while((my @call_details = caller($i++))) {
			print STDERR "\t", colored($call_details[2] . ' of ' . $call_details[1], 'red'), "\n";
		}
		die $format;
	}
	if($format =~ /%/) {	# FIXME: %%
		if(ref($params{'args'}) eq 'ARRAY') {
			$format = sprintf($format, @{$params{'args'}});
		} else {
			$format = sprintf($format, $params{'args'});
		}
	}
	utf8::decode($format);
	$format .= ' ' if($append_space);
	if($prepend_space) {
		return " $format";
	}
	return $format;
}

sub between
{
	if(my $phrase = shift) {
		if($phrase =~ /^fro?m (.+) to (.+)/i) {
			return i18n('between ') . conjunction($1, $2);
		}
		return $phrase;
	}
}

# Create an array that will allow fast access to each element
sub cache_array {
	if(ref($_[0]) && ref($_[0] eq 'ARRAY')) {
		return map { Class::Simple::Readonly::Cached->new({ object => $_, cache => {} }) } @_;
	}
	return @_;
}

# Print notes about the death, if any
sub add_death_notes
{
	my %params;

	if(ref($_[0]) eq 'HASH') {
		%params = %{$_[0]};
	} elsif(scalar(@_) % 2 == 0) {
		%params = @_;
	}

	my $person = $params{'person'};
	my $death = $params{'record'};	# death record
	my $phrase = $params{'phrase'};

	return unless($death);

	die 'BUG: add_death_notes, argument missing' unless(defined($person) && defined($phrase));

	# Cause of death
	if(my $cause = $person->cause()) {
		$cause = lc($cause);
		$phrase->append(" ($cause)");
	}
	if(my $notes = notes({ person => $person, record => $death, paragraph => 0 })) {
		# FIXME: If the notes are so long they go over
		#	a page split into more than one page
		#	properly rather than don't print, as now
		if((!$opts{'B'}) || (length($notes) < 4000)) {
			$notes =~ tr/\r//;
			$notes =~ tr/\n/ /;
			$notes =~ s/[\.,]$//;
			$notes = lcfirst($notes) unless($notes =~ /^[A-Z]{2}/);
			$phrase->append(" ($notes)");
		}
	}
}

# Get the weather for the day
sub weather
{
	my %params;

	if(ref($_[0]) eq 'HASH') {
		%params = %{$_[0]};
	} elsif(scalar(@_) % 2 == 0) {
		%params = @_;
	}

	# my $person = $params{'person'};
	my $record = $params{'record'};	# death record
	my $meteo = $params{'meteo'};

	if(!$record) {
		print STDERR "\n";
		my $i = 0;
		while((my @call_details = caller($i++))) {
			print STDERR "\t", colored($call_details[2] . ' of ' . $call_details[1], 'red'), "\n";
		}
		die 'Usage: weather(person, record, meteo)';
	}

	my $date = $record->date();

	return unless($date);
	return if($date !~ /^\d/);

	if((my $d = $dfg->parse_datetime(date => $date)) &&
	   (my $location = get_location($record->place()))) {
		my $weather = $meteo->weather($location, $d->strftime('%F'));

		return unless(defined($weather));

		my $temperature = $weather->{'daily'}->{'temperature_2m_max'}[0];
		my $wmo = $weather->{'daily'}->{'weathercode'}[0];

		if($wmo == 0) {
			if($temperature <= 16) {
				return 'a mild and sunny day';
			}
			if($temperature <= 5) {
				return 'a cold and sunny day';
			}
			return 'a warm, sunny day';
		} elsif($wmo == 2) {
			return 'a partly cloudy day';
		} elsif($wmo == 3) {
			if($temperature <= 5) {
				return 'a cold and overcast day';
			}
			return 'an overcast day';
		} elsif(($wmo == 51) || ($wmo == 53) || ($wmo == 55)) {
			if($temperature >= 22) {
				return 'a warm but drizzly day';
			}
			return 'a drizzly day';
		} elsif($wmo == 61) {
			return 'a day with light rain';
		} elsif($wmo == 63) {
			return 'a rainy day';
		} elsif($wmo == 71) {
			return 'a day with light snow';
		} elsif($wmo == 73) {
			if($temperature <= 5) {
				return 'a cold day with snow';
			}
			return 'a day with snow';
		} elsif($temperature < 5) {
			return 'a cold day';
		} elsif($wmo <= 1) {
			if($temperature >= 21) {
				return 'a warm and sunny day';
			}
			if($temperature >= 30) {
				return 'a hot and sunny day';
			}
			if($temperature <= 5) {
				return 'a hot but sunny day';
			}
			return 'a sunny day';
		} else {
			die "TODO: parse weather (wmo = $wmo, temperature = $temperature)";
		}
	}
}

sub append_notes
{
	my %params;

	if(ref($_[0]) eq 'HASH') {
		%params = %{$_[0]};
	} elsif(scalar(@_) % 2 == 0) {
		%params = @_;
	}

	if(my $notes = notes(\%params)) {
		my $phrase = $params{'phrase'};

		$phrase->append(' ') if($phrase->length());

		$notes = lcfirst($notes) unless($notes =~ /^(RAF|Royal Navy|Royal Flying Corps)/);
		$notes =~ s/[\s\.]+$//;
		$notes =~ tr/\r//;
		$notes =~ s/hms /HMS /ig;
		# Parse service information
		if($notes =~ /^regiment:\s+(.+)/i) {
			my $regiment = $1;
			my $service_number;
			if($regiment =~ /(.+)\s+Service number: (.+)/) {
				$regiment = $1;
				$service_number = $2;
			}
			if($regiment =~ /(.+);\s+Rank:\s+(.+)/i) {
				$regiment = $1;
				my $rank = $2;

				if($service_number && ($regiment =~ /(.+)\((.+)\)(.*)/)) {
					if(defined($3)) {
						$regiment = "$1($2 - service number $service_number)$3";
					} else {
						$regiment = "$1($2 - service number $service_number)";
					}
				}
				$rank =~ s/[\s\.;]+$//;
				if($rank eq 'A/cpl') {
					$rank = 'Acting Corporal';
				}
				$phrase->append("in the $regiment with the rank of $rank");
			} else {
				$regiment =~ s/[\s\.;]+$//;
				if($service_number && ($regiment =~ /(.+)\((.+)\)(.*)/)) {
					if(defined($3)) {
						$regiment = "$1($2 - service number $service_number)$3";
					} else {
						$regiment = "$1($2 - service number $service_number)";
					}
				}
				$phrase->append("in the $regiment");
			}
		} elsif($notes =~ /pFC US Army/) {
			if($notes =~ /Korea/) {
				$phrase->append('in Korea with the rank of private first class');
			} else {
				$phrase->append('with the rank of private first class');
			}
		} else {
			$phrase->append("($notes)");
		}
		return 1;
	}
	return 0;
}

# Given an array of siblings and my date of birth, return an array of which of them are my twins
# Allow for a twin being born a day before or after this person
sub twins
{
	my %params;

	if(ref($_[0]) eq 'HASH') {
		%params = %{$_[0]};
	} elsif(scalar(@_) % 2 == 0) {
		%params = @_;
	}

	my $birth_dt = $params{'birth_dt'};
	my @siblings = @{$params{'siblings'}};
	my @twins;

	foreach my $s(@siblings) {
		if(my $dob = dateofbirth($s)) {
			if(($dob =~ /^\d/) && ($dob !~ /[a-z]$/i)) {
				my $d;
				eval {
					$d = $date_parser->parse(date => $dob);
				};
				if($d && ($d = $d->[0])) {
					$d = $dfn->parse_datetime($d->{'canonical'});
					if(($d == $birth_dt) || ($d == ($birth_dt - $oneday)) || ($d == ($birth_dt + $oneday))) {
						push @twins, { sibling => $s, dob => $d };
					}
				}
			}
		}
	}

	return @twins;
}

sub person_in_residence_record
{
	my %params;

	if(ref($_[0]) eq 'HASH') {
		%params = %{$_[0]};
	} elsif(scalar(@_) % 2 == 0) {
		%params = @_;
	}

	my $person = $params{'person'};
	my $date = $params{'date'};

	foreach my $event(get_all_residences($person)) {
		my $edate = $event->date();
		if($edate && ($edate !~ /^bet\s/i) && ($edate !~ /[,\-]/) && (datecmp($edate, $date) == 0)) {
			return 1;
		}
	}

	return 0;
}

# Encode to HTML whatever the non-ascii encoding scheme has been chosen
#
# See https://www.compart.com/en/unicode/U+0161 etc.
#	https://www.compart.com/en/unicode/U+00EB
#
# keep_hrefs => 1 means ensure hyperlinks still work
# keep_apos => 1 means keep apostraphes, useful within <script>
# TODO: don't transform anything within <script>...</script>
sub wide_to_html
{
	my %params;

	if(ref($_[0]) eq 'HASH') {
		%params = %{$_[0]};
	} elsif(scalar(@_) % 2 == 0) {
		%params = @_;
	} elsif(scalar(@_) == 1) {
		$params{'string'} = shift;
	}

	my $string = $params{'string'};
	if(!defined($string)) {
		my $i = 0;
		while((my @call_details = caller($i++))) {
			print STDERR "\t", colored($call_details[2] . ' of ' . $call_details[1], 'red'), "\n";
		}
		die 'BUG: string not set';
	}

	# print STDERR __LINE__, ": ($string)";
	# print STDERR (sprintf '%v02X', $string);
	# print STDERR "\n";
	# my $i = 0;
	# while((my @call_details = caller($i++))) {
		# print STDERR "\t", colored($call_details[2] . ' of ' . $call_details[1], 'red'), "\n";
	# }

	$string = HTML::Entities::decode($string);
	# $string =~ s/ & / &amp; /g;
	$string =~ s/&ccaron;/Ä/g;	# I don't think HTML::Entities does this
	$string =~ s/&zcaron;/Å¾/g;	# I don't think HTML::Entities does this
	$string =~ s/&/&amp;/g;

	unless($params{'keep_hrefs'}) {
		$string =~ s/</&lt;/g;
		$string =~ s/>/&gt;/g;
		$string =~ s/"/&quot;/g;
	}

	# $string =~ s/&db=/&amp;db=/g;
	# $string =~ s/&id=/&amp;id=/g;

	unless($params{'keep_apos'}) {
		$string =~ s/'/&apos;/g;
		$string =~ s/â/&apos;/g;
		$string =~ s/â/&apos;/g;
		$string =~ s/â/&apos;/g;
	}

	if($string !~ /[^[:ascii:]]/) {
		return $string;
	}

	$string =~ s/\xc2\xa9/&copy;/g;
	$string =~ s/\xc2\xae/&reg;/g;
	$string =~ s/\xc3\xa1/&aacute;/g;
	$string =~ s/\xc3\xa2/&acirc;/g;
	$string =~ s/\xc3\xa4/&auml;/g;
	$string =~ s/\xc3\xa9/&eacute;/g;
	$string =~ s/\xc3\xb4/&ocirc;/g;	# Ã´
	$string =~ s/\xc5\xa1/&scaron;/g;
	$string =~ s/\xc4\x8d/&ccaron;/g;
	$string =~ s/\xc5\xbe/&zcaron;/g;
	$string =~ s/\xc3\xa7/&ccedil;/g;
	$string =~ s/\xc3\xb3/&oacute;/g;
	$string =~ s/\xc3\x96/&Ouml;/g;	# Ã
	$string =~ s/\xc3\xa8/&egrave;/g;
	$string =~ s/\xc3\x89/&Eacute;/g;
	$string =~ s/\xc3\xaa/&ecirc;/g;
	$string =~ s/\xc3\xab/&euml;/g;
	$string =~ s/\xc3\xae/&icirc;/g;
	$string =~ s/\xc3\xbb/&ucirc;/g;
	$string =~ s/\xc5\x9b/&sacute;/g;
	$string =~ s/\xc5\xa0/&Scaron;/g;
	$string =~ s/\xe2\x80\x93/&ndash;/g;
	$string =~ s/\xc3\xb1/&ntilde;/g;	# Ã±

	$string =~ s/\N{U+00A9}/&copy;/g;
	$string =~ s/\N{U+00AE}/&reg;/g;
	$string =~ s/\N{U+0161}/&scaron;/g;
	$string =~ s/\N{U+010D}/&ccaron;/g;
	$string =~ s/\N{U+017E}/&zcaron;/g;
	$string =~ s/\N{U+00E1}/&aacute;;/g;
	$string =~ s/\N{U+00E2}/&acirc;/g;
	$string =~ s/\N{U+00E4}/&auml;/g;
	$string =~ s/\N{U+00E8}/&egrave;/g;
	$string =~ s/\N{U+00E9}/&eacute;/g;
	$string =~ s/\N{U+00EE}/&icirc;/g;
	$string =~ s/\N{U+00D6}/&Ouml;/g;	# Ã
	$string =~ s/\N{U+00E7}/&ccedil;/g;	# Ã§
	$string =~ s/\N{U+00F4}/&ocirc;/g;	# Ã´
	$string =~ s/\N{U+00C9}/&Eacute;/g;
	$string =~ s/\N{U+00CA}/&ecirc;/g;
	$string =~ s/\N{U+00EB}/&euml;/g;
	$string =~ s/\N{U+00F3}/&oacute;/g;
	$string =~ s/\N{U+015B}/&sacute;/g;
	$string =~ s/\N{U+00FB}/&ucirc;/g;
	$string =~ s/\N{U+0160}/&Scaron;/g;
	$string =~ s/\N{U+2013}/&ndash;/g;

	# utf8::encode($string);
	# $string =~ s/Å¡/&scaron;/g;
	# $string =~ s/Ä/&ccaron;/g;
	# $string =~ s/Å¾/&zcaron;/g;
	# $string =~ s/Ã©/&eacute;/g;
	# $string =~ s/Ã§/&ccedil;/g;
	# $string =~ s/\N{U+0161}/&scaron;/g;
	# $string =~ s/\N{U+010D}/&ccaron;/g;
	# $string =~ s/\N{U+017E}/&zcaron;/g;
	# $string =~ s/\N{U+00E9}/&eacute;/g;
	# $string =~ s/\N{U+00D6}/&Ouml;/g;	# Ã
	# $string =~ s/\N{U+00E7}/&ccedil;/g;	# Ã§
	# $string =~ s/\N{U+00E8}/&egrave;/g;
	# $string =~ s/\N{U+00E9}/&Eacute;/g;

	# print STDERR __LINE__, ": ($string)";
	# print STDERR (sprintf '%v02X', $string);
	# print STDERR "\n";

	# utf8::decode($string);

	# print STDERR __LINE__, ": ($string)";
	# # print STDERR (sprintf '%v02X', $string);
	# print STDERR "\n";

	# $string =~ s/\xe4\x8d/&ccaron;/g;	# ? ACOM strangeness
	# $string =~ s/\N{U+0161}/&scaron;/g;
	# $string =~ s/\N{U+010D}/&ccaron;/g;
	# $string =~ s/\N{U+00A9}/&copy;/g;
	# $string =~ s/\N{U+00AE}/&reg;/g;
	# $string =~ s/\N{U+00E2}/&acirc;/g;
	# $string =~ s/\N{U+00E4}/&auml;/g;
	# $string =~ s/\N{U+00E8}/&egrave;/g;
	# $string =~ s/\N{U+00E9}/&eacute;/g;
	# $string =~ s/\N{U+00EB}/&euml;/g;
	# $string =~ s/\N{U+00F3}/&oacute;/g;
	# $string =~ s/\N{U+00FB}/&ucirc;/g;
	# $string =~ s/\N{U+017E}/&zcaron;/g;
	# $string =~ s/\N{U+00D6}/&Ouml;/g;	# Ã
	# $string =~ s/\N{U+00E7}/&ccedil;/g;	# Ã§
	# $string =~ s/\N{U+00C9}/&Eacute;/g;
	# $string =~ s/\N{U+00CA}/&ecirc;/g;
	# $string =~ s/\N{U+0160}/&Scaron;/g;	# FIXME: also above
	# $string =~ s/\N{U+2013}/-/g;

	$string =~ s/Å¡/&scaron;/g;
	$string =~ s/Ä/&ccaron;/g;
	$string =~ s/Å¾/&zcaron;/g;
	$string =~ s/Ã¡/&aacute;/g;
	$string =~ s/Ã¢/&acirc;/g;
	$string =~ s/Ã©/&eacute;/g;
	$string =~ s/Ã¨/&egrave;/g;
	$string =~ s/Ã§/&ccedil;/g;
	$string =~ s/Ãª/&ecirc;/g;
	$string =~ s/Ã«/&euml;/g;
	$string =~ s/Â©/&copy;/g;
	$string =~ s/Â®/&reg;/g;
	$string =~ s/Ã³/&oacute;/g;
	$string =~ s/Ã´/&ocirc;/g;
	$string =~ s/Å/&sacute;/g;
	$string =~ s/Ã»/&ucirc;/g;
	$string =~ s/Â£/&pound;/g;
	$string =~ s/â/&ndash;/g;
	$string =~ s/Ã±/&#x0F1;/g;
	$string =~ tr/\x80/ /;

	# if($string =~ /^Maria\(/) {
		# # print STDERR (unpack 'H*', $string);
		# print STDERR __LINE__, ': ';
		# print STDERR (sprintf '%v02X', $string);
		# print STDERR "\n";
		# my $i = 0;
		# while((my @call_details = caller($i++))) {
			# print STDERR "\t", colored($call_details[2] . ' of ' . $call_details[1], 'red'), "\n";
		# }
		# # die $string;
	# }

	# print STDERR __LINE__, ": ($string)\n";
	return $string;
}

# Lookup entry in dbpedia.
# TODO: Look up maiden name and married name(s)
# Experimental code with false positives at the moment
sub dbpedia
{
	my %params = (ref($_[0]) eq 'HASH') ? %{$_[0]} : @_;

	my $person = $params{'person'};
	my $yod = $params{'yod'};
	my $birth_dt = $params{'birth_dt'};
	my $yob = $params{'yob'};

	if(defined($birth_dt) && $birth_dt) {
		if(!ref($birth_dt)) {
			print STDERR "\n";
			my $i = 0;
			while((my @call_details = caller($i++))) {
				print STDERR "\t", colored($call_details[2] . ' of ' . $call_details[1], 'red'), "\n";
			}
			die "birth_dt ($birth_dt) is not a ref";
		}
		$yob = $birth_dt->year();
	}

	my $name = $person->name();
	$name =~ s/\///g;
	$nameparser->parse($name);
	my %name_components = $nameparser->components();
	my $firstname = $name_components{'given_name_1'} // $person->given_names // $name_components{'initials_1'};
	if($firstname) {
		$firstname =~ s/\'/\\\'/g;
		$firstname = Unicode::Diacritic::Strip::strip_diacritics($firstname);
	} else {
		$firstname = 'NULL';
	}
	# my $surname = $name_components{'surname_1'};
	my $surname = ucfirst(lc($person->surname()));
	if($surname) {
		$surname =~ s/\'/\\\'/g;
		$surname = Unicode::Diacritic::Strip::strip_diacritics($surname);
	} else {
		$surname = 'NULL';
	}

	my $url = "https://lookup.dbpedia.org/api/search?query=$firstname%20$surname";
	print "$url\n" if($opts{'v'});
	if(($firstname ne '?') && (my $resp = $browser->get($url))) {
		if($resp->is_success()) {
			if(my $arrayofresults = XML::Hash->new()->fromXMLStringtoHash($resp->decoded_content())->{'ArrayOfResults'}) {
				RESULT: foreach my $result(@{$arrayofresults->{'Result'}}) {
					if($result->{'Classes'}->{'Class'} &&
					   (ref($result->{'Classes'}->{'Class'}) eq 'ARRAY')) {
						my @classes = @{$result->{'Classes'}->{'Class'}};
						foreach my $class(@classes) {
							if(($class->{'Label'}->{'text'} eq 'Place') ||
							   ($class->{'Label'}->{'text'} eq 'School') ||
							   ($class->{'Label'}->{'text'} eq 'Work') ||
							   ($class->{'Label'}->{'text'} eq 'Event') ||
							   ($class->{'Label'}->{'text'} eq 'Holiday') ||
							   ($class->{'Label'}->{'text'} eq 'Plant') ||
							   ($class->{'Label'}->{'text'} eq 'Artwork')) {
								next RESULT;
							}
						}
					}
					if($result->{'Label'}->{'text'} &&
					   ($result->{'Label'}->{'text'} =~ /$firstname([a-z\s]+)$surname/i) &&
					   (my $description = $result->{'Description'})) {
						if(my $t = $description->{'text'}) {
							next if($t !~ /$firstname([a-z\s]+)$surname\s/i);
							if($t =~ /\(born\s.*?(\d{4})\D*?\)/) {
								my $b = $1;
								if(defined($yod) && ($yod < $b)) {
									# Died before the dbpedia person was born
									next;
								}
								if(defined($yob) && ($yob != $b)) {
									# Born different year from the dbpedia person was born
									next;
								}
							} elsif($t =~ /\(died\s.*?(\d{4})\)/) {
								my $d = $1;
								if(defined($yob) && ($yob > $d)) {
									# Born after dbpedia person died
									next;
								}
							} elsif($t =~ /\((\d{4})\x{2013}\d{4}\)/) {
								my $b = $1;
								if(defined($yod) && ($yod < $b)) {
									# Died before the dbpedia person was born
									next;
								}
								if(defined($yob) && ($yob != $b)) {
									# Born different year from the dbpedia person was born
									next;
								}
							} elsif($t =~ /\(c\. \d{4} \x{2013} (\d{4})\)/) {
								my $d = $1;
								if(defined($yob) && ($yob > $d)) {
									# Born after the dbpedia person died
									next;
								}
							} elsif($t =~ /may refer to:$/) {
								# TODO: recursive checking
								complain('TODO: also check ' . $result->{'URI'}->{'text'});
								next;
							}
							my @dts = DateTime::Format::Text->parse_datetime($t);
							if((scalar(@dts) == 1) && (defined(my $dt = $dts[0]))) {
								if($birth_dt && ($dt < $birth_dt)) {
									$dt = $dt->delta_days($birth_dt);
									if(($dt->{'days'} / 356) > 2) {
										# Born more than 2 years after
										# the dbpedia event
										next;
									}
								# } elsif(defined($yob) && ($yob != $dt->year())) {
									# next;
								}
							}
							if(scalar(@dts) == 2) {
								if(defined($yob) && (($yob != $dts[0]->year()) || ($yob > $dts[1]->year()))) {
									next;
								}
								if(defined($yod)) {
									if($yod < $dts[0]->year()) {
										next;
									}
									if($yod < ($dts[1]->year() - 40)) {
										# Died more than 40 years before the
										# dbpedia person
										next;
									}
								}
							} elsif($result->{'Categories'}->{'Category'}) {
								# Try to guess other info
								my @categories;
								if(ref($result->{'Categories'}->{'Category'}) eq 'ARRAY') {
									@categories = @{$result->{'Categories'}->{'Category'}};
								} else {
									@categories = ( $result->{'Categories'}->{'Category'} );
								}
								foreach my $category(@categories) {
									my $uri = $category->{'URI'}->{'text'};
									if(($uri =~ /Category:Teaching_hospitals/) ||
									   ($uri =~ /Category:Public_housing/) ||
									   ($uri =~ /Category:Defunct_companies/) ||
									   ($uri =~ /Category:Songs_/) ||
									   ($uri =~ /Category:Fictional/) ||
									   ($uri =~ /Category:Seismological_observatories/)) {
										next RESULT;
									}
									if(defined($yod)) {
										if($uri =~ /Living_people$/) {
											# dbpedia person is alive, ours is not
											next RESULT;
										}
										if($uri =~ /Category:(\d{4})_deaths$/) {
											my $d = $1;
											if($yod != $d) {
												# Died different year from the dbpedia person died
												next RESULT;
											}
										} elsif($uri =~ /(\d\d)th-century_/) {
											my $c = ($1 + 1) * 100;
											if(defined($yob) && ($yob > $c)) {
												# Born after dbpedia event
												next RESULT;
											}
										}
									}
									if(defined($yob)) {
										if($uri =~ /Category:(\d{4})_births$/) {
											my $b = $1;
											if(defined($yod) && ($yod < $b)) {
												# Died before the dbpedia person was born
												next RESULT;
											}
											if($yob != $b) {
												# Born different year from the dbpedia person was born
												next RESULT;
											}
										} elsif(($uri =~ /(\d{3,4})s_deaths/)) {
											if($yob > ($1 + 10)) {
												# Born after the end of the decade this person died
												next RESULT;
											}
										} elsif($uri =~ /(\d\d)th-century_deaths/) {
											my $c = ($1 + 1) * 100;
											if($yob > $c) {
												# Born after dbpedia person died
												next RESULT;
											}
										} elsif($uri =~ /Category:(\d{4})_deaths$/) {
											my $d = $1;
											if($yob > $d) {
												# Born after this person died
												next RESULT;
											}
										}
									}
									warn ">>>>>>>>>> $uri";
								}
							}
							$Data::Dumper::Maxdepth = 0;
							print STDERR Data::Dumper->new([\$result])->Dump();
							return $t;
						}
					}
				}
			}
		} else {
			complain({ person => $person, warning => "$url: $firstname $surname failed: " . $resp->status_line() });
		}
	}
}

# Parse a Newspaper event
# These are in FindMyPast records
sub newspaper
{
	my %params = (ref($_[0]) eq 'HASH') ? %{$_[0]} : @_;

	my $event = $params{'event'};

	my $rc = Class::Simple->new();

	if(my $date = $event->date()) {
		$date =~ s/^0//;
		$rc->date($date);
	}

	# my $source = $event->source();
	if(ref(my $source = $event->source())) {
		$rc->url($source->tag_record('REF')->value());
		$rc->title('a newspaper');
	} else {
		$source = get_source({ source => $source, %params });
		if(my $title = $source->title()) {
			$title =~ s/\.$//;
			$rc->title($title);
		}

		$source = $event->tag_record('SOUR');
		$rc->url($source->tag_record('REF')->value());

		if(my $page = $source->tag_record('PAGE')) {
			$page = $page->value();
			$page =~ s/^0+//;
			$rc->page($page);
		}

		# my @items = $source->items();
		# $Data::Dumper::Maxdepth = 2;
		# die Data::Dumper->new([\@items])->Dump();
	}

	return $rc;
}

# Avoid end of sentences such as "with his twin sister Jane E.."
sub given_names
{
	my %params;

	if(ref($_[0]) eq 'HASH') {
		%params = %{$_[0]};
	} elsif(scalar(@_) % 2 == 0) {
		%params = @_;
	} elsif(scalar(@_) == 1) {
		$params{'person'} = shift;
	}

	if(my $given = $params{'person'}->given_names()) {
		$given =~ s/\.$//;
		return $given;
	}
}

# Must all be in lower case
__DATA__
@@ English
a %s::a %s
a day before::a day before
after %s::after %s
all with %s::all with %s
also::also
also%s::also%s
an %s::an %s
and::and
arrived::arrived
at::at
before %s::before %s
between::between
birthplace::birthplace
both with %s::both with %s
brother::brother
brother-in-law::brother-in-law
brothers::brothers
check out %s::check out %s
child::child
children::children
daughter::daughter
died::died
during %s::during %s
during %s life::during %s life
eldest::eldest
father::father
following the death of::following the death of
from::from
funeral::funeral
grandchildren::grandchildren
great-grandchildren::great-grandchildren
had::had
has had::has had
has lived::has lived
has lived at %s::has lived at %s
has lived in %s::has lived in %s
he::he
husband::husband
is::is
is buried::is buried
is married to::is married to
later that same year::later that same year
married::married
mother::mother
of::of
of %d children::of %d children
older::older
on the same day::on the same day
on your father's side::on your father's side
on your mother's side::on your mother's side
parents::parents
she::she
sister::sister
sister-in-law::sister-in-law
sisters::sisters
son::son
the same day as::the same day as
they::they
times::times
to::to
today::today
tomorrow::tomorrow
twice::twice
twin of::twin of
was::was
was buried::was buried
was born::was born
was living::was living
was married to::was married to
when::when
wife::wife
with::with
with %s::with %s
your::your
@@ Breton
and::ha
son::mab
@@ French
a %s:M:un %s
a %s:F:une %s
a day before::la veille
after %s::aprÃ¨s le %s
all with %s::tout avec %s
also::aussi
also%s::aussi%s
an %s:M:un %s
an %s:F:une %s
and::et
arrived:M:est arrivÃ©
arrived:F:est arrivÃ©e
at::Ã 
before %s::avant le %s
between::entre
birthplace::ville natale
both with %s::tous les deux avec %s
brother::frÃ¨re
brother-in-law::beau-frÃ¨re
check out %s::visitez %s
child::enfant
children::enfants
daughter::fille
died:M:est mort
died:F:est morte
during %s::en %d
during %s life::au cours de sa vie
eldest:M:aÃ®nÃ©
eldest:F:aÃ®nÃ©e
father::pÃ¨re
following the death of::suite au mort de
from::de
has had::a eu
had::a eu
has lived::a habitÃ©
has lived at %s::a habitÃ© Ã  %s
has lived in %s::a habitÃ© en %s
he::il
husband::marie
is::est
is buried:M:est inhumÃ©
is buried:F:est inhumÃ©e
is married to:M:est mariÃ© Ã 
is married to:F:est mariÃ©e Ã 
later that same year::plus tard la mÃªme annÃ©e
married::a mariÃ©
mother::mÃ¨re
of::de
of %d children::de %d enfants
older:M:aÃ®nÃ©
older:F:aÃ®nÃ©e
on the same day::sur la mÃªme jour
on your father's side::du cÃ´tÃ© paternel
on your mother's side::du cÃ´tÃ© de votre mÃ¨re
parents::parents
she::elle
sister::sÅur
sister-in-law::belle-sÅur
sisters::sÅurs
son::fils
today::aujourd'hui
tomorrow::demain
the same day as::le mÃªme jour comme
they:M:ils
they:F:elles
times::temps
to::Ã 
twice::deux fois
twin of:F:jumelle de
twin of:M:jumeau de
was::Ã©tait
was buried:M:a Ã©tÃ© inhumÃ©
was buried:F:a Ã©tÃ© inhumÃ©e
was born:M:est nÃ©
was born:F:est nÃ©e
was living::habitait
was married to:M:a Ã©tÃ© mariÃ© Ã 
was married to:F:a Ã©tÃ© mariÃ©e Ã 
when::lorsque
wife::femme
with::avec
with %s::avec %s
your::votre
@@ German
a %s:M:ein %s
a %s:F:eine %s
a %s:N:ein %s
an %s:M:ein %s
an %s:F:eine %s
an %s:N:ein %s
a day before::einen Tag vorher
all with %s::alles mit %s
also::auch
also%s::auch%s
and::und
arrived::kam
at::in der
before %s::vor %s
between::zwischen
birthplace::Geburtsort
both with %s::beide mit %s
brother::Bruder
brothers::BrÃ¼der
check out %s::Schau mal bei %s
child::Kind
children::Kinder
daughter::Tochter
died::starb
during %s life:M:wÃ¤hrend seines Lebens
during %s life:F:wÃ¤hrend ihres Lebens
eldest::Ã¤lteste
father::Vater
following the death of::Nach dem Tod von
from::von
funeral::funeral
grandchildren::Enkelkinder
great-grandchildren::Urenkelkinder
has had::hatte
had::hatte
has lived in %s::hat in %s gelebt
he::er
husband::Mann
is::ist
is buried::ist begraben
is married to::ist verheiratet
later that same year::spÃ¤ter im gleichen Jahr
married::verheiratet
mother::Mutter
of::von
of %d children::von %d Kindern
on your father's side::Auf der Seite deines Vaters
parents::Eltern
she::sie
sister::Schwester
sisters::Schwestern
son::Sohn
the head of household::der Haushaltsvorstand
the same day as::die gleichen Tag als
times::fache
they::Sie
to::nach
today::heute
was::war
was born::wurde geboren
was married to %s::war mit %s verheiratet
wife::Frau
with::mit
youngest::jÃ¼ngsten
your::Ihr
@@ Latin
and::et
brother::frÄter
father::pater
husband::maritus
mother::mater
sister::soror
wife::uxor
@@ Spanish
he::Ã©l
father::padre
is::es
she::ella
__END__
