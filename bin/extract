#!/usr/bin/env perl

# Test the extract_family_info routine with varying obituaries

use strict;
use warnings;

use Data::Dumper;

unless(caller()) {
	my $info = extract_family_info($ARGV[0]);
	print Data::Dumper->new([$info])->Dump();
	$info = parse_obituary($ARGV[0]);
	print Data::Dumper->new([$info])->Dump();
}

sub extract_family_info
{
	my $text = shift;
	my %family;

	# Helper to extract people from a specific section and remove empty entries
	sub extract_people_section {
		my $section = shift;
		return unless $section;

		$section =~ s/\s+and\s+/, /g;  # Ensure "and" is treated as a separator
		$section =~ s/([A-Za-z]+),\s+([A-Z]{2})/$1<<COMMA>>$2/g;
		my @entries = split /\s*,\s*/, $section;

		my @people;
		foreach my $entry (@entries) {
			$entry =~ s/<<COMMA>>/, /g;

			my ($name, $spouse, $location) = ('', '', '');

			# Match "Ian (Terry) Girvan of Surrey, BC"
			if ($entry =~ /^(\w+)\s+\(([^)]+)\)\s+(\w+)\s+of\s+(.+)$/) {
				$name = "$1 $3"; $spouse = $2; $location = $4;
			}
			# Match "Gwen Steeves (Leslie) of Riverview, NB"
			elsif ($entry =~ /^(.+?)\s+\(([^)]+)\)\s+of\s+(.+)$/) {
				$name = $1; $spouse = $2; $location = $3;
			}
			# Match "Carol Girvan of Dartmouth, NS"
			elsif ($entry =~ /^(.+?)\s+of\s+(.+)$/) {
				$name = $1; $location = $2;
			}
			# Match names only (e.g. for siblings)
			else {
				$name = $entry;
			}

			next if !$name;  # Skip if name is empty
			next if($name =~ /^father-in-law\sto\s/);	# Skip follow ons

			# Create a hash and filter out blank fields
			my %person = (
				name	 => $name,
				spouse   => $spouse,
				location => $location,
			);

			# Remove blank fields
			%person = map { $_ => $person{$_} } grep { defined $person{$_} && $person{$_} ne '' } keys %person;

			push @people, \%person;
		}
		return \@people;
	}

	# Correct extraction of children (skipping "his/her")
	if ($text =~ /survived by (his|her) children\s*([^\.;]+)/i) {
		my $children_text = $2;
		$family{children} = extract_people_section($children_text);
	} elsif ($text =~ /Loving father of\s*([^\.;]+)/i) {  # Look for the phrase "Loving father of"
		# Correct extraction of children (skipping "his/her")
		my $children_text = $1;
		$family{children} = extract_people_section($children_text);
	}

	# Extract grandchildren
	$family{grandchildren} = [ split /\s*(?:,|and)\s*/i, ($text =~ /grandchildren\s+([^\.;]+)/i)[0] || '' ];

	# Extract siblings (sisters and brothers) correctly, skipping "her" or "his"
	if ($text =~ /predeceased by (his|her) sisters?\s*([^;]+);?/i) {
		my $sisters_text = $2;
		$family{sisters} = extract_people_section($sisters_text);
	}

	if ($text =~ /predeceased by (his|her) brothers?\s*([^;]+);?/i) {
		my $brothers_text = $2;
		$family{brothers} = extract_people_section($brothers_text);
	}

	# Detect nieces/nephews
	$family{nieces_nephews} = ($text =~ /as well as several nieces and nephews/i) ? ['several nieces and nephews'] : [];

	# Extract parents and clean the names by removing unnecessary details
	if ($text =~ /daughter of the late\s+(.+?)\s+and\s+(.+)/i) {
		my $parent1 = $1;
		my $parent2 = $2;

		# Remove anything after the first comma in each parent's name
		$parent1 =~ s/,.*//;
		$parent2 =~ s/,.*//;

		# Remove blank location field if empty
		$family{parents} = [
			{
				name	 => $parent1,
				# no location field included as it is empty
			},
			{
				name	 => $parent2,
				# no location field included as it is empty
			},
		];
	}

	# Extract spouse's death year and remove the "(year)" from the name
	if($text =~ /wife of the late\s+([\w\s]+)\s+\((\d{4})\)/) {
		my $name = $1;
		my $death_year = $2;
		$family{'spouse'} ||= [];

		# Remove the death year part from the spouse's name
		$name =~ s/\s*\(\d{4}\)//;

		push @{$family{'spouse'}}, {
			name => $name,
			death_year => $death_year
		}
	} elsif($text =~ /wife of\s+([\w\s]+)/) {
		my $name = $1;
		$family{'spouse'} ||= [];

		push @{$family{'spouse'}}, { name => $name }
	} elsif($text =~ /husband to the late\s([\w\s]+)[\s\.]/i) {
		my $name = $1;
		$family{'spouse'} ||= [];

		push @{$family{'spouse'}}, { name => $name }
	}

	# Ensure spouse location is properly handled
	if (exists $family{spouse} && defined $family{spouse}[0]{location} && $family{spouse}[0]{location} eq 'the late') {
		delete $family{spouse}[0]{location};
	}

	# Extract the funeral information
	if ($text =~ /funeral service.*?at\s+([^\n]+)\s+on\s+([^\n]+)\s+at\s+([^\n]+)/i) {
		$family{funeral} = {
			location => $1,
			date	 => $2,
			time	 => $3,
		};
	}

	# Extract father-in-law and mother-in-law information (if present)
	if($text =~ /father-in-law to\s+([A-Za-z\s]+)/) {
		my $father_in_law = $1;
		$family{children_in_law} = [{ name => $father_in_law }];
	} elsif($text =~ /mother-in-law to\s+([A-Za-z\s]+)/i) {
		my $mother_in_law = $1;
		$family{children_in_law} = [ split /\s*(?:,|and)\s*/i, ($text =~ /mother-in-law to\s+([^\.;]+)/i)[0] || '' ];
		if(scalar($family{children_in_law} == 0)) {
			$family{children_in_law} = [{ name => $mother_in_law }];
		}
	}

	# Remove blank fields from the main family hash
	%family = map { $_ => $family{$_} } grep { defined $family{$_} && $family{$_} ne '' } keys %family;

	# Remove empty arrays the family hash
	foreach my $key (keys %family) {
		if (ref($family{$key}) eq 'ARRAY' && @{$family{$key}} == 0) {
			delete $family{$key};
		}
	}

	return \%family;
}

sub parse_obituary {
    my ($text) = @_;
    my %results = ( people => [], places => [], relationships => {} );

    # Extract people with titles (Dr., Mr., etc.)
    while ($text =~ /\b(Mr|Mrs|Ms|Dr)\.?\s+([A-Z][a-z-]+(?:\s+[A-Z][a-z-]+)+)\b/gi) {
        push @{$results{people}}, $2;
    }

    # Extract relationships and their associated names (e.g., children: Alice, Bob)
    my @relationship_phrases = (
        "children", "siblings", "brothers", "sisters", 
        "survived by", "husband of", "wife of", "father of", "mother of"
    );

    for my $rel (@relationship_phrases) {
        while ($text =~ /$rel\s*[:,]?\s*([A-Za-z\s,.()]+?)(?=\.|\b(?:and|$))/gi) {
            my $names_str = $1;
            # Split names by commas/and, clean, and add to relationships
            my @names = split(/,\s*|\s+and\s+/, $names_str);
            for my $name (@names) {
                $name =~ s/^\s+|\s+$//g;  # Trim whitespace
                $name =~ s/[.,()]+$//g;    # Remove trailing punctuation
                push @{$results{relationships}{$rel}}, $name if $name =~ /\S/;
                push @{$results{people}}, $name if $name =~ /\S/;
            }
        }
    }

    # Extract places (unchanged from earlier)
    while ($text =~ /(died|born|passed away|resided|buried|funeral)\s+(?:in|at)\s+([A-Z][a-z-.,]+(?:\s+[A-Z][a-z-.,]+)*)/gi) {
        my $place = $2;
        $place =~ s/[.,]$//;
        push @{$results{places}}, $place;
    }

    # Deduplicate entries
    my %seen;
    @{$results{people}} = grep { !$seen{$_}++ } @{$results{people}};
    %seen = ();
    @{$results{places}} = grep { !$seen{$_}++ } @{$results{places}};

    return \%results;
}

1;
